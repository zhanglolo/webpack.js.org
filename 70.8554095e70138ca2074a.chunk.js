(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{366:function(n,e,s){"use strict";s.r(e),e.default='<blockquote class="tip">\n<p>本指南继续沿用 <a href="/guides/getting-started">起步</a>、<a href="/guides/output-management">管理输出</a> 和 <a href="/guides/code-splitting">代码分离</a> 中的代码示例。</p>\n</blockquote>\n<p>以上，我们使用 webpack 来打包我们的模块化后的应用程序，webpack 会生成一个可部署的 <code>/dist</code> 目录，然后把打包后的内容放置在此目录中。只要 <code>/dist</code> 目录中的内容部署到 server 上，client（通常是浏览器）就能够访问此 server 的网站及其资源。而最后一步获取资源是比较耗费时间的，这就是为什么浏览器使用一种名为 <a href="https://searchstorage.techtarget.com/definition/cache">缓存</a> 的技术。可以通过命中缓存，以降低网络流量，使网站加载速度更快，然而，如果我们在部署新版本时不更改资源的文件名，浏览器可能会认为它没有被更新，就会使用它的缓存版本。由于缓存的存在，当你需要获取新的代码时，就会显得很棘手。</p>\n<p>此指南的重点在于通过必要的配置，以确保 webpack 编译生成的文件能够被客户端缓存，而在文件内容变化后，能够请求到新的文件。</p>\n<h2 id="output-filenames">输出文件的文件名(output filename) <a href="#output-filenames" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>我们可以通过替换 <code>output.filename</code> 中的 <a href="/configuration/output/#outputfilename">substitutions</a> 设置，来定义输出文件的名称。webpack 提供了一种使用称为 <strong>substitution(可替换模板字符串)</strong> 的方式，通过带括号字符串来模板化文件名。其中，<code>[contenthash]</code> substitution 将根据资源内容创建出唯一 hash。当资源内容发生变化时，<code>[contenthash]</code> 也会发生变化。</p>\n<p>这里使用 <a href="/guides/getting-started">起步</a> 中的示例和 <a href="/guides/output-management">管理输出</a> 中的 <code>plugins</code> 插件来作为项目基础，所以我们依然不必手动地维护 <code>index.html</code> 文件：</p>\n<p><strong>project</strong></p>\n<pre><code class="hljs language-diff">webpack-demo\n|- package.json\n|- webpack.config.js\n|- /dist\n|- /src\n  |- index.js\n|- /node_modules</code></pre>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n  const { CleanWebpackPlugin } = require(\'clean-webpack-plugin\');\n  const HtmlWebpackPlugin = require(\'html-webpack-plugin\');\n\n  module.exports = {\n    entry: \'./src/index.js\',\n    plugins: [\n      // 对于 CleanWebpackPlugin 的 v2 versions 以下版本，使用 new CleanWebpackPlugin([\'dist/*\'])\n      new CleanWebpackPlugin(),\n      new HtmlWebpackPlugin({\n<span class="token deleted">-       title: \'Output Management\',</span>\n<span class="token inserted">+       title: \'Caching\',</span>\n      }),\n    ],\n    output: {\n<span class="token deleted">-     filename: \'bundle.js\',</span>\n<span class="token inserted">+     filename: \'[name].[contenthash].js\',</span>\n      path: path.resolve(__dirname, \'dist\'),\n    },\n  };</code></pre>\n<p>使用此配置，然后运行我们的 build script <code>npm run build</code>，产生以下输出：</p>\n<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n                       Asset       Size  Chunks                    Chunk Names\nmain.7e2c49a622975ebd9b7e.js     544 kB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  main\n                  index.html  197 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>\n<span class="token punctuation">..</span>.</code></pre>\n<p>可以看到，bundle 的名称是它内容（通过 hash）的映射。如果我们不做修改，然后再次运行构建，我们以为文件名会保持不变。然而，如果我们真的运行，可能会发现情况并非如此：</p>\n<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n                       Asset       Size  Chunks                    Chunk Names\nmain.205199ab45963f6a62ec.js     544 kB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  main\n                  index.html  197 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>\n<span class="token punctuation">..</span>.</code></pre>\n<p>这也是因为 webpack 在入口 chunk 中，包含了某些 boilerplate(引导模板)，特别是 runtime 和 manifest。（译注：boilerplate 指 webpack 运行时的引导代码）</p>\n<blockquote class="warning">\n<p>输出可能会因当前的 webpack 版本而稍有差异。与旧版本相比，新版本不一定有完全相同的问题，但我们仍然推荐的以下步骤，确保结果可靠。</p>\n</blockquote>\n<h2 id="extracting-boilerplate">提取引导模板(extracting boilerplate) <a href="#extracting-boilerplate" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>正如我们在 <a href="/guides/code-splitting">代码分离</a> 中所学到的，<a href="/plugins/split-chunks-plugin/"><code>SplitChunksPlugin</code></a> 可以用于将模块分离到单独的 bundle 中。webpack 还提供了一个优化功能，可使用 <a href="/configuration/optimization/#optimizationruntimechunk"><code>optimization.runtimeChunk</code></a> 选项将 runtime 代码拆分为一个单独的 chunk。将其设置为 <code>single</code> 来为所有 chunk 创建一个 runtime bundle：</p>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n  const { CleanWebpackPlugin } = require(\'clean-webpack-plugin\');\n  const HtmlWebpackPlugin = require(\'html-webpack-plugin\');\n\n  module.exports = {\n    entry: \'./src/index.js\',\n    plugins: [\n      // 对于 CleanWebpackPlugin 的 v2 versions 以下版本，使用 new CleanWebpackPlugin([\'dist/*\'])\n      new CleanWebpackPlugin(),\n      new HtmlWebpackPlugin({\n        title: \'Caching\',\n      }),\n    ],\n    output: {\n      filename: \'[name].[contenthash].js\',\n      path: path.resolve(__dirname, \'dist\'),\n    },\n<span class="token inserted">+   optimization: {</span>\n<span class="token inserted">+     runtimeChunk: \'single\',</span>\n<span class="token inserted">+   },</span>\n  };</code></pre>\n<p>再次构建，然后查看提取出来的 <code>runtime</code> bundle：</p>\n<pre><code class="hljs language-bash">Hash: 82c9c385607b2150fab2\nVersion: webpack 4.12.0\nTime: 3027ms\n                          Asset       Size  Chunks             Chunk Names\nruntime.cc17ae2a94ec771e9221.js   1.42 KiB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  runtime\n   main.e81de2cf758ada72f306.js   69.5 KiB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  main\n                     index.html  275 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>\n<span class="token punctuation">[</span>1<span class="token punctuation">]</span> <span class="token punctuation">(</span>webpack<span class="token punctuation">)</span>/buildin/module.js 497 bytes <span class="token punctuation">{</span>1<span class="token punctuation">}</span> <span class="token punctuation">[</span>built<span class="token punctuation">]</span>\n<span class="token punctuation">[</span>2<span class="token punctuation">]</span> <span class="token punctuation">(</span>webpack<span class="token punctuation">)</span>/buildin/global.js 489 bytes <span class="token punctuation">{</span>1<span class="token punctuation">}</span> <span class="token punctuation">[</span>built<span class="token punctuation">]</span>\n<span class="token punctuation">[</span>3<span class="token punctuation">]</span> ./src/index.js 309 bytes <span class="token punctuation">{</span>1<span class="token punctuation">}</span> <span class="token punctuation">[</span>built<span class="token punctuation">]</span>\n    + 1 hidden module</code></pre>\n<p>将第三方库(library)（例如 <code>lodash</code> 或 <code>react</code>）提取到单独的 <code>vendor</code> chunk 文件中，是比较推荐的做法，这是因为，它们很少像本地的源代码那样频繁修改。因此通过实现以上步骤，利用 client 的长效缓存机制，命中缓存来消除请求，并减少向 server 获取资源，同时还能保证 client 代码和 server 代码版本一致。\n这可以通过使用 <a href="/plugins/split-chunks-plugin/#split-chunks-example-2">SplitChunksPlugin 示例 2</a> 中演示的 <a href="/plugins/split-chunks-plugin/"><code>SplitChunksPlugin</code></a> 插件的 <a href="/plugins/split-chunks-plugin/#splitchunkscachegroups"><code>cacheGroups</code></a> 选项来实现。我们在 <code>optimization.splitChunks</code> 添加如下 <code>cacheGroups</code> 参数并构建：</p>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n  const { CleanWebpackPlugin } = require(\'clean-webpack-plugin\');\n  const HtmlWebpackPlugin = require(\'html-webpack-plugin\');\n\n  module.exports = {\n    entry: \'./src/index.js\',\n    plugins: [\n      // 对于 CleanWebpackPlugin 的 v2 versions 以下版本，使用 new CleanWebpackPlugin([\'dist/*\'])\n      new CleanWebpackPlugin(),\n      new HtmlWebpackPlugin({\n        title: \'Caching\',\n      }),\n    ],\n    output: {\n      filename: \'[name].[contenthash].js\',\n      path: path.resolve(__dirname, \'dist\'),\n    },\n    optimization: {\n      runtimeChunk: \'single\',\n<span class="token inserted">+     splitChunks: {</span>\n<span class="token inserted">+       cacheGroups: {</span>\n<span class="token inserted">+         vendor: {</span>\n<span class="token inserted">+           test: /[\\\\/]node_modules[\\\\/]/,</span>\n<span class="token inserted">+           name: \'vendors\',</span>\n<span class="token inserted">+           chunks: \'all\',</span>\n<span class="token inserted">+         },</span>\n<span class="token inserted">+       },</span>\n<span class="token inserted">+     },</span>\n    },\n  };</code></pre>\n<p>再次构建，然后查看新的 <code>vendor</code> bundle：</p>\n<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n                          Asset       Size  Chunks             Chunk Names\nruntime.cc17ae2a94ec771e9221.js   1.42 KiB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  runtime\nvendors.a42c3ca0d742766d7a28.js   69.4 KiB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  vendors\n   main.abf44fedb7d11d4312d7.js  240 bytes       2  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  main\n                     index.html  353 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>\n<span class="token punctuation">..</span>.</code></pre>\n<p>现在，我们可以看到 <code>main</code> 不再含有来自 <code>node_modules</code> 目录的 <code>vendor</code> 代码，并且体积减少到 <code>240 bytes</code>！</p>\n<h2 id="module-identifiers">模块标识符(module identifier) <a href="#module-identifiers" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>在项目中再添加一个模块 <code>print.js</code>：</p>\n<p><strong>project</strong></p>\n<pre><code class="hljs language-diff">webpack-demo\n|- package.json\n|- webpack.config.js\n|- /dist\n|- /src\n  |- index.js\n<span class="token inserted">+ |- print.js</span>\n|- /node_modules</code></pre>\n<p><strong>print.js</strong></p>\n<pre><code class="hljs language-diff"><span class="token inserted">+ export default function print(text) {</span>\n<span class="token inserted">+   console.log(text);</span>\n<span class="token inserted">+ };</span></code></pre>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff">  import _ from \'lodash\';\n<span class="token inserted">+ import Print from \'./print\';</span>\n\n  function component() {\n    const element = document.createElement(\'div\');\n\n    // lodash 是由当前 script 脚本 import 进来的\n    element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');\n<span class="token inserted">+   element.onclick = Print.bind(null, \'Hello webpack!\');</span>\n\n    return element;\n  }\n\n  document.body.appendChild(component());</code></pre>\n<p>再次运行构建，然后我们期望的是，只有 <code>main</code> bundle 的 hash 发生变化，然而……</p>\n<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n                           Asset       Size  Chunks                    Chunk Names\n  runtime.1400d5af64fc1b7b3a45.js    5.85 kB      0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         runtime\n  vendor.a7561fb0e9a071baadb9.js     541 kB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  vendor\n    main.b746e3eb72875af2caa9.js    1.22 kB       2  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         main\n                      index.html  352 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>\n<span class="token punctuation">..</span>.</code></pre>\n<p>……我们可以看到这三个文件的 hash 都变化了。这是因为每个 <a href="/api/module-variables/#moduleid-commonjs"><code>module.id</code></a> 会默认地基于解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变。因此，简要概括：</p>\n<ul>\n<li><code>main</code> bundle 会随着自身的新增内容的修改，而发生变化。</li>\n<li><code>vendor</code> bundle 会随着自身的 <code>module.id</code> 的变化，而发生变化。</li>\n<li><code>manifest</code> runtime 会因为现在包含一个新模块的引用，而发生变化。</li>\n</ul>\n<p>第一个和最后一个都是符合预期的行为，<code>vendor</code> hash 发生变化是我们要修复的。我们将 <a href="/configuration/optimization/#optimizationmoduleids"><code>optimization.moduleIds</code></a> 设置为 <code>\'hashed\'</code>：</p>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n  const { CleanWebpackPlugin } = require(\'clean-webpack-plugin\');\n  const HtmlWebpackPlugin = require(\'html-webpack-plugin\');\n\n  module.exports = {\n    entry: \'./src/index.js\',\n    plugins: [\n      // 对于 CleanWebpackPlugin 的 v2 versions 以下版本，使用 new CleanWebpackPlugin([\'dist/*\'])\n      new CleanWebpackPlugin(),\n      new HtmlWebpackPlugin({\n        title: \'Caching\',\n      }),\n    ],\n    output: {\n      filename: \'[name].[contenthash].js\',\n      path: path.resolve(__dirname, \'dist\'),\n    },\n    optimization: {\n<span class="token inserted">+     moduleIds: \'hashed\',</span>\n      runtimeChunk: \'single\',\n      splitChunks: {\n        cacheGroups: {\n          vendor: {\n            test: /[\\\\/]node_modules[\\\\/]/,\n            name: \'vendors\',\n            chunks: \'all\',\n          },\n        },\n      },\n    },\n  };</code></pre>\n<p>现在，不论是否添加任何新的本地依赖，对于前后两次构建，<code>vendor</code> hash 都应该保持一致：</p>\n<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n                          Asset       Size  Chunks             Chunk Names\n   main.216e852f60c8829c2289.js  340 bytes       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  main\nvendors.55e79e5927a639d21a1b.js   69.5 KiB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  vendors\nruntime.725a1a51ede5ae0cfde0.js   1.42 KiB       2  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  runtime\n                     index.html  353 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>\nEntrypoint main <span class="token operator">=</span> runtime.725a1a51ede5ae0cfde0.js vendors.55e79e5927a639d21a1b.js main.216e852f60c8829c2289.js\n<span class="token punctuation">..</span>.</code></pre>\n<p>然后，修改 <code>src/index.js</code>，临时移除额外的依赖：</p>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff">  import _ from \'lodash\';\n<span class="token deleted">- import Print from \'./print\';</span>\n<span class="token inserted">+ // import Print from \'./print\';</span>\n\n  function component() {\n    const element = document.createElement(\'div\');\n\n    // lodash 是由当前 script 脚本 import 进来的\n    element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');\n<span class="token deleted">-   element.onclick = Print.bind(null, \'Hello webpack!\');</span>\n<span class="token inserted">+   // element.onclick = Print.bind(null, \'Hello webpack!\');</span>\n\n    return element;\n  }\n\n  document.body.appendChild(component());</code></pre>\n<p>最后，再次运行我们的构建：</p>\n<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n                          Asset       Size  Chunks             Chunk Names\n   main.ad717f2466ce655fff5c.js  274 bytes       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  main\nvendors.55e79e5927a639d21a1b.js   69.5 KiB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  vendors\nruntime.725a1a51ede5ae0cfde0.js   1.42 KiB       2  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  runtime\n                     index.html  353 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>\nEntrypoint main <span class="token operator">=</span> runtime.725a1a51ede5ae0cfde0.js vendors.55e79e5927a639d21a1b.js main.ad717f2466ce655fff5c.js\n<span class="token punctuation">..</span>.</code></pre>\n<p>我们可以看到，这两次构建中，<code>vendor</code> bundle 文件名称，都是 <code>55e79e5927a639d21a1b</code>。</p>\n<h2 id="conclusion">结论 <a href="#conclusion" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>缓存可能很复杂，但是从应用程序或站点用户可以获得的收益来看，这值得付出努力。想要了解更多信息，请查看下面<em>进一步阅读</em>部分。</p>\n'}}]);