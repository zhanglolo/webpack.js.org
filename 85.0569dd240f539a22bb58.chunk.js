(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{381:function(e,n,s){"use strict";s.r(n),n.default='<p>在本指南中，我们将深入一些最佳实践和工具，将站点或应用程序构建到生产环境中。</p>\n<blockquote class="tip">\n<p>以下示例来源于 <a href="/guides/tree-shaking">tree shaking</a> 和 <a href="/guides/development">开发环境</a>。在继续之前，请确保你已经熟悉这些指南中所介绍的概念/配置。</p>\n</blockquote>\n<h2 id="setup">配置 <a href="#setup" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p><em>development(开发环境)</em> 和 <em>production(生产环境)</em> 这两个环境下的构建目标存在着巨大差异。在<em>开发环境</em>中，我们需要：强大的 source map 和一个有着 live reloading(实时重新加载) 或 hot module replacement(热模块替换) 能力的 localhost server。而<em>生产环境</em>目标则转移至其他方面，关注点在于压缩 bundle、更轻量的 source map、资源优化等，通过这些优化方式改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写<strong>彼此独立的 webpack 配置</strong>。</p>\n<p>虽然，以上我们将<em>生产环境</em>和<em>开发环境</em>做了略微区分，但是，请注意，我们还是会遵循不重复原则(Don\'t repeat yourself - DRY)，保留一个 "common(通用)" 配置。为了将这些配置合并在一起，我们将使用一个名为 <a href="https://github.com/survivejs/webpack-merge"><code>webpack-merge</code></a> 的工具。此工具会引用 "common" 配置，因此我们不必再在环境特定(environment-specific)的配置中编写重复代码。</p>\n<p>我们先从安装 <code>webpack-merge</code> 开始，并将之前指南中已经成型的那些代码进行分离：</p>\n<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev webpack-merge</code></pre>\n<p><strong>project</strong></p>\n<pre><code class="hljs language-diff">  webpack-demo\n  |- package.json\n<span class="token deleted">- |- webpack.config.js</span>\n<span class="token inserted">+ |- webpack.common.js</span>\n<span class="token inserted">+ |- webpack.dev.js</span>\n<span class="token inserted">+ |- webpack.prod.js</span>\n  |- /dist\n  |- /src\n    |- index.js\n    |- math.js\n  |- /node_modules</code></pre>\n<p><strong>webpack.common.js</strong></p>\n<pre><code class="hljs language-diff"><span class="token inserted">+ const path = require(\'path\');</span>\n<span class="token inserted">+ const { CleanWebpackPlugin } = require(\'clean-webpack-plugin\');</span>\n<span class="token inserted">+ const HtmlWebpackPlugin = require(\'html-webpack-plugin\');</span>\n<span class="token inserted">+</span>\n<span class="token inserted">+ module.exports = {</span>\n<span class="token inserted">+   entry: {</span>\n<span class="token inserted">+     app: \'./src/index.js\',</span>\n<span class="token inserted">+   },</span>\n<span class="token inserted">+   plugins: [</span>\n<span class="token inserted">+     // 对于 CleanWebpackPlugin 的 v2 versions 以下版本，使用 new CleanWebpackPlugin([\'dist/*\'])</span>\n<span class="token inserted">+     new CleanWebpackPlugin(),</span>\n<span class="token inserted">+     new HtmlWebpackPlugin({</span>\n<span class="token inserted">+       title: \'Production\',</span>\n<span class="token inserted">+     }),</span>\n<span class="token inserted">+   ],</span>\n<span class="token inserted">+   output: {</span>\n<span class="token inserted">+     filename: \'[name].bundle.js\',</span>\n<span class="token inserted">+     path: path.resolve(__dirname, \'dist\'),</span>\n<span class="token inserted">+   },</span>\n<span class="token inserted">+ };</span></code></pre>\n<p><strong>webpack.dev.js</strong></p>\n<pre><code class="hljs language-diff"><span class="token inserted">+ const merge = require(\'webpack-merge\');</span>\n<span class="token inserted">+ const common = require(\'./webpack.common.js\');</span>\n<span class="token inserted">+</span>\n<span class="token inserted">+ module.exports = merge(common, {</span>\n<span class="token inserted">+   mode: \'development\',</span>\n<span class="token inserted">+   devtool: \'inline-source-map\',</span>\n<span class="token inserted">+   devServer: {</span>\n<span class="token inserted">+     contentBase: \'./dist\',</span>\n<span class="token inserted">+   },</span>\n<span class="token inserted">+ });</span></code></pre>\n<p><strong>webpack.prod.js</strong></p>\n<pre><code class="hljs language-diff"><span class="token inserted">+ const merge = require(\'webpack-merge\');</span>\n<span class="token inserted">+ const common = require(\'./webpack.common.js\');</span>\n<span class="token inserted">+</span>\n<span class="token inserted">+ module.exports = merge(common, {</span>\n<span class="token inserted">+   mode: \'production\',</span>\n<span class="token inserted">+ });</span></code></pre>\n<p>现在，在 <code>webpack.common.js</code> 中，我们设置了 <code>entry</code> 和 <code>output</code> 配置，并且在其中引入这两个环境公用的全部插件。在 <code>webpack.dev.js</code> 中，我们将 <code>mode</code> 设置为 <code>development</code>，并且为此环境添加了推荐的 <code>devtool</code>（强大的 source map）和简单的 <code>devServer</code> 配置。最后，在 <code>webpack.prod.js</code> 中，我们将 <code>mode</code> 设置为 <code>production</code>，其中会引入之前在 <a href="/guides/tree-shaking">tree shaking</a> 指南中介绍过的 <code>TerserPlugin</code>。</p>\n<p>注意，在环境特定的配置中使用 <code>merge()</code> 功能，可以很方便地引用 <code>webpack.dev.js</code> 和 <code>webpack.prod.js</code> 中公用的 common 配置。<code>webpack-merge</code> 工具提供了各种 merge(合并) 高级功能，但是在我们的用例中，无需用到这些功能。</p>\n<h2 id="npm-scripts">NPM Scripts <a href="#npm-scripts" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>现在，我们把 <code>scripts</code> 重新指向到新配置。让 <code>npm start</code> script 中 <code>webpack-dev-server</code>, 使用 <code>webpack.dev.js</code>, 而让 <code>npm run build</code> script 使用 <code>webpack.prod.js</code>:</p>\n<p><strong>package.json</strong></p>\n<pre><code class="hljs language-diff">  {\n    "name": "development",\n    "version": "1.0.0",\n    "description": "",\n    "main": "src/index.js",\n    "scripts": {\n<span class="token deleted">-     "start": "webpack-dev-server --open",</span>\n<span class="token inserted">+     "start": "webpack-dev-server --open --config webpack.dev.js",</span>\n<span class="token deleted">-     "build": "webpack"</span>\n<span class="token inserted">+     "build": "webpack --config webpack.prod.js"</span>\n    },\n    "keywords": [],\n    "author": "",\n    "license": "ISC",\n    "devDependencies": {\n      "clean-webpack-plugin": "^0.1.17",\n      "css-loader": "^0.28.4",\n      "csv-loader": "^2.1.1",\n      "express": "^4.15.3",\n      "file-loader": "^0.11.2",\n      "html-webpack-plugin": "^2.29.0",\n      "style-loader": "^0.18.2",\n      "webpack": "^4.30.0",\n      "webpack-dev-middleware": "^1.12.0",\n      "webpack-dev-server": "^2.9.1",\n      "webpack-merge": "^4.1.0",\n      "xml-loader": "^1.2.1"\n    }\n  }</code></pre>\n<p>随便运行下这些脚本，然后查看输出结果的变化，然后我们会继续添加一些<em>生产环境</em>配置。</p>\n<h2 id="specify-the-mode">指定 mode <a href="#specify-the-mode" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>许多 library 通过与 <code>process.env.NODE_ENV</code> 环境变量关联，以决定 library 中应该引用哪些内容。例如，当<code>process.env.NODE_ENV</code> 没有被设置为 <code>\'production\'</code> 时，某些 library 为了使调试变得容易，可能会添加额外的 log(日志记录) 和 test(测试) 功能。并且，在使用 <code>process.env.NODE_ENV === \'production\'</code> 时，一些 library 可能针对具体用户的环境，删除或添加一些重要代码，以进行代码执行方面的优化。从 webpack v4 开始, 指定 <a href="/configuration/mode/"><code>mode</code></a> 会自动地配置 <a href="/plugins/define-plugin"><code>DefinePlugin</code></a>：</p>\n<p><strong>webpack.prod.js</strong></p>\n<pre><code class="hljs language-diff">  const merge = require(\'webpack-merge\');\n  const common = require(\'./webpack.common.js\');\n\n  module.exports = merge(common, {\n    mode: \'production\',\n  });</code></pre>\n<blockquote class="tip">\n<p>技术上讲，<code>NODE_ENV</code> 是一个由 Node.js 暴露给执行脚本的系统环境变量。通常用于决定在开发环境与生产环境(dev-vs-prod)下，server tools(服务期工具)、build scripts(构建脚本) 和 client-side libraries(客户端库) 的行为。然而，与预期相反，在构建脚本 <code>webpack.config.js</code> 中<code>process.env.NODE_ENV</code> 并没有被设置为 <code>"production"</code>，请查看 <a href="https://github.com/webpack/webpack/issues/2537">#2537</a>。因此，在 webpack 配置文件中，<code>process.env.NODE_ENV === \'production\' ? \'[name].[hash].bundle.js\' : \'[name].bundle.js\'</code> 这样的条件语句，无法按照预期运行。</p>\n</blockquote>\n<p>如果你正在使用像 <a href="https://react.docchina.org/"><code>react</code></a> 这样的 library，那么在添加此 DefinePlugin 插件后，你应该看到 bundle 大小显著下降。还要注意，任何位于 <code>/src</code> 的本地代码都可以关联到 process.env.NODE_ENV 环境变量，所以以下检查也是有效的：</p>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff">  import { cube } from \'./math.js\';\n<span class="token inserted">+</span>\n<span class="token inserted">+ if (process.env.NODE_ENV !== \'production\') {</span>\n<span class="token inserted">+   console.log(\'Looks like we are in development mode!\');</span>\n<span class="token inserted">+ }</span>\n\n  function component() {\n    const element = document.createElement(\'pre\');\n\n    element.innerHTML = [\n      \'Hello webpack!\',\n      \'5 cubed is equal to \' + cube(5)\n    ].join(\'\\n\\n\');\n\n    return element;\n  }\n\n  document.body.appendChild(component());</code></pre>\n<h2 id="minification">压缩(Minification) <a href="#minification" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>webpack v4+ will minify your code by default in <a href="/configuration/mode/#mode-production"><code>production mode</code></a>.</p>\n<p>注意，虽然生产环境下默认使用 <a href="/plugins/terser-webpack-plugin"><code>TerserPlugin</code></a> ，并且也是代码压缩方面比较好的选择，但是还有一些其他可选择项。以下有几个同样很受欢迎的插件：</p>\n<ul>\n<li><a href="https://github.com/webpack-contrib/babel-minify-webpack-plugin"><code>BabelMinifyWebpackPlugin</code></a></li>\n<li><a href="https://github.com/webpack-contrib/closure-webpack-plugin"><code>ClosureWebpackPlugin</code></a></li>\n</ul>\n<p>如果决定尝试一些其他压缩插件，只要确保新插件也会按照 <a href="/guides/tree-shaking">tree shake</a> 指南中所陈述的具有删除未引用代码(dead code)的能力，并将它作为 <a href="/configuration/optimization/#optimization-minimizer"><code>optimization.minimizer</code></a>。</p>\n<h2 id="source-mapping">源码映射(Source Mapping) <a href="#source-mapping" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>我们鼓励你在生产环境中启用 source map，因为它们对 debug(调试源码) 和运行 benchmark tests(基准测试) 很有帮助。虽然有着如此强大的功能，然而还是应该针对生产环境用途，选择一个可以快速构建的推荐配置（更多选项请查看 <a href="/configuration/devtool"><code>devtool</code></a>）。对于本指南，我们将在<em>生产环境</em>中使用 <code>source-map</code> 选项，而不是我们在<em>开发环境</em>中用到的 <code>inline-source-map</code>：</p>\n<p><strong>webpack.prod.js</strong></p>\n<pre><code class="hljs language-diff">  const merge = require(\'webpack-merge\');\n  const common = require(\'./webpack.common.js\');\n\n  module.exports = merge(common, {\n    mode: \'production\',\n<span class="token inserted">+   devtool: \'source-map\',</span>\n  });</code></pre>\n<blockquote class="tip">\n<p>避免在生产中使用 <code>inline-***</code> 和 <code>eval-***</code>，因为它们会增加 bundle 体积大小，并降低整体性能。</p>\n</blockquote>\n<h2 id="minimize-css">压缩 CSS <a href="#minimize-css" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>将生产环境下的 CSS 进行压缩会非常重要，请查看 <a href="/plugins/mini-css-extract-plugin/#minimizing-for-production">在生产环境下压缩</a> 章节。</p>\n<h2 id="cli-alternatives">CLI 替代选项 <a href="#cli-alternatives" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>以上所述也可以通过命令行实现。例如，<code>--optimize-minimize</code> 标记将在幕后引用 <code>TerserPlugin</code>。和以上描述的 <code>DefinePlugin</code> 实例相同，<code>--define process.env.NODE_ENV="\'production\'"</code> 也会做同样的事情。而且，<code>webpack -p</code> 将自动地配置上述这两个标记，从而调用需要引入的插件。</p>\n<p>虽然这种简写方式很好，但通常我们建议只使用配置方式，因为在这两种方式中，配置方式能够更准确地理解现在正在做的事情。配置方式还为可以让你更加细微地控制这两个插件中的其他选项。</p>\n'}}]);