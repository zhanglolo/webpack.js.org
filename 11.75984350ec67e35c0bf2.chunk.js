(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{302:function(n,s,e){"use strict";e.r(s),s.default='<p><code>Compilation</code> 模块会被 <code>Compiler</code> 用来创建新的 compilation 对象（或新的 build 对象）。\n<code>compilation</code> 实例能够访问所有的模块和它们的依赖（大部分是循环依赖）。\n它会对应用程序的依赖图中所有模块，\n进行字面上的编译(literal compilation)。\n在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、\n分块(chunk)、哈希(hash)和重新创建(restore)。</p>\n<p><code>Compilation</code> 类扩展(extend)自 <code>Tapable</code>，并提供了以下生命周期钩子。\n可以按照 compiler 钩子的相同方式来调用 tap：</p>\n<pre><code class="hljs language-js">compilation<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>someHook<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token comment">/* ... */</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p>和 <code>compiler</code> 用法相同，取决于不同的钩子类型，\n所以也可以在某些钩子上访问 <code>tapAsync</code> 和 <code>tapPromise</code>。</p>\n<h3 id="buildmodule"><code>buildModule</code> <a href="#buildmodule" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>在模块构建开始之前触发，可以用来修改模块。</p>\n<ul>\n<li>回调参数：<code>module</code></li>\n</ul>\n<pre><code class="hljs language-js">compilation<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>buildModule<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">\'SourceMapDevToolModuleOptionsPlugin\'</span><span class="token punctuation">,</span>\n  module <span class="token operator">=></span> <span class="token punctuation">{</span>\n    module<span class="token punctuation">.</span>useSourceMap <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h3 id="rebuildmodule"><code>rebuildModule</code> <a href="#rebuildmodule" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>在重新构建一个模块之前触发。</p>\n<ul>\n<li>回调参数：<code>module</code></li>\n</ul>\n<h3 id="failedmodule"><code>failedModule</code> <a href="#failedmodule" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>模块构建失败时执行。</p>\n<ul>\n<li>回调参数：<code>module</code> <code>error</code></li>\n</ul>\n<h3 id="succeedmodule"><code>succeedModule</code> <a href="#succeedmodule" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>模块构建成功时执行。</p>\n<ul>\n<li>回调参数：<code>module</code></li>\n</ul>\n<h3 id="finishmodules"><code>finishModules</code> <a href="#finishmodules" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>AsyncSeriesHook</code></p>\n<p>所有模块都完成构建并且没有错误时执行。</p>\n<ul>\n<li>回调参数：<code>modules</code></li>\n</ul>\n<h3 id="finishrebuildingmodule"><code>finishRebuildingModule</code> <a href="#finishrebuildingmodule" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>一个模块完成重新构建时执行，在都成功或有错误的情况下。</p>\n<ul>\n<li>回调参数：<code>module</code></li>\n</ul>\n<h3 id="seal"><code>seal</code> <a href="#seal" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>compilation 对象停止接收新的模块时触发。</p>\n<h3 id="unseal"><code>unseal</code> <a href="#unseal" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>compilation 对象开始接收新模块时触发。</p>\n<h3 id="optimizedependencies"><code>optimizeDependencies</code> <a href="#optimizedependencies" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncBailHook</code></p>\n<p>依赖优化开始时触发。</p>\n<ul>\n<li>回调参数：<code>modules</code></li>\n</ul>\n<h3 id="afteroptimizedependencies"><code>afterOptimizeDependencies</code> <a href="#afteroptimizedependencies" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>依赖优化之后触发。</p>\n<ul>\n<li>回调参数：<code>modules</code></li>\n</ul>\n<h3 id="optimize"><code>optimize</code> <a href="#optimize" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>优化阶段开始时触发。</p>\n<h3 id="optimizemodules"><code>optimizeModules</code> <a href="#optimizemodules" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncBailHook</code></p>\n<p>在模块优化阶段开始时调用。插件可以 tap 此钩子对模块进行优化。</p>\n<ul>\n<li>回调参数：<code>modules</code></li>\n</ul>\n<h3 id="afteroptimizemodules"><code>afterOptimizeModules</code> <a href="#afteroptimizemodules" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>在模块优化完成之后调用。</p>\n<ul>\n<li>回调参数：<code>modules</code></li>\n</ul>\n<h3 id="optimizechunks"><code>optimizeChunks</code> <a href="#optimizechunks" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncBailHook</code></p>\n<p>在 chunk 优化阶段开始时调用。插件可以 tap 此钩子对 chunk 执行优化。</p>\n<ul>\n<li>回调参数：<code>chunks</code></li>\n</ul>\n<h3 id="afteroptimizechunks"><code>afterOptimizeChunks</code> <a href="#afteroptimizechunks" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>chunk 优化完成之后触发。</p>\n<ul>\n<li>回调参数：<code>chunks</code></li>\n</ul>\n<h3 id="optimizetree"><code>optimizeTree</code> <a href="#optimizetree" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>AsyncSeriesHook</code></p>\n<p>在优化依赖树之前调用。插件可以 tap 此钩子执行依赖树优化。</p>\n<ul>\n<li>回调参数：<code>chunks</code> <code>modules</code></li>\n</ul>\n<h3 id="afteroptimizetree"><code>afterOptimizeTree</code> <a href="#afteroptimizetree" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>在依赖树优化成功完成之后调用。</p>\n<ul>\n<li>回调参数：<code>chunks</code> <code>modules</code></li>\n</ul>\n<h3 id="optimizechunkmodules"><code>optimizeChunkModules</code> <a href="#optimizechunkmodules" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncBailHook</code></p>\n<p>在树优化之后，chunk 模块优化开始时调用。插件可以 tap 此钩子来执行 chunk 模块的优化。</p>\n<ul>\n<li>回调参数：<code>chunks</code> <code>modules</code></li>\n</ul>\n<h3 id="afteroptimizechunkmodules"><code>afterOptimizeChunkModules</code> <a href="#afteroptimizechunkmodules" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>在 chunk 模块优化成功完成之后调用。</p>\n<ul>\n<li>回调参数：<code>chunks</code> <code>modules</code></li>\n</ul>\n<h3 id="shouldrecord"><code>shouldRecord</code> <a href="#shouldrecord" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncBailHook</code></p>\n<p>调用来决定是否存储 record。返回任何内容 <code>!== false</code> 将阻止执行所有其他 "record" 钩子（<a href="#record"><code>record</code></a>, <a href="#recordmodules"><code>recordModules</code></a>, <a href="#recordchunks"><code>recordChunks</code></a> 和 <a href="#recordhash"><code>recordHash</code></a>）。</p>\n<h3 id="revivemodules"><code>reviveModules</code> <a href="#revivemodules" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>从 record 中恢复模块信息。</p>\n<ul>\n<li>回调参数：<code>modules</code> <code>records</code></li>\n</ul>\n<h3 id="beforemoduleids"><code>beforeModuleIds</code> <a href="#beforemoduleids" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>在为每个模块分配 <code>id</code> 之前执行。</p>\n<ul>\n<li>回调参数：<code>modules</code></li>\n</ul>\n<h3 id="moduleids"><code>moduleIds</code> <a href="#moduleids" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>调用来每个模块分配一个 <code>id</code>。</p>\n<ul>\n<li>回调参数：<code>modules</code></li>\n</ul>\n<h3 id="optimizemoduleids"><code>optimizeModuleIds</code> <a href="#optimizemoduleids" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>在模块 <code>id</code> 优化开始时调用。</p>\n<ul>\n<li>回调参数：<code>modules</code></li>\n</ul>\n<h3 id="afteroptimizemoduleids"><code>afterOptimizeModuleIds</code> <a href="#afteroptimizemoduleids" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>在模块 <code>id</code> 优化完成时调用。</p>\n<ul>\n<li>回调参数：<code>modules</code></li>\n</ul>\n<h3 id="revivechunks"><code>reviveChunks</code> <a href="#revivechunks" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>从 record 中恢复 chunk 信息。</p>\n<ul>\n<li>回调参数：<code>chunks</code> <code>records</code></li>\n</ul>\n<h3 id="beforechunkids"><code>beforeChunkIds</code> <a href="#beforechunkids" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>在为每个 chunk 分配 <code>id</code> 之前执行。</p>\n<ul>\n<li>回调参数：<code>chunks</code></li>\n</ul>\n<h3 id="optimizechunkids"><code>optimizeChunkIds</code> <a href="#optimizechunkids" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>在 chunk <code>id</code> 优化阶段开始时调用。</p>\n<ul>\n<li>回调参数：<code>chunks</code></li>\n</ul>\n<h3 id="afteroptimizechunkids"><code>afterOptimizeChunkIds</code> <a href="#afteroptimizechunkids" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>chunk <code>id</code> 优化结束之后触发。</p>\n<ul>\n<li>回调参数：<code>chunks</code></li>\n</ul>\n<h3 id="recordmodules"><code>recordModules</code> <a href="#recordmodules" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>将模块信息存储到 record 中。<a href="#shouldrecord"><code>shouldRecord</code></a> 返回 truthy 值时触发。</p>\n<ul>\n<li>回调参数：<code>modules</code> <code>records</code></li>\n</ul>\n<h3 id="recordchunks"><code>recordChunks</code> <a href="#recordchunks" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>将 chunk 存储到 record 中。<a href="#shouldrecord"><code>shouldRecord</code></a> 返回 truthy 值时触发。</p>\n<ul>\n<li>回调参数：<code>chunks</code> <code>records</code></li>\n</ul>\n<h3 id="beforehash"><code>beforeHash</code> <a href="#beforehash" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>在 compilation 添加哈希(hash)之前。</p>\n<h3 id="afterhash"><code>afterHash</code> <a href="#afterhash" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>在 compilation 添加哈希(hash)之后。</p>\n<h3 id="recordhash"><code>recordHash</code> <a href="#recordhash" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>将有关 record 的信息存储到 <code>records</code> 中。仅在 <a href="#shouldrecord"><code>shouldRecord</code></a> 返回 truthy 值时触发。</p>\n<ul>\n<li>回调参数：<code>records</code></li>\n</ul>\n<h3 id="record"><code>record</code> <a href="#record" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>将 <code>compilation</code> 相关信息存储到 <code>record</code> 中。仅在 <a href="#shouldrecord"><code>shouldRecord</code></a> 返回 truthy 值时触发。</p>\n<ul>\n<li>回调参数：<code>compilation</code> <code>records</code></li>\n</ul>\n<h3 id="beforemoduleassets"><code>beforeModuleAssets</code> <a href="#beforemoduleassets" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>在创建模块 asset 之前执行。</p>\n<h3 id="additionalchunkassets"><code>additionalChunkAssets</code> <a href="#additionalchunkassets" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<blockquote class="warning">\n<p><code>additionalChunkAssets</code> 已弃用（可使用 <a href="#processassets">Compilation.hook.processAssets</a> 来代替，并且可使用 Compilation.PROCESS<em>ASSETS_STAGE</em>* 作为其选项参数。）</p>\n</blockquote>\n<p>为这些 chunk 创建其他 asset。</p>\n<ul>\n<li>回调参数：<code>chunks</code></li>\n</ul>\n<h3 id="shouldgeneratechunkassets"><code>shouldGenerateChunkAssets</code> <a href="#shouldgeneratechunkassets" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncBailHook</code></p>\n<p>调用以确定是否生成 chunk asset。返回任何 <code>!== false</code> 将允许生成 chunk asset。</p>\n<h3 id="beforechunkassets"><code>beforeChunkAssets</code> <a href="#beforechunkassets" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>在创建 chunk asset 之前。</p>\n<h3 id="additionalassets"><code>additionalAssets</code> <a href="#additionalassets" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>AsyncSeriesHook</code></p>\n<p>为 compilation 创建额外 asset。\n这个钩子可以用来下载图像，例如：</p>\n<pre><code class="hljs language-js">compilation<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>additionalAssets<span class="token punctuation">.</span><span class="token function">tapAsync</span><span class="token punctuation">(</span><span class="token string">\'MyPlugin\'</span><span class="token punctuation">,</span> callback <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token function">download</span><span class="token punctuation">(</span><span class="token string">\'https://img.shields.io/npm/v/webpack.svg\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span><span class="token punctuation">(</span>resp<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      compilation<span class="token punctuation">.</span>assets<span class="token punctuation">[</span><span class="token string">\'webpack-version.svg\'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">toAsset</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">\'[webpack-example-plugin] Unable to download the image\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h3 id="optimizechunkassets"><code>optimizeChunkAssets</code> <a href="#optimizechunkassets" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>AsyncSeriesHook</code></p>\n<blockquote class="warning">\n<p><code>optimizeChunkAssets</code> 已弃用。（可使用 <a href="#processassets">Compilation.hook.processAssets</a> 来代替，并且可使用 Compilation.PROCESS<em>ASSETS_STAGE</em>* 作为其选项参数。</p>\n</blockquote>\n<p>优化所有 chunk asset。asset 存储在 <code>compilation.assets</code> 中。\n每个 <code>Chunk</code> 都具有一个 <code>files</code> 属性，其指向由一个 chunk 创建的所有文件。\n任何额外 chunk asset 都存储在 <code>compilation.additionalChunkAssets</code> 中。</p>\n<ul>\n<li>回调参数：<code>chunks</code></li>\n</ul>\n<p>Here\'s an example that simply adds a banner to each chunk.</p>\n<pre><code class="hljs language-js">compilation<span class="token punctuation">.</span>hooks\n  <span class="token punctuation">.</span>optimizeChunkAssets\n  <span class="token punctuation">.</span><span class="token function">tapAsync</span><span class="token punctuation">(</span><span class="token string">\'MyPlugin\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>chunks<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    chunks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>chunk <span class="token operator">=></span> <span class="token punctuation">{</span>\n      chunk<span class="token punctuation">.</span>files<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>file <span class="token operator">=></span> <span class="token punctuation">{</span>\n        compilation<span class="token punctuation">.</span>assets<span class="token punctuation">[</span>file<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcatSource</span><span class="token punctuation">(</span>\n          <span class="token string">\'\\/**Sweet Banner**\\/\'</span><span class="token punctuation">,</span>\n          <span class="token string">\'\\n\'</span><span class="token punctuation">,</span>\n          compilation<span class="token punctuation">.</span>assets<span class="token punctuation">[</span>file<span class="token punctuation">]</span>\n        <span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h3 id="afteroptimizechunkassets"><code>afterOptimizeChunkAssets</code> <a href="#afteroptimizechunkassets" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<blockquote class="warning">\n<p><code>afterOptimizeChunkAssets</code> 已弃用。（可使用 <a href="#processassets">Compilation.hook.processAssets</a> 来代替，并且可使用 Compilation.PROCESS<em>ASSETS_STAGE</em>* 作为其选项参数。</p>\n</blockquote>\n<p>chunk asset 已经被优化。</p>\n<ul>\n<li>回调参数：<code>chunks</code></li>\n</ul>\n<p>这里是一个来自 <a href="https://github.com/boopathi">@boopathi</a> 的示例插件，详细地输出每个 chunk 里有什么。</p>\n<pre><code class="hljs language-js">compilation<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>afterOptimizeChunkAssets<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">\'MyPlugin\'</span><span class="token punctuation">,</span> chunks <span class="token operator">=></span> <span class="token punctuation">{</span>\n  chunks<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>chunk <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      id<span class="token punctuation">:</span> chunk<span class="token punctuation">.</span>id<span class="token punctuation">,</span>\n      name<span class="token punctuation">:</span> chunk<span class="token punctuation">.</span>name<span class="token punctuation">,</span>\n      includes<span class="token punctuation">:</span> chunk<span class="token punctuation">.</span><span class="token function">getModules</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>module <span class="token operator">=></span> module<span class="token punctuation">.</span>request<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<h3 id="optimizeassets"><code>optimizeAssets</code> <a href="#optimizeassets" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>AsyncSeriesHook</code></p>\n<p>优化存储在 <code>compilation.assets</code> 中的所有 asset。</p>\n<ul>\n<li>回调参数：<code>assets</code></li>\n</ul>\n<h3 id="afteroptimizeassets"><code>afterOptimizeAssets</code> <a href="#afteroptimizeassets" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>asset 已经优化。</p>\n<ul>\n<li>回调参数：<code>assets</code></li>\n</ul>\n<h3 id="processassets"><code>processAssets</code> <a href="#processassets" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>AsyncSeriesHook</code></p>\n<p>Asset processing.</p>\n<ul>\n<li>Callback Parameters: <code>assets</code></li>\n</ul>\n<p>Here\'s an example:</p>\n<pre><code class="hljs language-js">compilation<span class="token punctuation">.</span>hooks<span class="token punctuation">.</span>processAssets<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span>\n  <span class="token punctuation">{</span>\n    name<span class="token punctuation">:</span> <span class="token string">\'MyPlugin\'</span><span class="token punctuation">,</span>\n    stage<span class="token punctuation">:</span> Compilation<span class="token punctuation">.</span><span class="token constant">PROCESS_ASSETS_STAGE_ADDITIONS</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">(</span>assets<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// code here</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p>There\'re many stages to use:</p>\n<ul>\n<li><code>PROCESS_ASSETS_STAGE_ADDITIONAL</code> - Add additional assets to the compilation.</li>\n<li><code>PROCESS_ASSETS_STAGE_PRE_PROCESS</code> - Basic preprocessing of the assets.</li>\n<li><code>PROCESS_ASSETS_STAGE_DERIVED</code> - Derive new assets from the existing assets.</li>\n<li><code>PROCESS_ASSETS_STAGE_ADDITIONS</code> - Add additional sections to the existing assets e.g. banner or initialization code.</li>\n<li><code>PROCESS_ASSETS_STAGE_OPTIMIZE</code> - Optimize existing assets in a general way.</li>\n<li><code>PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT</code> - Optimize the count of existing assets, e.g. by merging them.</li>\n<li><code>PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY</code> - Optimize the compatibility of existing assets, e.g. add polyfills or vendor prefixes.</li>\n<li><code>PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE</code> - Optimize the size of existing assets, e.g. by minimizing or omitting whitespace.</li>\n<li><code>PROCESS_ASSETS_STAGE_SUMMARIZE</code> - Summarize the list of existing assets.</li>\n<li><code>PROCESS_ASSETS_STAGE_DEV_TOOLING</code> - Add development tooling to the assets, e.g. by extracting a source map.</li>\n<li><code>PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER</code> - Optimize the transfer of existing assets, e.g. by preparing a compressed (gzip) file as separate asset.</li>\n<li><code>PROCESS_ASSETS_STAGE_ANALYSE</code> - Analyze the existing assets.</li>\n<li><code>PROCESS_ASSETS_STAGE_REPORT</code> - Creating assets for the reporting purposes.</li>\n</ul>\n<h3 id="afterprocessassets"><code>afterProcessAssets</code> <a href="#afterprocessassets" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>Called after the <a href="#processassets"><code>processAssets</code></a> hook had finished without error.</p>\n<h3 id="needadditionalseal"><code>needAdditionalSeal</code> <a href="#needadditionalseal" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncBailHook</code></p>\n<p>调用来决定 compilation 是否需要解除 seal 以引入其他文件。</p>\n<h3 id="afterseal"><code>afterSeal</code> <a href="#afterseal" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>AsyncSeriesHook</code></p>\n<p>在 <code>needAdditionalSeal</code> 之后立即执行。</p>\n<h3 id="chunkhash"><code>chunkHash</code> <a href="#chunkhash" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>触发来为每个 chunk 生成 hash。</p>\n<ul>\n<li>回调参数：<code>chunk</code> <code>chunkHash</code></li>\n</ul>\n<h3 id="moduleasset"><code>moduleAsset</code> <a href="#moduleasset" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>一个模块中的一个 asset 被添加到 compilation 时调用。</p>\n<ul>\n<li>回调参数：<code>module</code> <code>filename</code></li>\n</ul>\n<h3 id="chunkasset"><code>chunkAsset</code> <a href="#chunkasset" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>一个 chunk 中的一个 asset 被添加到 compilation 时调用。</p>\n<ul>\n<li>回调参数：<code>chunk</code> <code>filename</code></li>\n</ul>\n<h3 id="assetpath"><code>assetPath</code> <a href="#assetpath" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncWaterfallHook</code></p>\n<p>调用以决定 asset 的路径。</p>\n<ul>\n<li>回调参数：<code>path</code> <code>options</code></li>\n</ul>\n<h3 id="needadditionalpass"><code>needAdditionalPass</code> <a href="#needadditionalpass" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncBailHook</code></p>\n<p>调用以决定 asset 在输出后是否需要进一步处理。</p>\n<h3 id="childcompiler"><code>childCompiler</code> <a href="#childcompiler" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p><code>SyncHook</code></p>\n<p>子 compiler 设置之后执行。</p>\n<ul>\n<li>回调参数：<code>childCompiler</code> <code>compilerName</code> <code>compilerIndex</code></li>\n</ul>\n<h3 id="normalmoduleloader"><code>normalModuleLoader</code> <a href="#normalmoduleloader" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<p>从 webpack v5 开始，<code>normalModuleLoader</code> 钩子已经删除。现在要访问loader 请改用 <code>NormalModule.getCompilationHooks(compilation).loader</code>。</p>\n'}}]);