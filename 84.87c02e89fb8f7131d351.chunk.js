(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{380:function(n,e,s){"use strict";s.r(e),e.default='<blockquote class="tip">\n<p>本指南继续沿用 <a href="/guides/asset-management"><code>管理资源</code></a> 指南中的代码示例。</p>\n</blockquote>\n<p>到目前为止，我们都是在 <code>index.html</code> 文件中手动引入所有资源，然而随着应用程序增长，并且一旦开始 <a href="/guides/caching">在文件名中使用 hash</a> 并输出 <a href="/guides/code-splitting">多个 bundle</a>，如果继续手动管理 <code>index.html</code> 文件，就会变得困难起来。然而，通过一些插件可以使这个过程更容易管控。</p>\n<h2 id="preparation">预先准备 <a href="#preparation" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>首先，调整一下我们的项目：</p>\n<p><strong>project</strong></p>\n<pre><code class="hljs language-diff">  webpack-demo\n  |- package.json\n  |- webpack.config.js\n  |- /dist\n  |- /src\n    |- index.js\n<span class="token inserted">+   |- print.js</span>\n  |- /node_modules</code></pre>\n<p>我们在 <code>src/print.js</code> 文件中添加一些逻辑：</p>\n<p><strong>src/print.js</strong></p>\n<pre><code class="hljs language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">printMe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'I get called from print.js!\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n<p>并且在 <code>src/index.js</code> 文件中使用这个函数：</p>\n<p><strong>src/index.js</strong></p>\n<pre><code class="hljs language-diff">  import _ from \'lodash\';\n<span class="token inserted">+ import printMe from \'./print.js\';</span>\n\n  function component() {\n    const element = document.createElement(\'div\');\n<span class="token inserted">+   const btn = document.createElement(\'button\');</span>\n\n    element.innerHTML = _.join([\'Hello\', \'webpack\'], \' \');\n\n<span class="token inserted">+   btn.innerHTML = \'点击这里，然后查看 console！\';</span>\n<span class="token inserted">+   btn.onclick = printMe;</span>\n<span class="token inserted">+</span>\n<span class="token inserted">+   element.appendChild(btn);</span>\n\n    return element;\n  }\n\n  document.body.appendChild(component());</code></pre>\n<p>还要更新 <code>dist/index.html</code> 文件，来为 webpack 分离入口做好准备：</p>\n<p><strong>dist/index.html</strong></p>\n<pre><code class="hljs language-diff">  &#x3C;!doctype html>\n  &#x3C;html>\n    &#x3C;head>\n<span class="token deleted">-     &#x3C;title>管理资源&#x3C;/title></span>\n<span class="token inserted">+     &#x3C;title>管理输出&#x3C;/title></span>\n<span class="token inserted">+     &#x3C;script src="./print.bundle.js">&#x3C;/script></span>\n    &#x3C;/head>\n    &#x3C;body>\n<span class="token deleted">-     &#x3C;script src="./bundle.js">&#x3C;/script></span>\n<span class="token inserted">+     &#x3C;script src="./app.bundle.js">&#x3C;/script></span>\n    &#x3C;/body>\n  &#x3C;/html></code></pre>\n<p>现在调整配置。我们将在 entry 添加 <code>src/print.js</code> 作为新的入口起点（<code>print</code>），然后修改 output，以便根据入口起点定义的名称，动态地产生 bundle 名称：</p>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n\n  module.exports = {\n<span class="token deleted">-   entry: \'./src/index.js\',</span>\n<span class="token inserted">+   entry: {</span>\n<span class="token inserted">+     app: \'./src/index.js\',</span>\n<span class="token inserted">+     print: \'./src/print.js\',</span>\n<span class="token inserted">+   },</span>\n    output: {\n<span class="token deleted">-     filename: \'bundle.js\',</span>\n<span class="token inserted">+     filename: \'[name].bundle.js\',</span>\n      path: path.resolve(__dirname, \'dist\'),\n    },\n  };</code></pre>\n<p>执行 <code>npm run build</code>，然后看到生成如下：</p>\n<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n          Asset     Size  Chunks                    Chunk Names\n  app.bundle.js   545 kB    0, 1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  app\nprint.bundle.js  2.74 kB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         print\n<span class="token punctuation">..</span>.</code></pre>\n<p>我们可以看到，webpack 生成 <code>print.bundle.js</code> 和 <code>app.bundle.js</code> 文件，这也和我们在 <code>index.html</code> 文件中指定的文件名称相对应。如果你在浏览器中打开 <code>index.html</code>，就可以看到在点击按钮时会发生什么。</p>\n<p>但是，如果我们更改了我们的一个入口起点的名称，甚至添加了一个新的入口，会发生什么？会在构建时重新命名生成的 bundle，但是我们的 <code>index.html</code> 文件仍然引用旧的名称。让我们用 <a href="/plugins/html-webpack-plugin"><code>HtmlWebpackPlugin</code></a> 来解决这个问题。</p>\n<h2 id="setting-up-htmlwebpackplugin">设置 HtmlWebpackPlugin <a href="#setting-up-htmlwebpackplugin" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>首先安装插件，并且调整 <code>webpack.config.js</code> 文件：</p>\n<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev html-webpack-plugin</code></pre>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n<span class="token inserted">+ const HtmlWebpackPlugin = require(\'html-webpack-plugin\');</span>\n\n  module.exports = {\n    entry: {\n      app: \'./src/index.js\',\n      print: \'./src/print.js\',\n    },\n<span class="token inserted">+   plugins: [</span>\n<span class="token inserted">+     new HtmlWebpackPlugin({</span>\n<span class="token inserted">+       title: \'管理输出\',</span>\n<span class="token inserted">+     }),</span>\n<span class="token inserted">+   ],</span>\n    output: {\n      filename: \'[name].bundle.js\',\n      path: path.resolve(__dirname, \'dist\'),\n    },\n  };</code></pre>\n<p>在我们构建之前，你应该了解，虽然在 <code>dist/</code> 文件夹我们已经有了 <code>index.html</code> 这个文件，然而 <code>HtmlWebpackPlugin</code> 还是会默认生成它自己的 <code>index.html</code> 文件。也就是说，它会用新生成的 <code>index.html</code> 文件，替换我们的原有文件。我们看下执行 <code>npm run build</code> 后会发生什么：</p>\n<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n           Asset       Size  Chunks                    Chunk Names\n print.bundle.js     544 kB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  print\n   app.bundle.js    2.81 kB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         app\n      index.html  249 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>\n<span class="token punctuation">..</span>.</code></pre>\n<p>如果在代码编辑器中打开 <code>index.html</code>，你会看到 <code>HtmlWebpackPlugin</code> 创建了一个全新的文件，所有的 bundle 会自动添加到 html 中。</p>\n<p>如果你想要了解 <code>HtmlWebpackPlugin</code> 插件提供的全部的功能和选项，你就应该阅读 <a href="https://github.com/jantimon/html-webpack-plugin"><code>HtmlWebpackPlugin</code></a> 仓库中的源码。</p>\n<p>还可以看下 <a href="https://github.com/jaketrent/html-webpack-template"><code>html-webpack-template</code></a>，除了提供默认模板之外，还提供了一些额外的功能。</p>\n<h2 id="cleaning-up-the-dist-folder">清理 <code>/dist</code> 文件夹 <a href="#cleaning-up-the-dist-folder" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>你可能已经注意到，由于遗留了之前的指南和代码示例，我们的 <code>/dist</code> 文件夹显得相当杂乱。webpack 将生成文件并放置在 <code>/dist</code> 文件夹中，但是它不会追踪哪些文件是实际在项目中用到的。</p>\n<p>通常比较推荐的做法是，在每次构建前清理 <code>/dist</code> 文件夹，这样只会生成用到的文件。让我们实现这个需求。</p>\n<p><a href="https://www.npmjs.com/package/clean-webpack-plugin"><code>clean-webpack-plugin</code></a> 是一个流行的清理插件，安装和配置它。</p>\n<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev clean-webpack-plugin</code></pre>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n  const HtmlWebpackPlugin = require(\'html-webpack-plugin\');\n<span class="token inserted">+ const { CleanWebpackPlugin } = require(\'clean-webpack-plugin\');</span>\n\n  module.exports = {\n    entry: {\n      app: \'./src/index.js\',\n      print: \'./src/print.js\',\n    },\n    plugins: [\n<span class="token inserted">+     new CleanWebpackPlugin(),</span>\n      new HtmlWebpackPlugin({\n        title: \'管理输出\',\n      }),\n    ],\n    output: {\n      filename: \'[name].bundle.js\',\n      path: path.resolve(__dirname, \'dist\'),\n    },\n  };</code></pre>\n<p>现在，执行 <code>npm run build</code>，检查 <code>/dist</code> 文件夹。如果一切顺利，现在只会看到构建后生成的文件，而没有旧文件！</p>\n<h2 id="the-manifest">manifest <a href="#the-manifest" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>你可能会很感兴趣，webpack 和 webpack 插件似乎“知道”应该生成哪些文件。答案是，webpack 通过 manifest，可以追踪所有模块到输出 bundle 之间的映射。如果你想要知道如何以其他方式来控制 webpack <a href="/configuration/output"><code>输出</code></a>，了解 manifest 是个好的开始。</p>\n<p>通过 <a href="https://github.com/danethurber/webpack-manifest-plugin"><code>WebpackManifestPlugin</code></a> 插件，可以将 manifest 数据提取为一个容易使用的 json 文件。</p>\n<p>我们不会在此展示一个如何在项目中使用此插件的完整示例，你可以在 <a href="/concepts/manifest">manifest</a> 概念页面深入阅读，以及在 <a href="/guides/caching">缓存</a> 指南中，了解它与长效缓存有何关系。</p>\n<h2 id="conclusion">结论 <a href="#conclusion" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>现在，你已经了解如何向 HTML 动态添加 bundle，让我们深入 <a href="/guides/development">开发环境</a> 指南。或者如果你想要深入更多相关高级话题，我们推荐你前往 <a href="/guides/code-splitting">代码分离</a> 指南。</p>\n'}}]);