(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{382:function(e,n,s){"use strict";s.r(n),n.default='<blockquote class="tip">\n<p>本指南继续沿用 <a href="/guides/output-management">管理输出</a> 中的代码示例。</p>\n</blockquote>\n<p>渐进式网络应用程序(progressive web application - PWA)，是一种可以提供类似于native app(原生应用程序) 体验的 web app(网络应用程序)。PWA 可以用来做很多事。其中最重要的是，在<strong>离线(offline)</strong>时应用程序能够继续运行功能。这是通过使用名为 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">Service Workers</a> 的 web 技术来实现的。</p>\n<p>本章将重点介绍，如何为我们的应用程序添加离线体验。我们将使用名为 <a href="https://github.com/GoogleChrome/workbox">Workbox</a> 的 Google 项目来实现此目的，该项目提供的工具可帮助我们更简单地为 web app 提供离线支持。</p>\n<h2 id="we-dont-work-offline-now">现在，我们并没有运行在离线环境下 <a href="#we-dont-work-offline-now" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>到目前为止，我们一直是直接查看本地文件系统的输出结果。通常情况下，真正的用户是通过网络访问 web app；用户的浏览器会与一个提供所需资源（例如，<code>.html</code>, <code>.js</code> 和 <code>.css</code> 文件）的 <strong>server</strong> 通讯。</p>\n<p>我们通过搭建一个简易 server 下，测试下这种离线体验。这里使用 <a href="https://www.npmjs.com/package/http-server">http-server</a> package：<code>npm install http-server --save-dev</code>。还要修改 <code>package.json</code> 的 <code>scripts</code> 部分，来添加一个 <code>start</code> script：</p>\n<p><strong>package.json</strong></p>\n<pre><code class="hljs language-diff">{\n  ...\n  "scripts": {\n<span class="token deleted">-    "build": "webpack"</span>\n<span class="token inserted">+    "build": "webpack",</span>\n<span class="token inserted">+    "start": "http-server dist"</span>\n  },\n  ...\n}</code></pre>\n<p>注意：默认情况下，<a href="/configuration/dev-server/">webpack DevServer</a> 会写入到内存。我们需要启用 <a href="/configuration/dev-server#devserverwritetodisk-">writeToDisk</a> 选项，来让 http-server 处理 <code>./dist</code> 目录中的文件。</p>\n<p>如果你之前没有操作过，先得运行命令 <code>npm run build</code> 来构建你的项目。然后运行命令 <code>npm start</code>。应该产生以下输出：</p>\n<pre><code class="hljs language-bash"><span class="token operator">></span> http-server dist\n\nStarting up http-server, serving dist\nAvailable on:\n  http://xx.x.x.x:8080\n  http://127.0.0.1:8080\n  http://xxx.xxx.x.x:8080\nHit CTRL-C to stop the server</code></pre>\n<p>如果你打开浏览器访问 <code>http://localhost:8080</code> (即 <code>http://127.0.0.1</code>)，你应该会看到 webpack 应用程序被 serve 到 <code>dist</code> 目录。如果停止 server 然后刷新，则 webpack 应用程序不再可访问。</p>\n<p>这就是我们为实现离线体验所需要的改变。在本章结束时，我们应该要实现的是，停止 server 然后刷新，仍然可以看到应用程序正常运行。</p>\n<h2 id="adding-workbox">添加 Workbox <a href="#adding-workbox" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>添加 workbox-webpack-plugin 插件，然后调整 <code>webpack.config.js</code> 文件：</p>\n<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> workbox-webpack-plugin --save-dev</code></pre>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-diff">  const path = require(\'path\');\n  const HtmlWebpackPlugin = require(\'html-webpack-plugin\');\n  const { CleanWebpackPlugin } = require(\'clean-webpack-plugin\');\n<span class="token inserted">+ const WorkboxPlugin = require(\'workbox-webpack-plugin\');</span>\n\n  module.exports = {\n    entry: {\n      app: \'./src/index.js\',\n      print: \'./src/print.js\',\n    },\n    plugins: [\n      // 对于 CleanWebpackPlugin 的 v2 versions 以下版本，使用 new CleanWebpackPlugin([\'dist/*\'])\n      new CleanWebpackPlugin(),\n      new HtmlWebpackPlugin({\n<span class="token deleted">-       title: \'Output Management\',</span>\n<span class="token inserted">+       title: \'Progressive Web Application\',</span>\n      }),\n<span class="token inserted">+     new WorkboxPlugin.GenerateSW({</span>\n<span class="token inserted">+       // 这些选项帮助快速启用 ServiceWorkers</span>\n<span class="token inserted">+       // 不允许遗留任何“旧的” ServiceWorkers</span>\n<span class="token inserted">+       clientsClaim: true,</span>\n<span class="token inserted">+       skipWaiting: true,</span>\n<span class="token inserted">+     }),</span>\n    ],\n    output: {\n      filename: \'[name].bundle.js\',\n      path: path.resolve(__dirname, \'dist\'),\n    },\n  };</code></pre>\n<p>完成这些设置，再次执行 <code>npm run build</code>，看下会发生什么：</p>\n<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.\n                  Asset       Size  Chunks                    Chunk Names\n          app.bundle.js     545 kB    0, 1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  app\n        print.bundle.js    2.74 kB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         print\n             index.html  254 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>\nprecache-manifest.b5ca1c555e832d6fbf9462efd29d27eb.js  268 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>\n      service-worker.js       1 kB          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>\n<span class="token punctuation">..</span>.</code></pre>\n<p>现在你可以看到，生成了两个额外的文件：<code>service-worker.js</code> 和名称冗长的 <code>precache-manifest.b5ca1c555e832d6fbf9462efd29d27eb.js</code>。<code>service-worker.js</code> 是 Service Worker 文件，<code>precache-manifest.b5ca1c555e832d6fbf9462efd29d27eb.js</code> 是 <code>service-worker.js</code> 引用的文件，所以它也可以运行。你本地生成的文件可能会有所不同；但是应该会有一个 <code>service-worker.js</code> 文件。</p>\n<p>所以，值得高兴的是，我们现在已经创建出一个 Service Worker。接下来该做什么？</p>\n<h2 id="registering-our-service-worker">注册 Service Worker <a href="#registering-our-service-worker" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>接下来我们注册 Service Worker，使其出场并开始表演。通过添加以下注册代码来完成此操作：</p>\n<p><strong>index.js</strong></p>\n<pre><code class="hljs language-diff">  import _ from \'lodash\';\n  import printMe from \'./print.js\';\n\n<span class="token inserted">+ if (\'serviceWorker\' in navigator) {</span>\n<span class="token inserted">+   window.addEventListener(\'load\', () => {</span>\n<span class="token inserted">+     navigator.serviceWorker.register(\'/service-worker.js\').then(registration => {</span>\n<span class="token inserted">+       console.log(\'SW registered: \', registration);</span>\n<span class="token inserted">+     }).catch(registrationError => {</span>\n<span class="token inserted">+       console.log(\'SW registration failed: \', registrationError);</span>\n<span class="token inserted">+     });</span>\n<span class="token inserted">+   });</span>\n<span class="token inserted">+ }</span></code></pre>\n<p>再次运行 <code>npm run build</code> 来构建包含注册代码版本的应用程序。然后用 <code>npm start</code> 启动服务。访问 <code>http://localhost:8080</code> 并查看 console 控制台。在那里你应该看到：</p>\n<pre><code class="hljs language-bash">SW registered</code></pre>\n<p>现在来进行测试。停止 server 并刷新页面。如果浏览器能够支持 Service Worker，应该可以看到你的应用程序还在正常运行。然而，server 已经<strong>停止</strong> serve 整个 dist 文件夹，此刻是 Service Worker 在进行 serve。</p>\n<h2 id="conclusion">结论 <a href="#conclusion" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>你已经使用 Workbox 项目构建了一个离线应用程序。开始进入将 web app 改造为 PWA 的旅程。你现在可能想要考虑下一步做什么。<a href="https://developers.google.com/web/progressive-web-apps/">这里</a>是可以帮助到你解决下一步问题的比较不错的资源。</p>\n'}}]);