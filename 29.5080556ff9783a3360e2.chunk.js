(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{322:function(n,a,s){"use strict";s.r(a),a.default='<p>本质上，<strong>webpack</strong> 是一个用于现代 JavaScript 应用程序的<em>静态模块打包工具</em>。当 webpack 处理应用程序时，它会在内部构建一个 <a href="/concepts/dependency-graph/">依赖图(dependency graph)</a>，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 <em>bundle</em>。</p>\n<blockquote class="tip">\n<p>可以在 <a href="/concepts/modules">这里</a> 了解更多关于 JavaScript 模块和 webpack 模块的信息。</p>\n</blockquote>\n<p>从 v4.0.0 开始，<strong>webpack 可以不用再引入一个配置文件</strong>来打包项目，然而，它仍然有着 <a href="/configuration">高度可配置性</a>，可以很好满足你的需求。</p>\n<p>在开始前你需要先理解一些<strong>核心概念</strong>：</p>\n<ul>\n<li><a href="#entry">入口(entry)</a></li>\n<li><a href="#output">输出(output)</a></li>\n<li><a href="#loaders">loader</a></li>\n<li><a href="#plugins">插件(plugin)</a></li>\n<li><a href="#mode">模式(mode)</a></li>\n<li><a href="#browser-compatibility">浏览器兼容性(browser compatibility)</a></li>\n<li><a href="#environment">环境(environment)</a></li>\n</ul>\n<p>本文档旨在给出这些概念的<strong>高度</strong>概述，同时提供具体概念的详尽相关用例的链接。</p>\n<p>为了更好地理解模块打包工具背后的理念，以及在底层它们是如何运作的，请参考以下资源：</p>\n<ul>\n<li><a href="https://www.youtube.com/watch?v=UNMkLHzofQI">手动打包一个应用程序</a></li>\n<li><a href="https://www.youtube.com/watch?v=Gc9-7PBqOC8">实时创建一个简单打包工具</a></li>\n<li><a href="https://github.com/ronami/minipack">一个简单打包工具的详细说明</a></li>\n</ul>\n<h2 id="entry">入口(entry) <a href="#entry" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p><strong>入口起点(entry point)</strong>指示 webpack 应该使用哪个模块，来作为构建其内部 <a href="/concepts/dependency-graph/">依赖图(dependency graph)</a> 的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。</p>\n<p>默认值是 <code>./src/index.js</code>，但你可以通过在 <a href="/configuration">webpack configuration</a> 中配置 <code>entry</code> 属性，来指定一个（或多个）不同的入口起点。例如：</p>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  entry<span class="token punctuation">:</span> <span class="token string">\'./path/to/my/entry/file.js\'</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n<blockquote class="tip">\n<p>在 <a href="/concepts/entry-points">入口起点</a> 章节可以了解更多信息。</p>\n</blockquote>\n<h2 id="output">输出(output) <a href="#output" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p><strong>output</strong> 属性告诉 webpack 在哪里输出它所创建的 <em>bundle</em>，以及如何命名这些文件。主要输出文件的默认值是 <code>./dist/main.js</code>，其他生成文件默认放置在 <code>./dist</code> 文件夹中。</p>\n<p>你可以通过在配置中指定一个 <code>output</code> 字段，来配置这些处理过程：</p>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'path\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  entry<span class="token punctuation">:</span> <span class="token string">\'./path/to/my/entry/file.js\'</span><span class="token punctuation">,</span>\n  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">\'dist\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    filename<span class="token punctuation">:</span> <span class="token string">\'my-first-webpack.bundle.js\'</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n<p>在上面的示例中，我们通过 <code>output.filename</code> 和 <code>output.path</code> 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。可能你想要了解在代码最上面导入的 path 模块是什么，它是一个 <a href="https://nodejs.org/api/modules.html">Node.js 核心模块</a>，用于操作文件路径。</p>\n<blockquote class="tip">\n<p><code>output</code> 属性还有 <a href="/configuration/output">更多可配置的特性</a>，如果你想要了解更多关于 <code>output</code> 属性的概念，可以通过阅读 <a href="/concepts/output">输出章节</a> 来了解更多。</p>\n</blockquote>\n<h2 id="loaders">loader <a href="#loaders" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。<strong>loader</strong> 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 <a href="/concepts/modules">模块</a>，以供应用程序使用，以及被添加到依赖图中。</p>\n<blockquote class="warning">\n<p>注意，loader 能够 <code>import</code> 导入任何类型的模块（例如 <code>.css</code> 文件），这是 webpack 特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是很有必要的，因为这可以使开发人员创建出更准确的依赖关系图。</p>\n</blockquote>\n<p>在更高层面，在 webpack 的配置中，<strong>loader</strong> 有两个属性：</p>\n<ol>\n<li><code>test</code> 属性，识别出哪些文件会被转换。</li>\n<li><code>use</code> 属性，定义出在进行转换时，应该使用哪个 loader。</li>\n</ol>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'path\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    filename<span class="token punctuation">:</span> <span class="token string">\'my-first-webpack.bundle.js\'</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>\n      <span class="token punctuation">{</span> test<span class="token punctuation">:</span> <span class="token regex">/\\.txt$/</span><span class="token punctuation">,</span> use<span class="token punctuation">:</span> <span class="token string">\'raw-loader\'</span> <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n<p>以上配置中，对一个单独的 module 对象定义了 <code>rules</code> 属性，里面包含两个必须属性：<code>test</code> 和 <code>use</code>。这告诉 webpack 编译器(compiler) 如下信息：</p>\n<blockquote>\n<p>“嘿，webpack 编译器，当你碰到「在 <code>require()</code>/<code>import</code> 语句中被解析为 \'.txt\' 的路径」时，在你对它打包之前，先 <strong>use(使用)</strong> <code>raw-loader</code> 转换一下。”</p>\n</blockquote>\n<blockquote class="warning">\n<p>重要的是要记住，在 webpack 配置中定义 rules 时，要定义在 <code>module.rules</code> 而不是 <code>rules</code> 中。为了使你便于理解，如果没有按照正确方式去做，webpack 会给出警告。</p>\n</blockquote>\n<blockquote class="warning">\n<p>请记住，使用正则表达式匹配文件时，你不要为它添加引号。也就是说，<code>/\\.txt$/</code> 与 <code>\'/\\.txt$/\'</code> 或 <code>"/\\.txt$/"</code> 不一样。前者指示 webpack 匹配任何以 .txt 结尾的文件，后者指示 webpack 匹配具有绝对路径 \'.txt\' 的单个文件; 这可能不符合你的意图。</p>\n</blockquote>\n<p>在使用 loader 时，可以阅读 <a href="/concepts/loaders">loader 章节</a> 查看更深入的自定义配置。</p>\n<h2 id="plugins">插件(plugin) <a href="#plugins" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。</p>\n<blockquote class="tip">\n<p>查看 <a href="/api/plugins">插件接口(plugin interface)</a>，学习如何使用它来扩展 webpack 能力。</p>\n</blockquote>\n<p>想要使用一个插件，你只需要 <code>require()</code> 它，然后把它添加到 <code>plugins</code> 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 <code>new</code> 操作符来创建一个插件实例。</p>\n<p><strong>webpack.config.js</strong></p>\n<pre><code class="hljs language-javascript"><span class="token keyword">const</span> HtmlWebpackPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'html-webpack-plugin\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 通过 npm 安装</span>\n<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'webpack\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 用于访问内置插件</span>\n\nmodule<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>\n      <span class="token punctuation">{</span> test<span class="token punctuation">:</span> <span class="token regex">/\\.txt$/</span><span class="token punctuation">,</span> use<span class="token punctuation">:</span> <span class="token string">\'raw-loader\'</span> <span class="token punctuation">}</span>\n    <span class="token punctuation">]</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>\n    <span class="token keyword">new</span> <span class="token class-name">HtmlWebpackPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>template<span class="token punctuation">:</span> <span class="token string">\'./src/index.html\'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n<p>在上面的示例中，<code>html-webpack-plugin</code> 为应用程序生成 HTML 一个文件，并自动注入所有生成的 bundle。</p>\n<blockquote class="tip">\n<p>webpack 提供许多开箱可用的插件！查阅 <a href="/plugins">插件列表</a> 获取更多。</p>\n</blockquote>\n<p>在 webpack 配置中使用插件是简单直接的。然而，也有很多值得我们进一步探讨的用例。<a href="/concepts/plugins">查看这里了解更多</a>。</p>\n<h2 id="mode">模式(mode) <a href="#mode" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>通过选择 <code>development</code>, <code>production</code> 或 <code>none</code> 之中的一个，来设置 <code>mode</code> 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 <code>production</code>。</p>\n<pre><code class="hljs language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>\n  mode<span class="token punctuation">:</span> <span class="token string">\'production\'</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n<p>想要了解更多，请查阅 <a href="/configuration/mode">mode 配置</a>，这里有具体每个值相应的优化行为。</p>\n<h2 id="browser-compatibility">浏览器兼容性(browser compatibility) <a href="#browser-compatibility" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>webpack 支持所有符合 <a href="https://kangax.github.io/compat-table/es5/">ES5 标准</a> 的浏览器（不支持 IE8 及以下版本）。webpack 的 <code>import()</code> 和 <code>require.ensure()</code> 需要 <code>Promise</code>。如果你想要支持旧版本浏览器，在使用这些表达式之前，还需要 <a href="/guides/shimming/">提前加载 polyfill</a>。</p>\n<h2 id="environment">环境(environment) <a href="#environment" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>webpack 运行与 Node.js v8.x+ 版本。</p>\n'}}]);