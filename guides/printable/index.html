<!DOCTYPE html><html lang="en" data-reactroot=""><head><meta charset="utf-8"/><meta name="theme-color" content="#2B3A42"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="robots" content="noindex,nofollow"/><title>webpack 官方中文文档</title><meta name="description" content="webpack 是一个模块打包器。它的主要目标是将 JavaScript 文件打包在一起，打包后的文件用于在浏览器中使用，但它也能够胜任转换（transform）、打包（bundle）或包裹（package）任何资源(resource or asset)。"/><meta property="og:site_name" content="webpack"/><meta property="og:type" content="website"/><meta property="og:title" content="webpack 官方中文文档"/><meta property="og:description" name="description" content="webpack 是一个模块打包器。它的主要目标是将 JavaScript 文件打包在一起，打包后的文件用于在浏览器中使用，但它也能够胜任转换（transform）、打包（bundle）或包裹（package）任何资源(resource or asset)。"/><meta property="og:image" content="https://webpack.js.org/dcd5e077cf9f54ebe52d4f7ebe8c3080.png"/><meta property="twitter:card" content="summary"/><meta property="twitter:site" content="@webpack"/><meta property="twitter:creator" content="@webpack"/><meta property="twitter:domain" content="https://webpack.js.org/"/><meta name="keywords" content="webpack5, webpack, webpack 中文文档, 印记中文, docschina, docschina.org, webpack.docschina.org, doc.react-china.org, nodejs.cn, vue.docschina.org, babel.docschina.org, parceljs.docschina.org, rollup.docschina.org, koajs.docschina.org"/><link rel="icon" type="image/x-icon" href="/bc3effb418df77da9e04825c48a58a49.ico"/><link rel="stylesheet" href="/50fdfa6f49416fbf9d03.css"/><link rel="stylesheet" href="/3faf4b4c06cd5fb9953a.css"/><link rel="manifest" href="/manifest.json"/><link rel="canonical" href="https://webpack.js.org/guides/printable/"/><meta name="mobile-web-app-capable" content="yes"/><link rel="icon" sizes="192x192" href="/icon_192x192.png"/><link rel="icon" sizes="512x512" href="/icon_512x512.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="apple-mobile-web-app-title" content="webpack"/><link rel="apple-touch-icon-precomposed" href="/icon_180x180.png"/><link rel="mask-icon" href="/aad9d51e01a0dcc2caf5bee43dc8e647.svg" color="#465e69"/><meta name="msapplication-TileImage" content="/icon_150x150.png"/><meta name="msapplication-TileColor" content="#465e69"/></head><body><div id="root"><div class="site"><div class="site__header"><div class="notification-bar"><div class="container notification-bar__inner"><p>Sponsor webpack and get apparel from the <a href="https://webpack.threadless.com">official shop</a>! All proceeds go to our <a href="https://opencollective.com/webpack">open collective</a>!</p></div></div><header class="navigation   "><section class="navigation__inner"><button aria-label="Open menu" class="navigation__mobile"><svg viewBox="-62 138 25 25"><g><g><path d="M-60.2,140.2h20.9c1,0,1.8,0.8,1.8,1.8l0,0c0,1-0.8,1.8-1.8,1.8h-20.9c-1,0-1.8-0.8-1.8-1.8l0,0 C-62,141-61.2,140.2-60.2,140.2z"></path><path d="M-60.2,148.7h20.9c1,0,1.8,0.8,1.8,1.8l0,0c0,1-0.8,1.8-1.8,1.8h-20.9c-1,0-1.8-0.8-1.8-1.8l0,0 C-62,149.5-61.2,148.7-60.2,148.7z"></path><path d="M-60.2,157.2h20.9c1,0,1.8,0.8,1.8,1.8l0,0c0,1-0.8,1.8-1.8,1.8h-20.9c-1,0-1.8-0.8-1.8-1.8l0,0 C-62,158-61.2,157.2-60.2,157.2z"></path></g></g></svg></button><a class="navigation__logo" href="/"><img class="logo" src="/e0b5805d423a4ec9473ee315250968b2.svg" alt="webpack logo"/></a><nav class="navigation__items"><a class="navigation__item  navigation__item--active" href="/concepts/">文档</a><a class="navigation__item  " href="/contribute/">参与贡献</a><a class="navigation__item  " href="/vote/">投票</a><a href="https://medium.com/webpack" target="_blank" rel="noopener" class="navigation__item  ">博客</a><a href="https://docschina.org" target="_blank" rel="noopener" class="navigation__item  ">印记中文</a><a href="https://github.com/webpack/webpack" target="_blank" rel="noopener" title="GitHub Repository" class="navigation__item navigation__item--icon "><i aria-hidden="true" class="icon-github"></i></a><a href="https://twitter.com/webpack" target="_blank" rel="noopener" title="webpack on Twitter" class="navigation__item navigation__item--icon "><i aria-hidden="true" class="icon-twitter"></i></a><a href="https://stackoverflow.com/questions/tagged/webpack" target="_blank" rel="noopener" title="webpack on Stack Overflow" class="navigation__item navigation__item--icon "><i aria-hidden="true" class="icon-stack-overflow"></i></a><span class="navigation__item navigation__item--icon"><nav class="dropdown navigation__languages"><button aria-haspopup="true" aria-expanded="false" aria-label="Select language"><img class="dropdown__language" alt="select language" src="/57c717e75066b659cfe19dc2a643153c.svg"/><i aria-hidden="true" class="dropdown__arrow"></i></button><div class="dropdown__list "><ul><li><a href="https://webpack.js.org/"><span>English</span></a></li><li><a href="https://webpack.docschina.org/"><span lang="zh">中文</span></a></li></ul></div></nav></span></nav><div class="navigation-search "><input type="text" class="navigation-search__input" placeholder="Search this site..." value=""/><button aria-label="Hide search box" class="navigation-search__icon navigation-search__clear"><svg viewBox="-137 138 25 25"><g transform="translate(0,-952.36218)"><path d="M-131.3,1094.4c-0.4,0-0.9,0.1-1.2,0.5c-0.7,0.7-0.7,1.7,0,2.4l5.6,5.6l-5.6,5.6c-0.7,0.7-0.7,1.7,0,2.4 c0.7,0.7,1.7,0.7,2.4,0l5.6-5.6l5.6,5.6c0.7,0.7,1.7,0.7,2.4,0c0.7-0.7,0.7-1.7,0-2.4l-5.6-5.6l5.6-5.6c0.7-0.7,0.7-1.7,0-2.4 c-0.7-0.7-1.7-0.7-2.4,0l-5.6,5.6l-5.6-5.6C-130.5,1094.5-130.9,1094.4-131.3,1094.4L-131.3,1094.4z"></path></g></svg></button><button aria-label="Show search box" class="navigation-search__icon navigation-search__search"><svg viewBox="-137 138 25 25"><g><path d="M-114.6,162.6l-7.5-7.5c-0.6-0.6-0.6-1.6,0-2.1l0,0c0.6-0.6,1.6-0.6,2.1,0l7.5,7.5c0.6,0.6,0.6,1.6,0,2.1l0,0 C-113,163.1-114,163.1-114.6,162.6z"></path><path d="M-134.1,140.9c-3.9,3.9-3.9,10.2,0,14.1s10.2,3.9,14.1,0s3.9-10.2,0-14.1S-130.2,137-134.1,140.9z M-122.1,153 c-2.7,2.7-7.1,2.7-9.8,0s-2.7-7.1,0-9.8s7.1-2.7,9.8,0C-119.4,145.9-119.4,150.2-122.1,153z"></path></g></svg></button></div></section><div class="navigation-sub"><div class="navigation-sub__inner"><a class="navigation-sub__link navigation-sub__link--active" title="指南" content="指南" href="/guides/">指南</a><a class="navigation-sub__link " title="api" content="api" href="/api/">api</a><a class="navigation-sub__link " title="plugin" content="plugin" href="/plugins/">plugin</a><a class="navigation-sub__link " title="概念" content="概念" href="/concepts/">概念</a><a class="navigation-sub__link " title="配置" content="配置" href="/configuration/">配置</a><a class="navigation-sub__link " title="迁移" content="迁移" href="/migrate/">迁移</a><a class="navigation-sub__link " title="loader" content="loader" href="/loaders/">loader</a></div></div></header></div><div class="container site__content"><div class="sponsors"><a href="https://www.ag-grid.com/?utm_source=webpack&amp;utm_medium=banner&amp;utm_campaign=sponsorship" target="_blank" rel="noopener" class="sponsors__content"><img src="/bf176a25b4f8227fea804854c98dc5e2.png"/><img src="/d19378a95ebe6b15d5ddea281138dcf4.svg" style="width:100px"/><div style="margin-top:1em;font-size:2em;text-align:center;color:#535353">ag-grid is proud to partner with webpack</div></a></div><nav class="sidebar site__sidebar"><div class="sidebar__inner"><div class="sidebar__shields"><a href="https://github.com/webpack/webpack/releases"><img alt="webpack shield" src="https://img.shields.io/github/package-json/v/webpack/webpack.svg?label=webpack&amp;style=flat-square&amp;maxAge=3600"/></a></div><div class="sidebar-item sidebar-item--disabled`"><i class="sidebar-item__toggle icon-vertical-bar"></i><a class="sidebar-item__title sidebar-link__print" href="/guides/printable/" rel="nofollow" alt="Print" title="Print" target="_blank">Print Section<img src="/96ccbfac58b65e83657a220603e00abe.svg"/></a></div><div><div class="sidebar-item  sidebar-item--disabled"><i class="sidebar-item__toggle icon-vertical-bar"></i><a class="sidebar-item__title" href="/guides/">指南</a></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/getting-started/">起步</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="基本安装"><a href="/guides/getting-started/#basic-setup">基本安装</a></li><li class="sidebar-item__anchor" title="创建一个 bundle"><a href="/guides/getting-started/#creating-a-bundle">创建一个 bundle</a></li><li class="sidebar-item__anchor" title="模块"><a href="/guides/getting-started/#modules">模块</a></li><li class="sidebar-item__anchor" title="使用一个配置文件"><a href="/guides/getting-started/#using-a-configuration">使用一个配置文件</a></li><li class="sidebar-item__anchor" title="npm scripts"><a href="/guides/getting-started/#npm-scripts">npm scripts</a></li><li class="sidebar-item__anchor" title="结论"><a href="/guides/getting-started/#conclusion">结论</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/asset-management/">管理资源</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="设置"><a href="/guides/asset-management/#setup">设置</a></li><li class="sidebar-item__anchor" title="加载 CSS"><a href="/guides/asset-management/#loading-css">加载 CSS</a></li><li class="sidebar-item__anchor" title="加载 images 图像"><a href="/guides/asset-management/#loading-images">加载 images 图像</a></li><li class="sidebar-item__anchor" title="加载 fonts 字体"><a href="/guides/asset-management/#loading-fonts">加载 fonts 字体</a></li><li class="sidebar-item__anchor" title="加载数据"><a href="/guides/asset-management/#loading-data">加载数据</a></li><li class="sidebar-item__anchor" title="全局资源"><a href="/guides/asset-management/#global-assets">全局资源</a></li><li class="sidebar-item__anchor" title="回退处理"><a href="/guides/asset-management/#wrapping-up">回退处理</a></li><li class="sidebar-item__anchor" title="下篇指南"><a href="/guides/asset-management/#next-guide">下篇指南</a></li><li class="sidebar-item__anchor" title="延伸阅读"><a href="/guides/asset-management/#further-reading">延伸阅读</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/output-management/">管理输出</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="预先准备"><a href="/guides/output-management/#preparation">预先准备</a></li><li class="sidebar-item__anchor" title="设置 HtmlWebpackPlugin"><a href="/guides/output-management/#setting-up-htmlwebpackplugin">设置 HtmlWebpackPlugin</a></li><li class="sidebar-item__anchor" title="清理 /dist 文件夹"><a href="/guides/output-management/#cleaning-up-the-dist-folder">清理 /dist 文件夹</a></li><li class="sidebar-item__anchor" title="manifest"><a href="/guides/output-management/#the-manifest">manifest</a></li><li class="sidebar-item__anchor" title="结论"><a href="/guides/output-management/#conclusion">结论</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/development/">开发环境</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="使用 source map"><a href="/guides/development/#using-source-maps">使用 source map</a></li><li class="sidebar-item__anchor" title="选择一个开发工具"><a href="/guides/development/#choosing-a-development-tool">选择一个开发工具</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="使用 watch mode(观察模式)"><a href="/guides/development/#using-watch-mode">使用 watch mode(观察模式)</a></li><li class="sidebar-item__anchor" title="使用 webpack-dev-server"><a href="/guides/development/#using-webpack-dev-server">使用 webpack-dev-server</a></li><li class="sidebar-item__anchor" title="使用 webpack-dev-middleware"><a href="/guides/development/#using-webpack-dev-middleware">使用 webpack-dev-middleware</a></li></ul></li><li class="sidebar-item__anchor" title="调整文本编辑器"><a href="/guides/development/#adjusting-your-text-editor">调整文本编辑器</a></li><li class="sidebar-item__anchor" title="结论"><a href="/guides/development/#conclusion">结论</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/code-splitting/">代码分离</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="入口起点(entry point)"><a href="/guides/code-splitting/#entry-points">入口起点(entry point)</a></li><li class="sidebar-item__anchor" title="防止重复(prevent duplication)"><a href="/guides/code-splitting/#prevent-duplication">防止重复(prevent duplication)</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="入口依赖"><a href="/guides/code-splitting/#entry-dependencies">入口依赖</a></li><li class="sidebar-item__anchor" title="SplitChunksPlugin"><a href="/guides/code-splitting/#splitchunksplugin">SplitChunksPlugin</a></li></ul></li><li class="sidebar-item__anchor" title="动态导入(dynamic import)"><a href="/guides/code-splitting/#dynamic-imports">动态导入(dynamic import)</a></li><li class="sidebar-item__anchor" title="预获取/预加载模块(prefetch/preload module)"><a href="/guides/code-splitting/#prefetchingpreloading-modules">预获取/预加载模块(prefetch/preload module)</a></li><li class="sidebar-item__anchor" title="bundle 分析(bundle analysis)"><a href="/guides/code-splitting/#bundle-analysis">bundle 分析(bundle analysis)</a></li><li class="sidebar-item__anchor" title="下一步"><a href="/guides/code-splitting/#next-steps">下一步</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/caching/">缓存</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="输出文件的文件名(output filename)"><a href="/guides/caching/#output-filenames">输出文件的文件名(output filename)</a></li><li class="sidebar-item__anchor" title="提取引导模板(extracting boilerplate)"><a href="/guides/caching/#extracting-boilerplate">提取引导模板(extracting boilerplate)</a></li><li class="sidebar-item__anchor" title="模块标识符(module identifier)"><a href="/guides/caching/#module-identifiers">模块标识符(module identifier)</a></li><li class="sidebar-item__anchor" title="结论"><a href="/guides/caching/#conclusion">结论</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/author-libraries/">创建 library</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="创建一个 library"><a href="/guides/author-libraries/#authoring-a-library">创建一个 library</a></li><li class="sidebar-item__anchor" title="基本配置"><a href="/guides/author-libraries/#base-configuration">基本配置</a></li><li class="sidebar-item__anchor" title="使用 source map 的基本配置"><a href="/guides/author-libraries/#base-configuration-with-source-map">使用 source map 的基本配置</a></li><li class="sidebar-item__anchor" title="外部化 lodash"><a href="/guides/author-libraries/#externalize-lodash">外部化 lodash</a></li><li class="sidebar-item__anchor" title="外部化的限制"><a href="/guides/author-libraries/#external-limitations">外部化的限制</a></li><li class="sidebar-item__anchor" title="暴露 library"><a href="/guides/author-libraries/#expose-the-library">暴露 library</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="最终步骤"><a href="/guides/author-libraries/#final-steps">最终步骤</a></li></ul></li></ul></div></div><div><div class="sidebar-item  sidebar-item--disabled"><i class="sidebar-item__toggle icon-vertical-bar"></i><a class="sidebar-item__title" href="/guides/environment-variables/">环境变量</a></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/build-performance/">构建性能</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="通用环境"><a href="/guides/build-performance/#general">通用环境</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="更新到最新版本"><a href="/guides/build-performance/#stay-up-to-date">更新到最新版本</a></li><li class="sidebar-item__anchor" title="loader"><a href="/guides/build-performance/#loaders">loader</a></li><li class="sidebar-item__anchor" title="引导(bootstrap)"><a href="/guides/build-performance/#bootstrap">引导(bootstrap)</a></li><li class="sidebar-item__anchor" title="解析"><a href="/guides/build-performance/#resolving">解析</a></li><li class="sidebar-item__anchor" title="dll"><a href="/guides/build-performance/#dlls">dll</a></li><li class="sidebar-item__anchor" title="小即是快(smaller = faster)"><a href="/guides/build-performance/#smaller--faster">小即是快(smaller = faster)</a></li><li class="sidebar-item__anchor" title="worker 池(worker pool)"><a href="/guides/build-performance/#worker-pool">worker 池(worker pool)</a></li><li class="sidebar-item__anchor" title="持久化缓存"><a href="/guides/build-performance/#persistent-cache">持久化缓存</a></li><li class="sidebar-item__anchor" title="自定义 plugin/loader"><a href="/guides/build-performance/#custom-pluginsloaders">自定义 plugin/loader</a></li><li class="sidebar-item__anchor" title="Progress plugin"><a href="/guides/build-performance/#progress-plugin">Progress plugin</a></li></ul></li><li class="sidebar-item__anchor" title="开发环境"><a href="/guides/build-performance/#development">开发环境</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="增量编译"><a href="/guides/build-performance/#incremental-builds">增量编译</a></li><li class="sidebar-item__anchor" title="在内存中编译"><a href="/guides/build-performance/#compile-in-memory">在内存中编译</a></li><li class="sidebar-item__anchor" title="stats.toJson 加速"><a href="/guides/build-performance/#statstojson-speed">stats.toJson 加速</a></li><li class="sidebar-item__anchor" title="Devtool"><a href="/guides/build-performance/#devtool">Devtool</a></li><li class="sidebar-item__anchor" title="避免在生产环境下才会用到的工具"><a href="/guides/build-performance/#avoid-production-specific-tooling">避免在生产环境下才会用到的工具</a></li><li class="sidebar-item__anchor" title="最小化 entry chunk"><a href="/guides/build-performance/#minimal-entry-chunk">最小化 entry chunk</a></li><li class="sidebar-item__anchor" title="避免额外的优化步骤"><a href="/guides/build-performance/#avoid-extra-optimization-steps">避免额外的优化步骤</a></li><li class="sidebar-item__anchor" title="输出结果不携带路径信息"><a href="/guides/build-performance/#output-without-path-info">输出结果不携带路径信息</a></li><li class="sidebar-item__anchor" title="Node.js 版本 8.9.10-9.11.1"><a href="/guides/build-performance/#nodejs-versions-8910-9111">Node.js 版本 8.9.10-9.11.1</a></li><li class="sidebar-item__anchor" title="TypeScript loader"><a href="/guides/build-performance/#typescript-loader">TypeScript loader</a></li></ul></li><li class="sidebar-item__anchor" title="生产环境"><a href="/guides/build-performance/#production">生产环境</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="多个 compilation 对象"><a href="/guides/build-performance/#multiple-compilations">多个 compilation 对象</a></li><li class="sidebar-item__anchor" title="Source Maps"><a href="/guides/build-performance/#source-maps">Source Maps</a></li></ul></li><li class="sidebar-item__anchor" title="工具相关问题"><a href="/guides/build-performance/#specific-tooling-issues">工具相关问题</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="Babel"><a href="/guides/build-performance/#babel">Babel</a></li><li class="sidebar-item__anchor" title="TypeScript"><a href="/guides/build-performance/#typescript">TypeScript</a></li><li class="sidebar-item__anchor" title="Sass"><a href="/guides/build-performance/#sass">Sass</a></li></ul></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/csp/">内容安全策略</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="示例"><a href="/guides/csp/#examples">示例</a></li><li class="sidebar-item__anchor" title="启用 CSP"><a href="/guides/csp/#enabling-csp">启用 CSP</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/development-vagrant/">开发 - Vagrant</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="配置项目"><a href="/guides/development-vagrant/#configuring-the-project">配置项目</a></li><li class="sidebar-item__anchor" title="启动服务器"><a href="/guides/development-vagrant/#running-the-server">启动服务器</a></li><li class="sidebar-item__anchor" title="配合 nginx 的高级用法"><a href="/guides/development-vagrant/#advanced-usage-with-nginx">配合 nginx 的高级用法</a></li><li class="sidebar-item__anchor" title="结论"><a href="/guides/development-vagrant/#conclusion">结论</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/dependency-management/">依赖管理</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="带表达式的 require 语句"><a href="/guides/dependency-management/#require-with-expression">带表达式的 require 语句</a></li><li class="sidebar-item__anchor" title="require.context"><a href="/guides/dependency-management/#requirecontext">require.context</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="context module API"><a href="/guides/dependency-management/#context-module-api">context module API</a></li></ul></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/installation/">安装</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="前提条件"><a href="/guides/installation/#prerequisites">前提条件</a></li><li class="sidebar-item__anchor" title="本地安装"><a href="/guides/installation/#local-installation">本地安装</a></li><li class="sidebar-item__anchor" title="全局安装"><a href="/guides/installation/#global-installation">全局安装</a></li><li class="sidebar-item__anchor" title="最新体验版本"><a href="/guides/installation/#bleeding-edge">最新体验版本</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/scaffolding/">脚手架</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="创建脚手架"><a href="/guides/scaffolding/#creating-a-scaffold">创建脚手架</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="编写脚手架"><a href="/guides/scaffolding/#writing-a-scaffold">编写脚手架</a></li><li class="sidebar-item__anchor" title="执行脚手架"><a href="/guides/scaffolding/#running-a-scaffold">执行脚手架</a></li></ul></li><li class="sidebar-item__anchor" title="API"><a href="/guides/scaffolding/#api">API</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="必选项"><a href="/guides/scaffolding/#required">必选项</a></li><li class="sidebar-item__anchor" title="可选项"><a href="/guides/scaffolding/#optional">可选项</a></li><li class="sidebar-item__anchor" title="opts.env.configuration（必选项）"><a href="/guides/scaffolding/#optsenvconfigurationrequired">opts.env.configuration（必选项）</a></li><li class="sidebar-item__anchor" title="opts.env.configuration.myObj（必选项）"><a href="/guides/scaffolding/#optsenvconfigurationmyobj-required">opts.env.configuration.myObj（必选项）</a></li><li class="sidebar-item__anchor" title="myObj.webpackOptions（必选项）"><a href="/guides/scaffolding/#myobjwebpackoptions-required">myObj.webpackOptions（必选项）</a></li><li class="sidebar-item__anchor" title="writing（必选项）"><a href="/guides/scaffolding/#writing-required">writing（必选项）</a></li><li class="sidebar-item__anchor" title="myObj.merge（可选项）"><a href="/guides/scaffolding/#myobjmerge-optional">myObj.merge（可选项）</a></li><li class="sidebar-item__anchor" title="myObj.topScope（可选项）"><a href="/guides/scaffolding/#myobjtopscopeoptional">myObj.topScope（可选项）</a></li><li class="sidebar-item__anchor" title="myObj.configName（可选项）"><a href="/guides/scaffolding/#myobjconfignameoptional">myObj.configName（可选项）</a></li></ul></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/hot-module-replacement/">模块热替换</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="启用 HMR"><a href="/guides/hot-module-replacement/#enabling-hmr">启用 HMR</a></li><li class="sidebar-item__anchor" title="通过 Node.js API"><a href="/guides/hot-module-replacement/#via-the-nodejs-api">通过 Node.js API</a></li><li class="sidebar-item__anchor" title="问题"><a href="/guides/hot-module-replacement/#gotchas">问题</a></li><li class="sidebar-item__anchor" title="HMR 加载样式"><a href="/guides/hot-module-replacement/#hmr-with-stylesheets">HMR 加载样式</a></li><li class="sidebar-item__anchor" title="其他代码和框架"><a href="/guides/hot-module-replacement/#other-code-and-frameworks">其他代码和框架</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/tree-shaking/">Tree Shaking</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="添加一个通用模块"><a href="/guides/tree-shaking/#add-a-utility">添加一个通用模块</a></li><li class="sidebar-item__anchor" title="将文件标记为 side-effect-free(无副作用)"><a href="/guides/tree-shaking/#mark-the-file-as-side-effect-free">将文件标记为 side-effect-free(无副作用)</a></li><li class="sidebar-item__anchor" title="解释 tree shaking 和 sideEffects"><a href="/guides/tree-shaking/#clarifying-tree-shaking-and-sideeffects">解释 tree shaking 和 sideEffects</a></li><li class="sidebar-item__anchor" title="将函数调用标记为无副作用"><a href="/guides/tree-shaking/#mark-a-function-call-as-side-effect-free">将函数调用标记为无副作用</a></li><li class="sidebar-item__anchor" title="压缩输出结果"><a href="/guides/tree-shaking/#minify-the-output">压缩输出结果</a></li><li class="sidebar-item__anchor" title="结论"><a href="/guides/tree-shaking/#conclusion">结论</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/production/">生产环境</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="配置"><a href="/guides/production/#setup">配置</a></li><li class="sidebar-item__anchor" title="NPM Scripts"><a href="/guides/production/#npm-scripts">NPM Scripts</a></li><li class="sidebar-item__anchor" title="指定 mode"><a href="/guides/production/#specify-the-mode">指定 mode</a></li><li class="sidebar-item__anchor" title="压缩(Minification)"><a href="/guides/production/#minification">压缩(Minification)</a></li><li class="sidebar-item__anchor" title="源码映射(Source Mapping)"><a href="/guides/production/#source-mapping">源码映射(Source Mapping)</a></li><li class="sidebar-item__anchor" title="压缩 CSS"><a href="/guides/production/#minimize-css">压缩 CSS</a></li><li class="sidebar-item__anchor" title="CLI 替代选项"><a href="/guides/production/#cli-alternatives">CLI 替代选项</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/lazy-loading/">懒加载</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="示例"><a href="/guides/lazy-loading/#example">示例</a></li><li class="sidebar-item__anchor" title="框架"><a href="/guides/lazy-loading/#frameworks">框架</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/shimming/">Shimming 预置依赖</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="Shimming 预置全局变量"><a href="/guides/shimming/#shimming-globals">Shimming 预置全局变量</a></li><li class="sidebar-item__anchor" title="细粒度 Shimming"><a href="/guides/shimming/#granular-shimming">细粒度 Shimming</a></li><li class="sidebar-item__anchor" title="全局 Exports"><a href="/guides/shimming/#global-exports">全局 Exports</a></li><li class="sidebar-item__anchor" title="加载 Polyfills"><a href="/guides/shimming/#loading-polyfills">加载 Polyfills</a></li><li class="sidebar-item__anchor" title="进一步优化"><a href="/guides/shimming/#further-optimizations">进一步优化</a></li><li class="sidebar-item__anchor" title="Node 内置"><a href="/guides/shimming/#node-built-ins">Node 内置</a></li><li class="sidebar-item__anchor" title="其他工具"><a href="/guides/shimming/#other-utilities">其他工具</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/typescript/">TypeScript</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="基础配置"><a href="/guides/typescript/#basic-setup">基础配置</a></li><li class="sidebar-item__anchor" title="Loader"><a href="/guides/typescript/#loader">Loader</a></li><li class="sidebar-item__anchor" title="Source Maps"><a href="/guides/typescript/#source-maps">Source Maps</a></li><li class="sidebar-item__anchor" title="使用第三方类库"><a href="/guides/typescript/#using-third-party-libraries">使用第三方类库</a></li><li class="sidebar-item__anchor" title="导入其他资源"><a href="/guides/typescript/#importing-other-assets">导入其他资源</a></li><li class="sidebar-item__anchor" title="构建性能"><a href="/guides/typescript/#build-performance">构建性能</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/progressive-web-application/">渐进式网络应用程序</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="现在，我们并没有运行在离线环境下"><a href="/guides/progressive-web-application/#we-dont-work-offline-now">现在，我们并没有运行在离线环境下</a></li><li class="sidebar-item__anchor" title="添加 Workbox"><a href="/guides/progressive-web-application/#adding-workbox">添加 Workbox</a></li><li class="sidebar-item__anchor" title="注册 Service Worker"><a href="/guides/progressive-web-application/#registering-our-service-worker">注册 Service Worker</a></li><li class="sidebar-item__anchor" title="结论"><a href="/guides/progressive-web-application/#conclusion">结论</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/public-path/">公共路径</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="示例"><a href="/guides/public-path/#use-cases">示例</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="基于环境设置"><a href="/guides/public-path/#environment-based">基于环境设置</a></li><li class="sidebar-item__anchor" title="在运行时设置"><a href="/guides/public-path/#on-the-fly">在运行时设置</a></li></ul></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/integrations/">集成</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="NPM Scripts"><a href="/guides/integrations/#npm-scripts">NPM Scripts</a></li><li class="sidebar-item__anchor" title="Grunt"><a href="/guides/integrations/#grunt">Grunt</a></li><li class="sidebar-item__anchor" title="Gulp"><a href="/guides/integrations/#gulp">Gulp</a></li><li class="sidebar-item__anchor" title="Mocha"><a href="/guides/integrations/#mocha">Mocha</a></li><li class="sidebar-item__anchor" title="Karma"><a href="/guides/integrations/#karma">Karma</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/entry-advanced/">entry 高级用法</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="每个入口使用多种文件类型"><a href="/guides/entry-advanced/#multiple-file-types-per-entry">每个入口使用多种文件类型</a></li></ul></div></div><div><div class="sidebar-item  "><i class="sidebar-item__toggle icon-chevron-right"></i><a class="sidebar-item__title" href="/guides/asset-modules/">资源模块</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="resource 资源(resource asset)"><a href="/guides/asset-modules/#resource-assets">resource 资源(resource asset)</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="自定义输出文件名"><a href="/guides/asset-modules/#custom-output-filename">自定义输出文件名</a></li></ul></li><li class="sidebar-item__anchor" title="inline 资源(inlining asset)"><a href="/guides/asset-modules/#inlining-assets">inline 资源(inlining asset)</a><ul class="sidebar-item__anchors"><li class="sidebar-item__anchor" title="自定义 data URI 生成器"><a href="/guides/asset-modules/#custom-data-uri-generator">自定义 data URI 生成器</a></li></ul></li><li class="sidebar-item__anchor" title="source 资源(source asset)"><a href="/guides/asset-modules/#source-assets">source 资源(source asset)</a></li><li class="sidebar-item__anchor" title="通用资源类型(general asset type)"><a href="/guides/asset-modules/#general-asset-type">通用资源类型(general asset type)</a></li></ul></div></div><div class="sidebar__docs-version">You are reading webpack <!-- -->5<!-- --> documentation. Change here to:<ul><li><a rel="nofollow" href="https://v4.webpack.docschina.org">webpack <!-- -->4<!-- --> documentation</a></li></ul></div></div></nav><section class="page"><div class="page-links"><a class="page-links__link" href="https://github.com/docschina/webpack.js.org/edit/cn/src/content/guides/printable.md">编辑此页<i class="page-links__icon icon-edit"></i></a><span class="page-links__gap">|</span><button class="page-links__link page-links__print as-link" title="Print this page">打印文档<img src="/96ccbfac58b65e83657a220603e00abe.svg"/></button></div><div class="markdown"><h1>Printable</h1><div><h1 id="指南">指南<a href="#%E6%8C%87%E5%8D%97" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p>指南章节，用于理解和掌握 webpack 提供的各种工具和特性。首先，通过 <a href="/guides/getting-started/">起步</a> 进行简单导入。</p>
<p>指南会逐步带你由浅入深。本章节更多是作为一个切入点，一旦阅读完成后，你就会更加容易深入到实际的 <a href="/configuration">配置</a> 文档中。</p>
<blockquote class="warning">
<p>指南中运行 webpack 后显示的输出，可能和新版本的输出略有不同。这是意料之中的事情。只要 bundle 看起来接近，而且运行正常，那就没有问题。如果你遇到在新版本中，示例无法良好运行，请 <a href="https://github.com/webpack/webpack.js.org/issues/new/choose">创建一个 issue</a>，我们将尽力解决版本差异。</p>
</blockquote>
<h1 id="起步">起步<a href="#%E8%B5%B7%E6%AD%A5" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p>webpack 用于编译 JavaScript 模块。一旦完成 <a href="/guides/installation">安装</a>，你就可以通过 webpack <a href="/api/cli">CLI</a> 或 <a href="/api/node">API</a> 与其配合交互。如果你还不熟悉 webpack，请阅读 <a href="/concepts">核心概念</a> 和 <a href="/comparison">对比</a>，了解为什么要使用 webpack，而不是社区中的其他工具。</p>
<blockquote class="warning">
<p>从 webpack v5.0.0-beta.1 开始，需要运行的 Node.js 最低版本是 10.13.0 (LTS)</p>
</blockquote>
<h2 id="basic-setup">基本安装 <a href="#basic-setup" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>首先我们创建一个目录，初始化 npm，然后 <a href="/guides/installation#local-installation">在本地安装 webpack</a>，接着安装 webpack-cli（此工具用于在命令行中运行 webpack）：</p>
<pre><code class="hljs language-bash"><span class="token function">mkdir</span> webpack-demo
<span class="token function">cd</span> webpack-demo
<span class="token function">npm</span> init -y
<span class="token function">npm</span> <span class="token function">install</span> webpack webpack-cli --save-dev</code></pre>
<blockquote class="tip">
<p>贯穿整个指南的是，我们将使用 <code>diff</code> 块，来展示对目录、文件和代码所做的修改。</p>
</blockquote>
<p>现在，我们将创建以下目录结构、文件和内容：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  |- package.json
<span class="token inserted">+ |- index.html</span>
<span class="token inserted">+ |- /src</span>
<span class="token inserted">+   |- index.js</span></code></pre>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-javascript"><span class="token keyword">function</span> <span class="token function">component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// lodash（目前通过一个 script 引入）对于执行这一行是必需的</span>
  element<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Hello'</span><span class="token punctuation">,</span> <span class="token string">'webpack'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> element<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>index.html</strong></p>
<pre><code class="hljs language-html"><span class="token doctype">&#x3C;!doctype html></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>html</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>title</span><span class="token punctuation">></span></span>起步<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>title</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://unpkg.com/lodash@4.16.6<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>script</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>head</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./src/index.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>script</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<p>我们还需要调整 <code>package.json</code> 文件，以便确保我们安装包是 <code>private(私有的)</code>，并且移除 <code>main</code> 入口。这可以防止意外发布你的代码。</p>
<blockquote class="tip">
<p>如果你想要了解 <code>package.json</code> 内在机制的更多信息，我们推荐阅读 <a href="https://docs.npmjs.com/files/package.json">npm 文档</a>。</p>
</blockquote>
<p><strong>package.json</strong></p>
<pre><code class="hljs language-diff">  {
    "name": "webpack-demo",
    "version": "1.0.0",
    "description": "",
<span class="token inserted">+   "private": true,</span>
<span class="token deleted">-   "main": "index.js",</span>
    "scripts": {
      "test": "echo \"Error: no test specified\" &#x26;&#x26; exit 1"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "devDependencies": {
      "webpack": "^4.20.2",
      "webpack-cli": "^3.1.2"
    },
    "dependencies": {}
  }</code></pre>
<p>在此示例中，<code>&#x3C;script></code> 标签之间存在隐式依赖关系。在 <code>index.js</code> 文件执行之前，还需要在页面中先引入 <code>lodash</code>。这是因为 <code>index.js</code> 并未显式声明它需要 <code>lodash</code>，只是假定推测已经存在一个全局变量 <code>_</code>。</p>
<p>使用这种方式去管理 JavaScript 项目会有一些问题：</p>
<ul>
<li>无法直接体现，脚本的执行依赖于外部库。</li>
<li>如果依赖不存在，或者引入顺序错误，应用程序将无法正常运行。</li>
<li>如果依赖被引入但是并没有使用，浏览器将被迫下载无用代码。</li>
</ul>
<p>让我们使用 webpack 来管理这些脚本。</p>
<h2 id="creating-a-bundle">创建一个 bundle <a href="#creating-a-bundle" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>首先，我们稍微调整下目录结构，创建分发代码(<code>/dist</code>)文件夹用于存放分发代码，源代码(<code>/src</code>)文件夹仍存放源代码。源代码是指用于书写和编辑的代码。分发代码是指在构建过程中，经过最小化和优化后产生的输出结果，最终将在浏览器中加载。调整后目录结构如下：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  |- package.json
<span class="token inserted">+ |- /dist</span>
<span class="token inserted">+   |- index.html</span>
<span class="token deleted">- |- index.html</span>
  |- /src
    |- index.js</code></pre>
<p>要在 <code>index.js</code> 中打包 <code>lodash</code> 依赖，我们需要在本地安装 library：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save lodash</code></pre>
<blockquote class="tip">
<p>在安装一个 package，而此 package 要打包到生产环境 bundle 中时，你应该使用 <code>npm install --save</code>。如果你在安装一个用于开发环境的 package 时（例如，linter, 测试库等），你应该使用 <code>npm install --save-dev</code>。更多信息请查看 <a href="https://docs.npmjs.com/cli/install">npm 文档</a>。</p>
</blockquote>
<p>现在，在我们的 script 中 import <code>lodash</code>：</p>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff"><span class="token inserted">+ import _ from 'lodash';</span>
<span class="token inserted">+</span>
  function component() {
    const element = document.createElement('div');

<span class="token deleted">-   // lodash（目前通过一个 script 引入）对于执行这一行是必需的</span>
<span class="token inserted">+   // lodash，现在通过一个 script 引入</span>
    element.innerHTML = _.join(['Hello', 'webpack'], ' ');

    return element;
  }

  document.body.appendChild(component());</code></pre>
<p>现在，我们将会打包所有脚本，我们必须更新 <code>index.html</code> 文件。由于现在是通过 <code>import</code> 引入 lodash，所以要将 lodash <code>&#x3C;script></code> 删除，然后修改另一个 <code>&#x3C;script></code> 标签来加载 bundle，而不是原始的 <code>/src</code> 文件：</p>
<p><strong>dist/index.html</strong></p>
<pre><code class="hljs language-diff">  &#x3C;!doctype html>
  &#x3C;html>
   &#x3C;head>
     &#x3C;title>起步&#x3C;/title>
<span class="token deleted">-    &#x3C;script src="https://unpkg.com/lodash@4.16.6">&#x3C;/script></span>
   &#x3C;/head>
   &#x3C;body>
<span class="token deleted">-    &#x3C;script src="./src/index.js">&#x3C;/script></span>
<span class="token inserted">+    &#x3C;script src="main.js">&#x3C;/script></span>
   &#x3C;/body>
  &#x3C;/html></code></pre>
<p>在这个设置中，<code>index.js</code> 显式要求引入的 <code>lodash</code> 必须存在，然后将它绑定为 <code>_</code>（没有全局作用域污染）。通过声明模块所需的依赖，webpack 能够利用这些信息去构建依赖图，然后使用图生成一个优化过的 bundle，并且会以正确顺序执行。</p>
<p>可以这样说，执行 <code>npx webpack</code>，会将我们的脚本 <code>src/index.js</code> 作为 <a href="/concepts/entry-points">入口起点</a>，也会生成 <code>dist/main.js</code> 作为 <a href="/concepts/output">输出</a>。Node 8.2/npm 5.2.0 以上版本提供的 <code>npx</code> 命令，可以运行在初次安装的 webpack package 中的 webpack 二进制文件（即 <code>./node_modules/.bin/webpack</code>）：</p>
<pre><code class="hljs language-bash">npx webpack

<span class="token punctuation">..</span>.
Built at: 13/06/2018 11:52:07
  Asset      Size  Chunks             Chunk Names
main.js  70.4 KiB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  main
<span class="token punctuation">..</span>.

WARNING <span class="token keyword">in</span> configuration <span class="token punctuation">(</span>配置警告<span class="token punctuation">)</span>
The <span class="token string">'mode'</span> option has not been set, webpack will fallback to <span class="token string">'production'</span> <span class="token keyword">for</span> this value. Set <span class="token string">'mode'</span> option to <span class="token string">'development'</span> or <span class="token string">'production'</span> to <span class="token function">enable</span> defaults <span class="token keyword">for</span> each environment. <span class="token punctuation">(</span><span class="token string">'mode'</span> 选项还未设置，webpack 会将其值回退至 <span class="token string">'production'</span>。将 <span class="token string">'mode'</span> 选项设置为 <span class="token string">'development'</span> 或 <span class="token string">'production'</span>，来启用对应环境的默认优化设置<span class="token punctuation">)</span>
You can also <span class="token keyword">set</span> it to <span class="token string">'none'</span> to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/ <span class="token punctuation">(</span>也可以将其设置为 <span class="token string">'none'</span>，以禁用所有默认行为。了解更多 https://webpack.js.org/configuration/mode/<span class="token punctuation">)</span></code></pre>
<blockquote class="tip">
<p>输出可能会稍有不同，但是只要构建成功，那么你就可以放心继续。并且不要担心警告，稍后我们就会解决。</p>
</blockquote>
<p>在浏览器中打开 <code>index.html</code>，如果一切正常，你应该能看到以下文本：'Hello webpack'。</p>
<blockquote class="warning">
<p>在浏览器中打开 <code>index.html</code>，如果在压缩过后的 JavaScript 中出现语法错误，请设置 <a href="/configuration/mode/#mode-development"><code>development 模式</code></a>，并再次运行 <code>npx webpack</code>。这与最新版本 Node.js (v12.5+) 上运行 <code>npx webpack</code> 有关，和 <a href="https://nodejs.org/en/">LTS 版本</a> 无关。</p>
</blockquote>
<h2 id="modules">模块 <a href="#modules" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p><a href="https://babeljs.io/learn-es2015/">ES2015</a> 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import"><code>import</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export"><code>export</code></a> 语句已经被标准化。虽然大多数浏览器还无法支持它们，但是 webpack 却能够提供开箱即用般的支持。</p>
<p>事实上，webpack 在幕后会将代码“转译”，以便旧版本浏览器可以执行。如果你检查 <code>dist/main.js</code>，你可以看到 webpack 具体如何实现，这是独创精巧的设计！除了 <code>import</code> 和 <code>export</code>，webpack 还能够很好地支持多种其他模块语法，更多信息请查看 <a href="/api/module-methods">模块 API</a>。</p>
<p>注意，webpack 不会更改代码中除 <code>import</code> 和 <code>export</code> 语句以外的部分。如果你在使用其它 <a href="http://es6-features.org/">ES2015 特性</a>，请确保你在 webpack <a href="/concepts/loaders/">loader 系统</a> 中使用了一个像是 <a href="https://babel.docschina.org/">Babel</a> 或 <a href="https://buble.surge.sh/guide/">Bublé</a> 的 <a href="/loaders/#transpiling">transpiler(转译器)</a>。</p>
<h2 id="using-a-configuration">使用一个配置文件 <a href="#using-a-configuration" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>在 webpack v4 中，可以无须任何配置，然而大多数项目会需要很复杂的设置，这就是为什么 webpack 仍然要支持 <a href="/concepts/configuration">配置文件</a>。这比在 terminal(终端) 中手动输入大量命令要高效的多，所以让我们创建一个配置文件：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  |- package.json
<span class="token inserted">+ |- webpack.config.js</span>
  |- /dist
    |- index.html
  |- /src
    |- index.js</code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-javascript"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>
  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    filename<span class="token punctuation">:</span> <span class="token string">'main.js'</span><span class="token punctuation">,</span>
    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>现在，让我们通过新的配置文件再次执行构建：</p>
<pre><code class="hljs language-bash">npx webpack --config webpack.config.js

<span class="token punctuation">..</span>.
  Asset      Size  Chunks             Chunk Names
main.js  70.4 KiB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  main
<span class="token punctuation">..</span>.

WARNING <span class="token keyword">in</span> configuration <span class="token punctuation">(</span>配置警告<span class="token punctuation">)</span>
The <span class="token string">'mode'</span> option has not been set, webpack will fallback to <span class="token string">'production'</span> <span class="token keyword">for</span> this value. Set <span class="token string">'mode'</span> option to <span class="token string">'development'</span> or <span class="token string">'production'</span> to <span class="token function">enable</span> defaults <span class="token keyword">for</span> each environment. <span class="token punctuation">(</span><span class="token string">'mode'</span> 选项还未设置，webpack 会将其值回退至 <span class="token string">'production'</span>。将 <span class="token string">'mode'</span> 选项设置为 <span class="token string">'development'</span> 或 <span class="token string">'production'</span>，来启用对应环境的默认优化设置<span class="token punctuation">)</span>
You can also <span class="token keyword">set</span> it to <span class="token string">'none'</span> to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/ <span class="token punctuation">(</span>也可以将其设置为 <span class="token string">'none'</span>，以禁用所有默认行为。了解更多 https://webpack.js.org/configuration/mode/<span class="token punctuation">)</span></code></pre>
<blockquote class="tip">
<p>如果 <code>webpack.config.js</code> 存在，则 <code>webpack</code> 命令将默认选择使用它。我们在这里使用 <code>--config</code> 选项只是向你表明，可以传递任何名称的配置文件。这对于需要拆分成多个文件的复杂配置是非常有用的。</p>
</blockquote>
<p>比起 CLI 这种简单直接的使用方式，配置文件具有更多的灵活性。我们可以通过配置方式指定 loader 规则(loader rule)、plugin(插件)、resolve 选项，以及许多其他增强功能。更多详细信息请查看 <a href="/configuration">配置文档</a>。</p>
<h2 id="npm-scripts">npm scripts <a href="#npm-scripts" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>考虑到用 CLI 这种方式来运行本地的 webpack 副本并不是特别方便，我们可以设置一个快捷方式。调整 <em>package.json</em> 文件，添加一个 <a href="https://docs.npmjs.com/misc/scripts">npm script</a>：</p>
<p><strong>package.json</strong></p>
<pre><code class="hljs language-diff">  {
    "name": "webpack-demo",
    "version": "1.0.0",
    "description": "",
    "scripts": {
<span class="token deleted">-      "test": "echo \"Error: no test specified\" &#x26;&#x26; exit 1"</span>
<span class="token inserted">+      "test": "echo \"Error: no test specified\" &#x26;&#x26; exit 1",</span>
<span class="token inserted">+      "build": "webpack"</span>
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "devDependencies": {
      "webpack": "^4.20.2",
      "webpack-cli": "^3.1.2"
    },
    "dependencies": {
      "lodash": "^4.17.5"
    }
  }</code></pre>
<p>现在，可以使用 <code>npm run build</code> 命令，来替代我们之前使用的 <code>npx</code> 命令。注意，使用 npm <code>scripts</code>，我们可以像使用 <code>npx</code> 那样通过模块名引用本地安装的 npm packages。这是大多数基于 npm 的项目遵循的标准，因为它允许所有贡献者使用同一组通用脚本（如果必要，每个命令都需要添加 <code>--config</code> flag）。</p>
<p>现在运行以下命令，然后看看你的脚本别名是否正常运行：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> run build

<span class="token punctuation">..</span>.
  Asset      Size  Chunks             Chunk Names
main.js  70.4 KiB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  main
<span class="token punctuation">..</span>.

WARNING <span class="token keyword">in</span> configuration <span class="token punctuation">(</span>配置警告<span class="token punctuation">)</span>
The <span class="token string">'mode'</span> option has not been set, webpack will fallback to <span class="token string">'production'</span> <span class="token keyword">for</span> this value. Set <span class="token string">'mode'</span> option to <span class="token string">'development'</span> or <span class="token string">'production'</span> to <span class="token function">enable</span> defaults <span class="token keyword">for</span> each environment. <span class="token punctuation">(</span><span class="token string">'mode'</span> 选项还未设置，webpack 会将其值回退至 <span class="token string">'production'</span>。将 <span class="token string">'mode'</span> 选项设置为 <span class="token string">'development'</span> 或 <span class="token string">'production'</span>，来启用对应环境的默认优化设置<span class="token punctuation">)</span>
You can also <span class="token keyword">set</span> it to <span class="token string">'none'</span> to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/ <span class="token punctuation">(</span>也可以将其设置为 <span class="token string">'none'</span>，以禁用所有默认行为。了解更多 https://webpack.js.org/configuration/mode/<span class="token punctuation">)</span></code></pre>
<blockquote class="tip">
<p>通过在 <code>npm run build</code> 命令和你的参数之间添加两个中横线，可以将自定义参数传递给 webpack，例如：<code>npm run build -- --colors</code>。</p>
</blockquote>
<h2 id="conclusion">结论 <a href="#conclusion" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>现在，你已经有了一个基础构建配置，你应该移至下一章节 <a href="/guides/asset-management"><code>资源管理</code></a> 指南，以了解如何通过 webpack 来管理资源，例如 images、fonts。此刻你的项目看起来应该如下：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">webpack-demo
|- package.json
|- webpack.config.js
|- /dist
  |- main.js
  |- index.html
|- /src
  |- index.js
|- /node_modules</code></pre>
<blockquote class="tip">
<p>如果你使用的是 npm 5，你可能还会在目录中看到一个 <code>package-lock.json</code> 文件。</p>
</blockquote>
<p>如果想要了解 webpack 设计思想，你应该看下 <a href="/concepts">基本概念</a> 和 <a href="/configuration">配置</a> 页面。此外，<a href="/api">API</a> 章节可以深入了解 webpack 提供的各种接口。</p>
<h1 id="管理资源">管理资源<a href="#%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p>如果你是从开始一直在沿用指南的示例，现在会有一个小项目，显示 "Hello webpack"。现在我们尝试混合一些其他资源，比如 images，看看 webpack 如何处理。</p>
<p>在 webpack 出现之前，前端开发人员会使用 grunt 和 gulp 等工具来处理资源，并将它们从 <code>/src</code> 文件夹移动到 <code>/dist</code> 或 <code>/build</code> 目录中。JavaScript 模块也遵循同样方式，但是，像 webpack 这样的工具，将<strong>动态打包</strong>所有依赖（创建所谓的 <a href="/concepts/dependency-graph">依赖图(dependency graph)</a>）。这是极好的创举，因为现在每个模块都可以<em>明确表述它自身的依赖</em>，可以避免打包未使用的模块。</p>
<p>webpack 最出色的功能之一就是，除了引入 JavaScript，还可以通过 loader <em>引入任何其他类型的文件</em>。也就是说，以上列出的那些 JavaScript 的优点（例如显式依赖），同样可以用来构建 web 站点或 web 应用程序中的所有非 JavaScript 内容。让我们从 CSS 开始起步，或许你可能已经熟悉了下面这些设置。</p>
<h2 id="setup">设置 <a href="#setup" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>在开始之前，让我们对项目做一个小的修改：</p>
<p><strong>dist/index.html</strong></p>
<pre><code class="hljs language-diff">  &#x3C;!doctype html>
  &#x3C;html>
    &#x3C;head>
<span class="token deleted">-    &#x3C;title>起步&#x3C;/title></span>
<span class="token inserted">+    &#x3C;title>管理资源&#x3C;/title></span>
    &#x3C;/head>
    &#x3C;body>
<span class="token deleted">-     &#x3C;script src="main.js">&#x3C;/script></span>
<span class="token inserted">+     &#x3C;script src="bundle.js">&#x3C;/script></span>
    &#x3C;/body>
  &#x3C;/html></code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');

  module.exports = {
    entry: './src/index.js',
    output: {
<span class="token deleted">-     filename: 'main.js',</span>
<span class="token inserted">+     filename: 'bundle.js',</span>
      path: path.resolve(__dirname, 'dist'),
    },
  };</code></pre>
<h2 id="loading-css">加载 CSS <a href="#loading-css" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>为了在 JavaScript 模块中 <code>import</code> 一个 CSS 文件，你需要安装 <a href="/loaders/style-loader">style-loader</a> 和 <a href="/loaders/css-loader">css-loader</a>，并在 <a href="/configuration/module"><code>module</code> 配置</a> 中添加这些 loader：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev style-loader css-loader</code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');

  module.exports = {
    entry: './src/index.js',
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
<span class="token inserted">+   module: {</span>
<span class="token inserted">+     rules: [</span>
<span class="token inserted">+       {</span>
<span class="token inserted">+         test: /\.css$/,</span>
<span class="token inserted">+         use: [</span>
<span class="token inserted">+           'style-loader',</span>
<span class="token inserted">+           'css-loader',</span>
<span class="token inserted">+         ],</span>
<span class="token inserted">+       },</span>
<span class="token inserted">+     ],</span>
<span class="token inserted">+   },</span>
  };</code></pre>
<blockquote class="tip">
<p>webpack 根据正则表达式，来确定应该查找哪些文件，并将其提供给指定的 loader。在这个示例中，所有以 <code>.css</code> 结尾的文件，都将被提供给 <code>style-loader</code> 和 <code>css-loader</code>。</p>
</blockquote>
<p>这使你可以在依赖于此样式的 js 文件中 <code>import './style.css'</code>。现在，在此模块执行过程中，含有 CSS 字符串的 <code>&#x3C;style></code> 标签，将被插入到 html 文件的 <code>&#x3C;head></code> 中。</p>
<p>我们尝试一下，通过在项目中添加一个新的 <code>style.css</code> 文件，并将其 import 到我们的 <code>index.js</code> 中：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  |- package.json
  |- webpack.config.js
  |- /dist
    |- bundle.js
    |- index.html
  |- /src
<span class="token inserted">+   |- style.css</span>
    |- index.js
  |- /node_modules</code></pre>
<p><strong>src/style.css</strong></p>
<pre><code class="hljs language-css"><span class="token selector">.hello</span> <span class="token punctuation">{</span>
  <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff">  import _ from 'lodash';
<span class="token inserted">+ import './style.css';</span>

  function component() {
    const element = document.createElement('div');

    // lodash 是由当前 script 脚本 import 导入进来的
    element.innerHTML = _.join(['Hello', 'webpack'], ' ');
<span class="token inserted">+   element.classList.add('hello');</span>

    return element;
  }

  document.body.appendChild(component());</code></pre>
<p>现在运行 build 命令：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> run build

<span class="token punctuation">..</span>.
    Asset      Size  Chunks             Chunk Names
bundle.js  76.4 KiB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  main
Entrypoint main <span class="token operator">=</span> bundle.js
<span class="token punctuation">..</span>.</code></pre>
<p>再次在浏览器中打开 <code>index.html</code>，你应该看到 <code>Hello webpack</code> 现在的样式是红色。要查看 webpack 做了什么，请检查页面（不要查看页面源代码，它不会显示结果，因为 <code>&#x3C;style></code> 标签是由 JavaScript 动态创建的），并查看页面的 head 标签。它应该包含 style 块元素，也就是我们在 <code>index.js</code> 中 import 的 css 文件中的样式。</p>
<p>注意，在多数情况下，你也可以进行 <a href="/plugins/mini-css-extract-plugin/#minimizing-for-production">压缩 CSS</a>，以便在生产环境中节省加载时间。最重要的是，现有的 loader 可以支持任何你可以想到的 CSS 风格 - <a href="/loaders/postcss-loader">postcss</a>, <a href="/loaders/sass-loader">sass</a> 和 <a href="/loaders/less-loader">less</a> 等。</p>
<h2 id="loading-images">加载 images 图像 <a href="#loading-images" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>假想，现在我们正在下载 CSS，但是像 background 和 icon 这样的图像，要如何处理呢？使用 <a href="/loaders/file-loader">file-loader</a>，我们可以轻松地将这些内容混合到 CSS 中：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev file-loader</code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');

  module.exports = {
    entry: './src/index.js',
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
    module: {
      rules: [
        {
          test: /\.css$/,
          use: [
            'style-loader',
            'css-loader'
          ],
        },
<span class="token inserted">+       {</span>
<span class="token inserted">+         test: /\.(png|svg|jpg|gif)$/,</span>
<span class="token inserted">+         use: [</span>
<span class="token inserted">+           'file-loader',</span>
<span class="token inserted">+         ],</span>
<span class="token inserted">+       },</span>
      ],
    },
  };</code></pre>
<p>现在，在 <code>import MyImage from './my-image.png'</code> 时，此图像将被处理并添加到 <code>output</code> 目录，<em>并且</em> <code>MyImage</code> 变量将包含该图像在处理后的最终 url。在使用 <a href="/loaders/css-loader">css-loader</a> 时，如前所示，会使用类似过程处理你的 CSS 中的 <code>url('./my-image.png')</code>。loader 会识别这是一个本地文件，并将 <code>'./my-image.png'</code> 路径，替换为 <code>output</code> 目录中图像的最终路径。而 <a href="/loaders/html-loader">html-loader</a> 以相同的方式处理 <code>&#x3C;img src="./my-image.png" /></code>。</p>
<p>我们向项目添加一个图像，然后看它是如何工作的，你可以使用任何你喜欢的图像：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  |- package.json
  |- webpack.config.js
  |- /dist
    |- bundle.js
    |- index.html
  |- /src
<span class="token inserted">+   |- icon.png</span>
    |- style.css
    |- index.js
  |- /node_modules</code></pre>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff">  import _ from 'lodash';
  import './style.css';
<span class="token inserted">+ import Icon from './icon.png';</span>

  function component() {
    const element = document.createElement('div');

    // lodash，现在由此脚本导入
    element.innerHTML = _.join(['Hello', 'webpack'], ' ');
    element.classList.add('hello');

<span class="token inserted">+   // 将图像添加到我们已经存在的 div 中。</span>
<span class="token inserted">+   const myIcon = new Image();</span>
<span class="token inserted">+   myIcon.src = Icon;</span>
<span class="token inserted">+</span>
<span class="token inserted">+   element.appendChild(myIcon);</span>

    return element;
  }

  document.body.appendChild(component());</code></pre>
<p><strong>src/style.css</strong></p>
<pre><code class="hljs language-diff">  .hello {
    color: red;
<span class="token inserted">+   background: url('./icon.png');</span>
  }</code></pre>
<p>重新构建并再次打开 index.html 文件：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> run build

<span class="token punctuation">..</span>.
                               Asset      Size  Chunks                    Chunk Names
da4574bb234ddc4bb47cbe1ca4b20303.png  3.01 MiB          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>
                           bundle.js  76.7 KiB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         main
Entrypoint main <span class="token operator">=</span> bundle.js
<span class="token punctuation">..</span>.</code></pre>
<p>如果一切顺利，你现在应该看到你的 icon 图标成为了重复的背景图，以及 <code>Hello webpack</code> 文本旁边的 <code>img</code> 元素。如果检查此元素，你将看到实际的文件名已更改为 <code>5c999da72346a995e7e2718865d019c8.png</code>。这意味着 webpack 在 <code>src</code> 文件夹中找到我们的文件，并对其进行了处理！</p>
<blockquote class="tip">
<p>合乎逻辑下一步是，压缩和优化你的图像。查看 <a href="https://github.com/tcoopman/image-webpack-loader">image-webpack-loader</a> 和 <a href="/loaders/url-loader">url-loader</a>，以了解更多关于如何增强加载处理图像功能。</p>
</blockquote>
<h2 id="loading-fonts">加载 fonts 字体 <a href="#loading-fonts" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>那么，像字体这样的其他资源如何处理呢？file-loader 和 url-loader 可以接收并加载任何文件，然后将其输出到构建目录。这就是说，我们可以将它们用于任何类型的文件，也包括字体。让我们更新 <code>webpack.config.js</code> 来处理字体文件：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');

  module.exports = {
    entry: './src/index.js',
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
    module: {
      rules: [
        {
          test: /\.css$/,
          use: [
            'style-loader',
            'css-loader'
          ],
        },
        {
          test: /\.(png|svg|jpg|gif)$/,
          use: [
            'file-loader',
          ],
        },
<span class="token inserted">+       {</span>
<span class="token inserted">+         test: /\.(woff|woff2|eot|ttf|otf)$/,</span>
<span class="token inserted">+         use: [</span>
<span class="token inserted">+           'file-loader',</span>
<span class="token inserted">+         ],</span>
<span class="token inserted">+       },</span>
      ],
    },
  };</code></pre>
<p>在项目中添加一些字体文件：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  |- package.json
  |- webpack.config.js
  |- /dist
    |- bundle.js
    |- index.html
  |- /src
<span class="token inserted">+   |- my-font.woff</span>
<span class="token inserted">+   |- my-font.woff2</span>
    |- icon.png
    |- style.css
    |- index.js
  |- /node_modules</code></pre>
<p>配置好 loader 并将字体文件放在合适的位置后，你可以通过一个 <code>@font-face</code> 声明将其混合。本地的 <code>url(...)</code> 指令会被 webpack 获取处理，就像它处理图片一样：</p>
<p><strong>src/style.css</strong></p>
<pre><code class="hljs language-diff"><span class="token inserted">+ @font-face {</span>
<span class="token inserted">+   font-family: 'MyFont';</span>
<span class="token inserted">+   src:  url('./my-font.woff2') format('woff2'),</span>
<span class="token inserted">+         url('./my-font.woff') format('woff');</span>
<span class="token inserted">+   font-weight: 600;</span>
<span class="token inserted">+   font-style: normal;</span>
<span class="token inserted">+ }</span>

  .hello {
    color: red;
<span class="token inserted">+   font-family: 'MyFont';</span>
    background: url('./icon.png');
  }</code></pre>
<p>现在，让我们重新构建，然后看下 webpack 是否处理了我们的字体：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> run build

<span class="token punctuation">..</span>.
                                 Asset      Size  Chunks                    Chunk Names
5439466351d432b73fdb518c6ae9654a.woff2  19.5 KiB          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
 387c65cc923ad19790469cfb5b7cb583.woff  23.4 KiB          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
  da4574bb234ddc4bb47cbe1ca4b20303.png  3.01 MiB          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>
                             bundle.js    77 KiB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         main
Entrypoint main <span class="token operator">=</span> bundle.js
<span class="token punctuation">..</span>.</code></pre>
<p>重新打开 <code>index.html</code> 看看我们的 <code>Hello webpack</code> 文本显示是否换上了新的字体。如果一切顺利，你应该能看到变化。</p>
<h2 id="loading-data">加载数据 <a href="#loading-data" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>此外，可以加载的有用资源还有数据，如 JSON 文件，CSV、TSV 和 XML。类似于 NodeJS，JSON 支持实际上是内置的，也就是说 <code>import Data from './data.json'</code> 默认将正常运行。要导入 CSV、TSV 和 XML，你可以使用 <a href="https://github.com/theplatapi/csv-loader">csv-loader</a> 和 <a href="https://github.com/gisikw/xml-loader">xml-loader</a>。让我们处理加载这三类文件：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev csv-loader xml-loader</code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');

  module.exports = {
    entry: './src/index.js',
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
    module: {
      rules: [
        {
          test: /\.css$/,
          use: [
            'style-loader',
            'css-loader'
          ],
        },
        {
          test: /\.(png|svg|jpg|gif)$/,
          use: [
            'file-loader',
          ],
        },
        {
          test: /\.(woff|woff2|eot|ttf|otf)$/,
          use: [
            'file-loader',
          ],
        },
<span class="token inserted">+       {</span>
<span class="token inserted">+         test: /\.(csv|tsv)$/,</span>
<span class="token inserted">+         use: [</span>
<span class="token inserted">+           'csv-loader',</span>
<span class="token inserted">+         ],</span>
<span class="token inserted">+       },</span>
<span class="token inserted">+       {</span>
<span class="token inserted">+         test: /\.xml$/,</span>
<span class="token inserted">+         use: [</span>
<span class="token inserted">+           'xml-loader',</span>
<span class="token inserted">+         ],</span>
<span class="token inserted">+       },</span>
      ],
    },
  };</code></pre>
<p>在项目中添加一些数据文件：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  |- package.json
  |- webpack.config.js
  |- /dist
    |- bundle.js
    |- index.html
  |- /src
<span class="token inserted">+   |- data.xml</span>
    |- my-font.woff
    |- my-font.woff2
    |- icon.png
    |- style.css
    |- index.js
  |- /node_modules</code></pre>
<p><strong>src/data.xml</strong></p>
<pre><code class="hljs language-xml"><span class="token prolog">&#x3C;?xml version="1.0" encoding="UTF-8"?></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>note</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>to</span><span class="token punctuation">></span></span>Mary<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>to</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>from</span><span class="token punctuation">></span></span>John<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>from</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>heading</span><span class="token punctuation">></span></span>Reminder<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>heading</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>body</span><span class="token punctuation">></span></span>Call Cindy on Tuesday<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>note</span><span class="token punctuation">></span></span></code></pre>
<p>现在，你可以 <code>import</code> 这四种类型的数据(JSON, CSV, TSV, XML)中的任何一种，所导入的 <code>Data</code> 变量，将包含可直接使用的已解析 JSON：</p>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff">  import _ from 'lodash';
  import './style.css';
  import Icon from './icon.png';
<span class="token inserted">+ import Data from './data.xml';</span>

  function component() {
    const element = document.createElement('div');

    // lodash，现在通过 script 标签导入
    element.innerHTML = _.join(['Hello', 'webpack'], ' ');
    element.classList.add('hello');

    // 将图像添加到我们已经存在的 div 中。
    const myIcon = new Image();
    myIcon.src = Icon;

    element.appendChild(myIcon);

<span class="token inserted">+   console.log(Data);</span>

    return element;
  }

  document.body.appendChild(component());</code></pre>
<p>重新执行 <code>npm run build</code> 命令，然后打开 <code>index.html</code>。查看开发者工具中的控制台，你应该能够看到导入的数据会被打印出来！</p>
<blockquote class="tip">
<p>在使用 <a href="https://github.com/d3">d3</a> 等工具实现某些数据可视化时，这个功能极其有用。可以不用在运行时再去发送一个 ajax 请求获取和解析数据，而是在构建过程中将其提前加载到模块中，以便浏览器加载模块后，直接就可以访问解析过的数据。</p>
</blockquote>
<blockquote class="warning">
<p>只有在使用 JSON 模块默认导出时会没有警告。</p>
</blockquote>
<pre><code class="hljs language-javascript"><span class="token comment">// 没有警告</span>
<span class="token keyword">import</span> data <span class="token keyword">from</span> <span class="token string">'./data.json'</span><span class="token punctuation">;</span>

<span class="token comment">// 显示警告，规范不允许这样做。</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./data.json'</span><span class="token punctuation">;</span></code></pre>
<h2 id="global-assets">全局资源 <a href="#global-assets" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>上述所有内容中最出色之处在于，以这种方式加载资源，你可以以更直观的方式将模块和资源组合在一起。无需依赖于含有全部资源的 <code>/assets</code> 目录，而是将资源与代码组合在一起使用。例如，类似这样的结构会非常有用：</p>
<pre><code class="hljs language-diff"><span class="token deleted">- |- /assets</span>
<span class="token inserted">+ |– /components</span>
<span class="token inserted">+ |  |– /my-component</span>
<span class="token inserted">+ |  |  |– index.jsx</span>
<span class="token inserted">+ |  |  |– index.css</span>
<span class="token inserted">+ |  |  |– icon.svg</span>
<span class="token inserted">+ |  |  |– img.png</span></code></pre>
<p>这种配置方式会使你的代码更具备可移植性，因为现有的集中放置的方式会让所有资源紧密耦合起来。假如你想在另一个项目中使用  <code>/my-component</code>，只需将其复制或移动到 <code>/components</code> 目录下。只要你已经安装过全部<em>外部依赖</em>，并且<em>已经在配置中定义过相同的 loader</em>，那么项目应该能够良好运行。</p>
<p>但是，假如你只能被局限在旧有开发方式，或者你有一些在多个组件（视图、模板、模块等）之间共享的资源。你仍然可以将这些资源存储在一个基本目录(base directory)中，甚至配合使用 <a href="/configuration/resolve/#resolvealias">alias</a> 来使它们更方便 <code>import 导入</code>。</p>
<h2 id="wrapping-up">回退处理 <a href="#wrapping-up" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>对于下篇指南，我们无需使用本指南中所有用到的资源，因此我们会进行一些清理工作，以便为下篇指南 <a href="/guides/output-management/">管理输出</a> 做好准备：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  |- package.json
  |- webpack.config.js
  |- /dist
    |- bundle.js
    |- index.html
  |- /src
<span class="token deleted">-   |- data.xml</span>
<span class="token deleted">-   |- my-font.woff</span>
<span class="token deleted">-   |- my-font.woff2</span>
<span class="token deleted">-   |- icon.png</span>
<span class="token deleted">-   |- style.css</span>
    |- index.js
  |- /node_modules</code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');

  module.exports = {
    entry: './src/index.js',
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
<span class="token deleted">-   module: {</span>
<span class="token deleted">-     rules: [</span>
<span class="token deleted">-       {</span>
<span class="token deleted">-         test: /\.css$/,</span>
<span class="token deleted">-         use: [</span>
<span class="token deleted">-           'style-loader',</span>
<span class="token deleted">-           'css-loader',</span>
<span class="token deleted">-         ],</span>
<span class="token deleted">-       },</span>
<span class="token deleted">-       {</span>
<span class="token deleted">-         test: /\.(png|svg|jpg|gif)$/,</span>
<span class="token deleted">-         use: [</span>
<span class="token deleted">-           'file-loader',</span>
<span class="token deleted">-         ],</span>
<span class="token deleted">-       },</span>
<span class="token deleted">-       {</span>
<span class="token deleted">-         test: /\.(woff|woff2|eot|ttf|otf)$/,</span>
<span class="token deleted">-         use: [</span>
<span class="token deleted">-           'file-loader',</span>
<span class="token deleted">-         ],</span>
<span class="token deleted">-       },</span>
<span class="token deleted">-       {</span>
<span class="token deleted">-         test: /\.(csv|tsv)$/,</span>
<span class="token deleted">-         use: [</span>
<span class="token deleted">-           'csv-loader',</span>
<span class="token deleted">-         ],</span>
<span class="token deleted">-       },</span>
<span class="token deleted">-       {</span>
<span class="token deleted">-         test: /\.xml$/,</span>
<span class="token deleted">-         use: [</span>
<span class="token deleted">-           'xml-loader',</span>
<span class="token deleted">-         ],</span>
<span class="token deleted">-       },</span>
<span class="token deleted">-     ],</span>
<span class="token deleted">-   },</span>
  };</code></pre>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff">  import _ from 'lodash';
<span class="token deleted">- import './style.css';</span>
<span class="token deleted">- import Icon from './icon.png';</span>
<span class="token deleted">- import Data from './data.xml';</span>
<span class="token deleted">-</span>
  function component() {
    const element = document.createElement('div');
<span class="token deleted">-</span>
<span class="token deleted">-   // lodash，现在通过 script 标签导入</span>
    element.innerHTML = _.join(['Hello', 'webpack'], ' ');
<span class="token deleted">-   element.classList.add('hello');</span>
<span class="token deleted">-</span>
<span class="token deleted">-   // 将图像添加到我们已经存在的 div 中。</span>
<span class="token deleted">-   const myIcon = new Image();</span>
<span class="token deleted">-   myIcon.src = Icon;</span>
<span class="token deleted">-</span>
<span class="token deleted">-   element.appendChild(myIcon);</span>
<span class="token deleted">-</span>
<span class="token deleted">-   console.log(Data);</span>

    return element;
  }

  document.body.appendChild(component());</code></pre>
<h2 id="next-guide">下篇指南 <a href="#next-guide" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>我们继续移步到 <a href="/guides/output-management/">管理输出</a></p>
<h2 id="further-reading">延伸阅读 <a href="#further-reading" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<ul>
<li><a href="https://survivejs.com/webpack/loading/fonts/">加载字体</a> on SurviveJS</li>
</ul>
<h1 id="管理输出">管理输出<a href="#%E7%AE%A1%E7%90%86%E8%BE%93%E5%87%BA" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<blockquote class="tip">
<p>本指南继续沿用 <a href="/guides/asset-management"><code>管理资源</code></a> 指南中的代码示例。</p>
</blockquote>
<p>到目前为止，我们都是在 <code>index.html</code> 文件中手动引入所有资源，然而随着应用程序增长，并且一旦开始 <a href="/guides/caching">在文件名中使用 hash</a> 并输出 <a href="/guides/code-splitting">多个 bundle</a>，如果继续手动管理 <code>index.html</code> 文件，就会变得困难起来。然而，通过一些插件可以使这个过程更容易管控。</p>
<h2 id="preparation">预先准备 <a href="#preparation" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>首先，调整一下我们的项目：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  |- package.json
  |- webpack.config.js
  |- /dist
  |- /src
    |- index.js
<span class="token inserted">+   |- print.js</span>
  |- /node_modules</code></pre>
<p>我们在 <code>src/print.js</code> 文件中添加一些逻辑：</p>
<p><strong>src/print.js</strong></p>
<pre><code class="hljs language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">printMe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I get called from print.js!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>并且在 <code>src/index.js</code> 文件中使用这个函数：</p>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff">  import _ from 'lodash';
<span class="token inserted">+ import printMe from './print.js';</span>

  function component() {
    const element = document.createElement('div');
<span class="token inserted">+   const btn = document.createElement('button');</span>

    element.innerHTML = _.join(['Hello', 'webpack'], ' ');

<span class="token inserted">+   btn.innerHTML = '点击这里，然后查看 console！';</span>
<span class="token inserted">+   btn.onclick = printMe;</span>
<span class="token inserted">+</span>
<span class="token inserted">+   element.appendChild(btn);</span>

    return element;
  }

  document.body.appendChild(component());</code></pre>
<p>还要更新 <code>dist/index.html</code> 文件，来为 webpack 分离入口做好准备：</p>
<p><strong>dist/index.html</strong></p>
<pre><code class="hljs language-diff">  &#x3C;!doctype html>
  &#x3C;html>
    &#x3C;head>
<span class="token deleted">-     &#x3C;title>管理资源&#x3C;/title></span>
<span class="token inserted">+     &#x3C;title>管理输出&#x3C;/title></span>
<span class="token inserted">+     &#x3C;script src="./print.bundle.js">&#x3C;/script></span>
    &#x3C;/head>
    &#x3C;body>
<span class="token deleted">-     &#x3C;script src="./bundle.js">&#x3C;/script></span>
<span class="token inserted">+     &#x3C;script src="./app.bundle.js">&#x3C;/script></span>
    &#x3C;/body>
  &#x3C;/html></code></pre>
<p>现在调整配置。我们将在 entry 添加 <code>src/print.js</code> 作为新的入口起点（<code>print</code>），然后修改 output，以便根据入口起点定义的名称，动态地产生 bundle 名称：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');

  module.exports = {
<span class="token deleted">-   entry: './src/index.js',</span>
<span class="token inserted">+   entry: {</span>
<span class="token inserted">+     app: './src/index.js',</span>
<span class="token inserted">+     print: './src/print.js',</span>
<span class="token inserted">+   },</span>
    output: {
<span class="token deleted">-     filename: 'bundle.js',</span>
<span class="token inserted">+     filename: '[name].bundle.js',</span>
      path: path.resolve(__dirname, 'dist'),
    },
  };</code></pre>
<p>执行 <code>npm run build</code>，然后看到生成如下：</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
          Asset     Size  Chunks                    Chunk Names
  app.bundle.js   545 kB    0, 1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  app
print.bundle.js  2.74 kB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         print
<span class="token punctuation">..</span>.</code></pre>
<p>我们可以看到，webpack 生成 <code>print.bundle.js</code> 和 <code>app.bundle.js</code> 文件，这也和我们在 <code>index.html</code> 文件中指定的文件名称相对应。如果你在浏览器中打开 <code>index.html</code>，就可以看到在点击按钮时会发生什么。</p>
<p>但是，如果我们更改了我们的一个入口起点的名称，甚至添加了一个新的入口，会发生什么？会在构建时重新命名生成的 bundle，但是我们的 <code>index.html</code> 文件仍然引用旧的名称。让我们用 <a href="/plugins/html-webpack-plugin"><code>HtmlWebpackPlugin</code></a> 来解决这个问题。</p>
<h2 id="setting-up-htmlwebpackplugin">设置 HtmlWebpackPlugin <a href="#setting-up-htmlwebpackplugin" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>首先安装插件，并且调整 <code>webpack.config.js</code> 文件：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev html-webpack-plugin</code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
<span class="token inserted">+ const HtmlWebpackPlugin = require('html-webpack-plugin');</span>

  module.exports = {
    entry: {
      app: './src/index.js',
      print: './src/print.js',
    },
<span class="token inserted">+   plugins: [</span>
<span class="token inserted">+     new HtmlWebpackPlugin({</span>
<span class="token inserted">+       title: '管理输出',</span>
<span class="token inserted">+     }),</span>
<span class="token inserted">+   ],</span>
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
  };</code></pre>
<p>在我们构建之前，你应该了解，虽然在 <code>dist/</code> 文件夹我们已经有了 <code>index.html</code> 这个文件，然而 <code>HtmlWebpackPlugin</code> 还是会默认生成它自己的 <code>index.html</code> 文件。也就是说，它会用新生成的 <code>index.html</code> 文件，替换我们的原有文件。我们看下执行 <code>npm run build</code> 后会发生什么：</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
           Asset       Size  Chunks                    Chunk Names
 print.bundle.js     544 kB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  print
   app.bundle.js    2.81 kB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         app
      index.html  249 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.</code></pre>
<p>如果在代码编辑器中打开 <code>index.html</code>，你会看到 <code>HtmlWebpackPlugin</code> 创建了一个全新的文件，所有的 bundle 会自动添加到 html 中。</p>
<p>如果你想要了解 <code>HtmlWebpackPlugin</code> 插件提供的全部的功能和选项，你就应该阅读 <a href="https://github.com/jantimon/html-webpack-plugin"><code>HtmlWebpackPlugin</code></a> 仓库中的源码。</p>
<p>还可以看下 <a href="https://github.com/jaketrent/html-webpack-template"><code>html-webpack-template</code></a>，除了提供默认模板之外，还提供了一些额外的功能。</p>
<h2 id="cleaning-up-the-dist-folder">清理 <code>/dist</code> 文件夹 <a href="#cleaning-up-the-dist-folder" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>你可能已经注意到，由于遗留了之前的指南和代码示例，我们的 <code>/dist</code> 文件夹显得相当杂乱。webpack 将生成文件并放置在 <code>/dist</code> 文件夹中，但是它不会追踪哪些文件是实际在项目中用到的。</p>
<p>通常比较推荐的做法是，在每次构建前清理 <code>/dist</code> 文件夹，这样只会生成用到的文件。让我们实现这个需求。</p>
<p><a href="https://www.npmjs.com/package/clean-webpack-plugin"><code>clean-webpack-plugin</code></a> 是一个流行的清理插件，安装和配置它。</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev clean-webpack-plugin</code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const HtmlWebpackPlugin = require('html-webpack-plugin');
<span class="token inserted">+ const { CleanWebpackPlugin } = require('clean-webpack-plugin');</span>

  module.exports = {
    entry: {
      app: './src/index.js',
      print: './src/print.js',
    },
    plugins: [
<span class="token inserted">+     new CleanWebpackPlugin(),</span>
      new HtmlWebpackPlugin({
        title: '管理输出',
      }),
    ],
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
  };</code></pre>
<p>现在，执行 <code>npm run build</code>，检查 <code>/dist</code> 文件夹。如果一切顺利，现在只会看到构建后生成的文件，而没有旧文件！</p>
<h2 id="the-manifest">manifest <a href="#the-manifest" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>你可能会很感兴趣，webpack 和 webpack 插件似乎“知道”应该生成哪些文件。答案是，webpack 通过 manifest，可以追踪所有模块到输出 bundle 之间的映射。如果你想要知道如何以其他方式来控制 webpack <a href="/configuration/output"><code>输出</code></a>，了解 manifest 是个好的开始。</p>
<p>通过 <a href="https://github.com/danethurber/webpack-manifest-plugin"><code>WebpackManifestPlugin</code></a> 插件，可以将 manifest 数据提取为一个容易使用的 json 文件。</p>
<p>我们不会在此展示一个如何在项目中使用此插件的完整示例，你可以在 <a href="/concepts/manifest">manifest</a> 概念页面深入阅读，以及在 <a href="/guides/caching">缓存</a> 指南中，了解它与长效缓存有何关系。</p>
<h2 id="conclusion">结论 <a href="#conclusion" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>现在，你已经了解如何向 HTML 动态添加 bundle，让我们深入 <a href="/guides/development">开发环境</a> 指南。或者如果你想要深入更多相关高级话题，我们推荐你前往 <a href="/guides/code-splitting">代码分离</a> 指南。</p>
<h1 id="开发环境">开发环境<a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<blockquote class="tip">
<p>本指南继续沿用 <a href="/guides/output-management">管理输出</a> 指南中的代码示例。</p>
</blockquote>
<p>如果你一直跟随之前的指南，应该对一些 webpack 基础知识有着很扎实的理解。在我们继续之前，先来看看如何设置一个开发环境，使我们的开发体验变得更轻松一些。</p>
<blockquote class="warning">
<p>本指南中的工具<strong>仅用于开发环境</strong>，请<strong>不要</strong>在生产环境中使用它们！</p>
</blockquote>
<p>在开始前，我们先将 <a href="/configuration/mode/#mode-development"><code>mode</code> 设置为 <code>'development'</code></a>。</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const HtmlWebpackPlugin = require('html-webpack-plugin');
  const { CleanWebpackPlugin } = require('clean-webpack-plugin');

  module.exports = {
<span class="token inserted">+   mode: 'development',</span>
    entry: {
      app: './src/index.js',
      print: './src/print.js',
    },
    plugins: [
      // 对于 CleanWebpackPlugin 的 v2 versions 以下版本，使用 new CleanWebpackPlugin(['dist/*'])
      new CleanWebpackPlugin(),
      new HtmlWebpackPlugin({
        title: '开发环境',
      }),
    ],
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
  };</code></pre>
<h2 id="using-source-maps">使用 source map <a href="#using-source-maps" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>当 webpack 打包源代码时，可能会很难追踪到 error(错误) 和 warning(警告) 在源代码中的原始位置。例如，如果将三个源文件（<code>a.js</code>, <code>b.js</code> 和 <code>c.js</code>）打包到一个 bundle（<code>bundle.js</code>）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会直接指向到 <code>bundle.js</code>。你可能需要准确地知道错误来自于哪个源文件，所以这种提示这通常不会提供太多帮助。</p>
<p>为了更容易地追踪 error 和 warning，JavaScript 提供了 <a href="http://blog.teamtreehouse.com/introduction-source-maps">source maps</a> 功能，可以将编译后的代码映射回原始源代码。如果一个错误来自于 <code>b.js</code>，source map 就会明确的告诉你。</p>
<p>source map 有许多 <a href="/configuration/devtool">可用选项</a>，请务必仔细阅读它们，以便可以根据需要进行配置。</p>
<p>对于本指南，我们将使用 <code>inline-source-map</code> 选项，这有助于解释说明示例意图（此配置仅用于示例，不要用于生产环境）：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const HtmlWebpackPlugin = require('html-webpack-plugin');
  const { CleanWebpackPlugin } = require('clean-webpack-plugin');

  module.exports = {
    mode: 'development',
    entry: {
      app: './src/index.js',
      print: './src/print.js',
    },
<span class="token inserted">+   devtool: 'inline-source-map',</span>
    plugins: [
      new CleanWebpackPlugin(),
      new HtmlWebpackPlugin({
        title: 'Development',
      }),
    ],
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
  };</code></pre>
<p>现在，让我们来做一些调试，在 <code>print.js</code> 文件中生成一个错误：</p>
<p><strong>src/print.js</strong></p>
<pre><code class="hljs language-diff">  export default function printMe() {
<span class="token deleted">-   console.log('I get called from print.js!');</span>
<span class="token inserted">+   cosnole.log('I get called from print.js!');</span>
  }</code></pre>
<p>运行 <code>npm run build</code>，编译如下：</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
          Asset       Size  Chunks                    Chunk Names
  app.bundle.js    1.44 MB    0, 1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  app
print.bundle.js    6.43 kB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         print
     index.html  248 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.</code></pre>
<p>现在，在浏览器中打开生成的 <code>index.html</code> 文件，点击按钮，并且在控制台查看显示的错误。错误应该如下：</p>
<pre><code class="hljs language-bash">Uncaught ReferenceError: cosnole is not defined
   at HTMLButtonElement.printMe <span class="token punctuation">(</span>print.js:2<span class="token punctuation">)</span></code></pre>
<p>我们可以看到，此错误包含有发生错误的文件（<code>print.js</code>）和行号（2）的引用。这是非常有帮助的，因为现在我们可以确切地知道，所要解决问题的位置。</p>
<h2 id="choosing-a-development-tool">选择一个开发工具 <a href="#choosing-a-development-tool" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<blockquote class="warning">
<p>某些文本编辑器具有 "safe write(安全写入)" 功能，可能会干扰下面一些工具。阅读 <a href="#adjusting-your-text-editor">调整文本编辑器</a> 以解决这些问题。</p>
</blockquote>
<p>在每次编译代码时，手动运行 <code>npm run build</code> 会显得很麻烦。</p>
<p>webpack 提供几种可选方式，帮助你在代码发生变化后自动编译代码：</p>
<ol>
<li>webpack watch mode(webpack 观察模式)</li>
<li>webpack-dev-server</li>
<li>webpack-dev-middleware</li>
</ol>
<p>多数场景中，你可能需要使用 <code>webpack-dev-server</code>，但是不妨探讨一下以上的所有选项。</p>
<h3 id="using-watch-mode">使用 watch mode(观察模式) <a href="#using-watch-mode" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>你可以指示 webpack "watch" 依赖图中所有文件的更改。如果其中一个文件被更新，代码将被重新编译，所以你不必再去手动运行整个构建。</p>
<p>我们添加一个用于启动 webpack watch mode 的 npm scripts：</p>
<p><strong>package.json</strong></p>
<pre><code class="hljs language-diff">  {
    "name": "webpack-demo",
    "version": "1.0.0",
    "description": "",
    "scripts": {
      "test": "echo \"Error: no test specified\" &#x26;&#x26; exit 1",
<span class="token inserted">+     "watch": "webpack --watch",</span>
      "build": "webpack"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "devDependencies": {
      "clean-webpack-plugin": "^2.0.0",
      "css-loader": "^0.28.4",
      "csv-loader": "^2.1.1",
      "file-loader": "^0.11.2",
      "html-webpack-plugin": "^2.29.0",
      "style-loader": "^0.18.2",
      "webpack": "^4.30.0",
      "xml-loader": "^1.2.1"
    }
  }</code></pre>
<p>修改配置文件，告知 <code>CleanWebpackPlugin</code> 你不想在 watch 触发增量构建后删除 <code>index.html</code> 文件，我们通过配置 <a href="https://github.com/johnagan/clean-webpack-plugin#options-and-defaults-optional"><code>cleanStaleWebpackAssets</code> 选项</a> 来实现：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const HtmlWebpackPlugin = require('html-webpack-plugin');
  const { CleanWebpackPlugin } = require('clean-webpack-plugin');

  module.exports = {
    mode: 'development',
    entry: {
      app: './src/index.js',
      print: './src/print.js',
    },
    devtool: 'inline-source-map',
    plugins: [
<span class="token deleted">-     new CleanWebpackPlugin(),</span>
<span class="token inserted">+     new CleanWebpackPlugin({ cleanStaleWebpackAssets: false }),</span>
      new HtmlWebpackPlugin({
        title: 'Development',
      }),
    ],
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
  };</code></pre>
<p>现在，你可以在命令行中运行 <code>npm run watch</code>，然后就会看到 webpack 是如何编译代码。
然而，你会发现并没有退出命令行。这是因为此 script 当前还在 watch 你的文件。</p>
<p>现在，webpack 观察文件的同时，先移除我们之前加入的错误：</p>
<p><strong>src/print.js</strong></p>
<pre><code class="hljs language-diff">  export default function printMe() {
<span class="token deleted">-   cosnole.log('I get called from print.js!');</span>
<span class="token inserted">+   console.log('I get called from print.js!');</span>
  }</code></pre>
<p>现在，保存文件并检查 terminal(终端) 窗口。应该可以看到 webpack 自动地重新编译修改后的模块！</p>
<p>唯一的缺点是，为了看到修改后的实际效果，你需要刷新浏览器。如果能够自动刷新浏览器就更好了，因此接下来我们会尝试通过 <code>webpack-dev-server</code> 实现此功能。</p>
<h3 id="using-webpack-dev-server">使用 webpack-dev-server <a href="#using-webpack-dev-server" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p><code>webpack-dev-server</code> 为你提供了一个简单的 web server，并且具有 live reloading(实时重新加载) 功能。设置如下：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev webpack-dev-server</code></pre>
<p>修改配置文件，告知 dev server，从什么位置查找文件：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const HtmlWebpackPlugin = require('html-webpack-plugin');
  const { CleanWebpackPlugin } = require('clean-webpack-plugin');

  module.exports = {
    mode: 'development',
    entry: {
      app: './src/index.js',
      print: './src/print.js',
    },
    devtool: 'inline-source-map',
<span class="token inserted">+   devServer: {</span>
<span class="token inserted">+     contentBase: './dist',</span>
<span class="token inserted">+   },</span>
    plugins: [
      new CleanWebpackPlugin({ cleanStaleWebpackAssets: false }),
      new HtmlWebpackPlugin({
        title: 'Development',
      }),
    ],
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
  };</code></pre>
<p>以上配置告知 <code>webpack-dev-server</code>，将 <code>dist</code> 目录下的文件 serve 到 <code>localhost:8080</code> 下。（译注：serve，将资源作为 server 的可访问文件）</p>
<blockquote class="warning">
<p>webpack-dev-server 在编译之后不会写入到任何输出文件。而是将 bundle 文件保留在内存中，然后将它们 serve 到 server 中，就好像它们是挂载在 server 根路径上的真实文件一样。如果你的页面希望在其他不同路径中找到 bundle 文件，则可以通过 dev server 配置中的 <a href="/configuration/dev-server/#devserverpublicpath-"><code>publicPath</code></a> 选项进行修改。</p>
</blockquote>
<p>我们添加一个可以直接运行 dev server 的 script：</p>
<p><strong>package.json</strong></p>
<pre><code class="hljs language-diff">  {
    "name": "development",
    "version": "1.0.0",
    "description": "",
    "private": true,
    "scripts": {
      "test": "echo \"Error: no test specified\" &#x26;&#x26; exit 1",
      "watch": "webpack --watch",
<span class="token inserted">+     "start": "webpack-dev-server --open",</span>
      "build": "webpack"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "devDependencies": {
      "clean-webpack-plugin": "^2.0.0",
      "css-loader": "^0.28.4",
      "csv-loader": "^2.1.1",
      "express": "^4.15.3",
      "file-loader": "^0.11.2",
      "html-webpack-plugin": "^2.29.0",
      "style-loader": "^0.18.2",
      "webpack": "^4.30.0",
      "webpack-dev-server": "^3.8.0",
      "xml-loader": "^1.2.1"
    }
  }</code></pre>
<p>现在，在命令行中运行 <code>npm start</code>，我们会看到浏览器自动加载页面。如果你更改任何源文件并保存它们，web server 将在编译代码后自动重新加载。试试看！</p>
<p><code>webpack-dev-server</code> 具有许多可配置的选项。关于其他更多配置，请查看 <a href="/configuration/dev-server">配置文档</a>。</p>
<blockquote class="tip">
<p>现在，server 正在运行，你可能需要尝试 <a href="/guides/hot-module-replacement">模块热替换(hot module replacement)</a>！</p>
</blockquote>
<h3 id="using-webpack-dev-middleware">使用 webpack-dev-middleware <a href="#using-webpack-dev-middleware" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p><code>webpack-dev-middleware</code> 是一个封装器(wrapper)，它可以把 webpack 处理过的文件发送到一个 server。  <code>webpack-dev-server</code> 在内部使用了它，然而它也可以作为一个单独的 package 来使用，以便根据需求进行更多自定义设置。下面是一个 webpack-dev-middleware 配合 express server 的示例。</p>
<p>首先，安装 <code>express</code> 和 <code>webpack-dev-middleware</code>：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev express webpack-dev-middleware</code></pre>
<p>现在，我们需要调整 webpack 配置文件，以确保 middleware(中间件) 功能能够正确启用：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const HtmlWebpackPlugin = require('html-webpack-plugin');
  const { CleanWebpackPlugin } = require('clean-webpack-plugin');

  module.exports = {
    mode: 'development',
    entry: {
      app: './src/index.js',
      print: './src/print.js',
    },
    devtool: 'inline-source-map',
    devServer: {
      contentBase: './dist',
    },
    plugins: [
      new CleanWebpackPlugin({ cleanStaleWebpackAssets: false }),
      new HtmlWebpackPlugin({
        title: '管理输出',
      }),
    ],
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
<span class="token inserted">+     publicPath: '/',</span>
    },
  };</code></pre>
<p>我们将会在 server 脚本使用 <code>publicPath</code>，以确保文件资源能够正确地 serve 在 <code>http://localhost:3000</code> 下，稍后我们会指定 port number(端口号)。接下来是设置自定义 <code>express</code> server：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  |- package.json
  |- webpack.config.js
<span class="token inserted">+ |- server.js</span>
  |- /dist
  |- /src
    |- index.js
    |- print.js
  |- /node_modules</code></pre>
<p><strong>server.js</strong></p>
<pre><code class="hljs language-javascript"><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> webpackDevMiddleware <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-dev-middleware'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./webpack.config.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> compiler <span class="token operator">=</span> <span class="token function">webpack</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 告知 express 使用 webpack-dev-middleware，</span>
<span class="token comment">// 以及将 webpack.config.js 配置文件作为基础配置。</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">webpackDevMiddleware</span><span class="token punctuation">(</span>compiler<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  publicPath<span class="token punctuation">:</span> config<span class="token punctuation">.</span>output<span class="token punctuation">.</span>publicPath<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 将文件 serve 到 port 3000。</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Example app listening on port 3000!\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>现在，添加一个 npm script，以使我们更方便地运行 server：</p>
<p><strong>package.json</strong></p>
<pre><code class="hljs language-diff">  {
    "name": "development",
    "version": "1.0.0",
    "description": "",
    "private": true,
    "scripts": {
      "test": "echo \"Error: no test specified\" &#x26;&#x26; exit 1",
      "watch": "webpack --watch",
      "start": "webpack-dev-server --open",
<span class="token inserted">+     "server": "node server.js",</span>
      "build": "webpack"
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "devDependencies": {
      "clean-webpack-plugin": "^2.0.0",
      "css-loader": "^0.28.4",
      "csv-loader": "^2.1.1",
      "express": "^4.15.3",
      "file-loader": "^0.11.2",
      "html-webpack-plugin": "^2.29.0",
      "style-loader": "^0.18.2",
      "webpack": "^4.30.0",
      "webpack-dev-middleware": "^1.12.0",
      "webpack-dev-server": "^3.8.0",
      "xml-loader": "^1.2.1"
    }
  }</code></pre>
<p>现在，在 terminal(终端) 中执行 <code>npm run server</code>，将会有类似如下信息输出：</p>
<pre><code class="hljs language-bash">Example app listening on port 3000<span class="token operator">!</span>
<span class="token punctuation">..</span>.
          Asset       Size  Chunks                    Chunk Names
  app.bundle.js    1.44 MB    0, 1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  app
print.bundle.js    6.57 kB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         print
     index.html  306 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.
webpack: Compiled successfully.</code></pre>
<p>现在，打开浏览器，访问 <code>http://localhost:3000</code>。应该看到 webpack 应用程序已经运行！</p>
<blockquote class="tip">
<p>如果想要了解更多关于模块热替换(hot module replacement)的运行机制，我们推荐你查看 <a href="/guides/hot-module-replacement/">模块热替换(hot module replacement)</a> 指南。</p>
</blockquote>
<h2 id="adjusting-your-text-editor">调整文本编辑器 <a href="#adjusting-your-text-editor" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>使用自动编译代码时，可能会在保存文件时遇到一些问题。某些编辑器具有 "safe write(安全写入)" 功能，会影响重新编译。</p>
<p>在一些常见的编辑器中禁用此功能，查看以下列表：</p>
<ul>
<li><strong>Sublime Text 3</strong>：在用户首选项(user preferences)中添加 <code>atomic_save: 'false'</code>。</li>
<li><strong>JetBrains IDEs (e.g. WebStorm)</strong>：在 <code>Preferences > Appearance &#x26; Behavior > System Settings</code> 中取消选中 "Use safe write"。</li>
<li><strong>Vim</strong>：在设置(settings)中增加 <code>:set backupcopy=yes</code>。</li>
</ul>
<h2 id="conclusion">结论 <a href="#conclusion" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>现在，你已经学会了如何自动编译代码，并运行一个简单的 development server，查看下一个指南，其中将介绍<a href="/guides/code-splitting/">代码分割（Code Splitting）</a>。</p>
<h1 id="代码分离">代码分离<a href="#%E4%BB%A3%E7%A0%81%E5%88%86%E7%A6%BB" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<blockquote class="tip">
<p>本指南继续沿用 <a href="/guides/getting-started">起步</a> 和 <a href="/guides/output-management">管理输出</a> 中的示例代码。请确保你已熟悉这些指南中提供的示例。</p>
</blockquote>
<p>代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p>
<p>常用的代码分离方法有三种：</p>
<ul>
<li>入口起点：使用 <a href="/configuration/entry-context"><code>entry</code></a> 配置手动地分离代码。</li>
<li>防止重复：使用 <a href="/plugins/split-chunks-plugin"><code>SplitChunksPlugin</code></a> 去重和分离 chunk。</li>
<li>动态导入：通过模块的内联函数调用来分离代码。</li>
</ul>
<h2 id="entry-points">入口起点(entry point) <a href="#entry-points" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>这是迄今为止最简单直观的分离代码的方式。不过，这种方式手动配置较多，并有一些隐患，我们将会解决这些问题。先来看看如何从 main bundle 中分离 another module(另一个模块)：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">webpack-demo
|- package.json
|- webpack.config.js
|- /dist
|- /src
  |- index.js
<span class="token inserted">+ |- another-module.js</span>
|- /node_modules</code></pre>
<p><strong>another-module.js</strong></p>
<pre><code class="hljs language-js"><span class="token keyword">import</span> _ <span class="token keyword">from</span> <span class="token string">'lodash'</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>
  _<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Another'</span><span class="token punctuation">,</span> <span class="token string">'module'</span><span class="token punctuation">,</span> <span class="token string">'loaded!'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">' '</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">const path = require('path');

module.exports = {
  mode: 'development',
  entry: {
    index: './src/index.js',
<span class="token inserted">+   another: './src/another-module.js',</span>
  },
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
};</code></pre>
<p>这将生成如下构建结果：</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
            Asset     Size   Chunks             Chunk Names
another.bundle.js  550 KiB  another  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  another
  index.bundle.js  550 KiB    index  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  index
Entrypoint index <span class="token operator">=</span> index.bundle.js
Entrypoint another <span class="token operator">=</span> another.bundle.js
<span class="token punctuation">..</span>.</code></pre>
<p>正如前面提到的，这种方式存在一些隐患：</p>
<ul>
<li>如果入口 chunk 之间包含一些重复的模块，那些重复模块都会被引入到各个 bundle 中。</li>
<li>这种方法不够灵活，并且不能动态地将核心应用程序逻辑中的代码拆分出来。</li>
</ul>
<p>以上两点中，第一点对我们的示例来说无疑是个问题，因为之前我们在 <code>./src/index.js</code> 中也引入过 <code>lodash</code>，这样就在两个 bundle 中造成重复引用。接着，我们通过使用 <a href="/plugins/split-chunks-plugin"><code>SplitChunksPlugin</code></a> 来移除重复的模块。</p>
<h2 id="prevent-duplication">防止重复(prevent duplication) <a href="#prevent-duplication" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<h3 id="entry-dependencies">入口依赖 <a href="#entry-dependencies" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>配置 <a href="/configuration/entry-context/#dependencies"><code>dependOn</code> option</a> 选项，这样可以在多个 chunk 之间共享模块。</p>
<pre><code class="hljs language-diff">  const path = require('path');

  module.exports = {
    mode: 'development',
    entry: {
<span class="token deleted">-     index: './src/index.js',</span>
<span class="token deleted">-     another: './src/another-module.js',</span>
<span class="token inserted">+     index: { import: './src/index.js', dependOn: 'shared' },</span>
<span class="token inserted">+     another: { import: './src/another-module.js', dependOn: 'shared' },</span>
<span class="token inserted">+     shared: 'lodash',</span>
    },
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
  };</code></pre>
<h3 id="splitchunksplugin"><code>SplitChunksPlugin</code> <a href="#splitchunksplugin" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p><a href="/plugins/split-chunks-plugin"><code>SplitChunksPlugin</code></a> 插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。让我们使用这个插件，将之前的示例中重复的 <code>lodash</code> 模块去除：</p>
<blockquote class="warning">
<p>CommonsChunkPlugin 已经从 webpack v4 legato 中移除。想要了解在最新版本中如何处理 chunks，请查看 <a href="/plugins/split-chunks-plugin"><code>SplitChunksPlugin</code></a> 。</p>
</blockquote>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');

  module.exports = {
    mode: 'development',
    entry: {
      index: './src/index.js',
      another: './src/another-module.js',
    },
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
<span class="token inserted">+   optimization: {</span>
<span class="token inserted">+     splitChunks: {</span>
<span class="token inserted">+       chunks: 'all',</span>
<span class="token inserted">+     },</span>
<span class="token inserted">+   },</span>
  };</code></pre>
<p>使用 <a href="/plugins/split-chunks-plugin/#optimization-splitchunks"><code>optimization.splitChunks</code></a> 配置选项之后，现在应该可以看出，<code>index.bundle.js</code> 和 <code>another.bundle.js</code> 中已经移除了重复的依赖模块。需要注意的是，插件将 <code>lodash</code> 分离到单独的 chunk，并且将其从 main bundle 中移除，减轻了大小。执行 <code>npm run build</code> 查看效果：</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
                          Asset      Size                 Chunks             Chunk Names
              another.bundle.js  5.95 KiB                another  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  another
                index.bundle.js  5.89 KiB                  index  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  index
vendors~another~index.bundle.js   547 KiB  vendors~another~index  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  vendors~another~index
Entrypoint index <span class="token operator">=</span> vendors~another~index.bundle.js index.bundle.js
Entrypoint another <span class="token operator">=</span> vendors~another~index.bundle.js another.bundle.js
<span class="token punctuation">..</span>.</code></pre>
<p>以下是由社区提供，一些对于代码分离很有帮助的 plugin 和 loader：</p>
<ul>
<li><a href="plugins/mini-css-extract-plugin"><code>mini-css-extract-plugin</code></a>: 用于将 CSS 从主应用程序中分离。</li>
</ul>
<h2 id="dynamic-imports">动态导入(dynamic import) <a href="#dynamic-imports" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>当涉及到动态代码拆分时，webpack 提供了两个类似的技术。第一种，也是推荐选择的方式是，使用符合 <a href="https://github.com/tc39/proposal-dynamic-import">ECMAScript 提案</a> 的 <a href="/api/module-methods/#import-1"><code>import()</code> 语法</a> 来实现动态导入。第二种，则是 webpack 的遗留功能，使用 webpack 特定的 <a href="/api/module-methods/#requireensure"><code>require.ensure</code></a>。让我们先尝试使用第一种……</p>
<blockquote class="warning">
<p><code>import()</code> 调用会在内部用到 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">promises</a>。如果在旧版本浏览器中使用 <code>import()</code>，记得使用一个 polyfill 库（例如 <a href="https://github.com/stefanpenner/es6-promise">es6-promise</a> 或 <a href="https://github.com/taylorhakes/promise-polyfill">promise-polyfill</a>），来 shim <code>Promise</code>。</p>
</blockquote>
<p>在我们开始之前，先从配置中移除掉多余的 <a href="/concepts/entry-points/"><code>entry</code></a> 和 <a href="/plugins/split-chunks-plugin/#optimization-splitchunks"><code>optimization.splitChunks</code></a>，因为接下来的演示中并不需要它们：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');

  module.exports = {
    mode: 'development',
    entry: {
      index: './src/index.js',
<span class="token deleted">-     another: './src/another-module.js',</span>
    },
    output: {
      filename: '[name].bundle.js',
<span class="token inserted">+     chunkFilename: '[name].bundle.js',</span>
      publicPath: 'dist/',
      path: path.resolve(__dirname, 'dist'),
    },
<span class="token deleted">-   optimization: {</span>
<span class="token deleted">-     splitChunks: {</span>
<span class="token deleted">-       chunks: 'all',</span>
<span class="token deleted">-     },</span>
<span class="token deleted">-   },</span>
  };</code></pre>
<p>注意，这里使用了 <code>chunkFilename</code>，它决定 non-entry chunk(非入口 chunk) 的名称。关于 <code>chunkFilename</code> 更多信息，请查看 <a href="/configuration/output/#outputchunkfilename">输出</a> 文档。更新我们的项目，移除现在不会用到的文件：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">webpack-demo
|- package.json
|- webpack.config.js
|- /dist
|- /src
  |- index.js
<span class="token deleted">- |- another-module.js</span>
|- /node_modules</code></pre>
<p>现在，我们不再使用 statically import(静态导入) <code>lodash</code>，而是通过 dynamic import(动态导入) 来分离出一个 chunk：</p>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff"><span class="token deleted">- import _ from 'lodash';</span>
<span class="token deleted">-</span>
<span class="token deleted">- function component() {</span>
<span class="token inserted">+ function getComponent() {</span>
<span class="token deleted">-   const element = document.createElement('div');</span>
<span class="token deleted">-</span>
<span class="token deleted">-   // Lodash, now imported by this script</span>
<span class="token deleted">-   element.innerHTML = _.join(['Hello', 'webpack'], ' ');</span>
<span class="token inserted">+   return import(/* webpackChunkName: "lodash" */ 'lodash').then(({ default: _ }) => {</span>
<span class="token inserted">+     const element = document.createElement('div');</span>
<span class="token inserted">+</span>
<span class="token inserted">+     element.innerHTML = _.join(['Hello', 'webpack'], ' ');</span>
<span class="token inserted">+</span>
<span class="token inserted">+     return element;</span>
<span class="token inserted">+</span>
<span class="token inserted">+   }).catch(error => 'An error occurred while loading the component');</span>
  }

<span class="token deleted">- document.body.appendChild(component());</span>
<span class="token inserted">+ getComponent().then(component => {</span>
<span class="token inserted">+   document.body.appendChild(component);</span>
<span class="token inserted">+ })</span></code></pre>
<p>我们之所以需要 <code>default</code>，是因为 webpack 4 在导入 CommonJS 模块时，将不再解析为 <code>module.exports</code> 的值，而是为 CommonJS 模块创建一个 artificial namespace 对象，更多有关背后原因的信息，请阅读 <a href="https://medium.com/webpack/webpack-4-import-and-commonjs-d619d626b655">webpack 4: import() and CommonJs</a></p>
<p>注意，在注释中使用了 <code>webpackChunkName</code>。这样做会导致我们的 bundle 被命名为 <code>lodash.bundle.js</code> ，而不是 <code>[id].bundle.js</code> 。想了解更多关于 <code>webpackChunkName</code> 和其他可用选项，请查看 <a href="/api/module-methods/#import-1"><code>import()</code> 相关文档</a>。让我们执行 webpack，查看 <code>lodash</code> 是否会分离到一个单独的 bundle：</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
                   Asset      Size          Chunks             Chunk Names
         index.bundle.js  7.88 KiB           index  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  index
vendors~lodash.bundle.js   547 KiB  vendors~lodash  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  vendors~lodash
Entrypoint index <span class="token operator">=</span> index.bundle.js
<span class="token punctuation">..</span>.</code></pre>
<p>由于 <code>import()</code> 会返回一个 promise，因此它可以和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"><code>async</code> 函数</a>一起使用。但是，需要使用像 Babel 这样的预处理器和 <a href="https://babel.docschina.org/docs/plugins/syntax-dynamic-import/#installation">Syntax Dynamic Import Babel Plugin</a>。下面是如何通过 async 函数简化代码：</p>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff"><span class="token deleted">- function getComponent() {</span>
<span class="token inserted">+ async function getComponent() {</span>
<span class="token deleted">-   return import(/* webpackChunkName: "lodash" */ 'lodash').then(({ default: _ }) => {</span>
<span class="token deleted">-     const element = document.createElement('div');</span>
<span class="token deleted">-</span>
<span class="token deleted">-     element.innerHTML = _.join(['Hello', 'webpack'], ' ');</span>
<span class="token deleted">-</span>
<span class="token deleted">-     return element;</span>
<span class="token deleted">-</span>
<span class="token deleted">-   }).catch(error => 'An error occurred while loading the component');</span>
<span class="token inserted">+   const element = document.createElement('div');</span>
<span class="token inserted">+   const { default: _ } = await import(/* webpackChunkName: "lodash" */ 'lodash');</span>
<span class="token inserted">+</span>
<span class="token inserted">+   element.innerHTML = _.join(['Hello', 'webpack'], ' ');</span>
<span class="token inserted">+</span>
<span class="token inserted">+   return element;</span>
  }

  getComponent().then(component => {
    document.body.appendChild(component);
  });</code></pre>
<blockquote class="tip">
<p>在稍后示例中，可能会根据计算后的变量(computed variable)导入特定模块时，可以通过向 <code>import()</code> 传入一个 <a href="/api/module-methods/#dynamic-expressions-in-import">动态表达式</a>。</p>
</blockquote>
<h2 id="prefetchingpreloading-modules">预获取/预加载模块(prefetch/preload module) <a href="#prefetchingpreloading-modules" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>webpack v4.6.0+ 增加了对预获取和预加载的支持。</p>
<p>在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 "resource hint(资源提示)"，来告知浏览器：</p>
<ul>
<li>prefetch(预获取)：将来某些导航下可能需要的资源</li>
<li>preload(预加载)：当前导航下可能需要资源</li>
</ul>
<p>下面这个 prefetch 的简单示例中，有一个 <code>HomePage</code> 组件，其内部渲染一个 <code>LoginButton</code> 组件，然后在点击后按需加载 <code>LoginModal</code> 组件。</p>
<p><strong>LoginButton.js</strong></p>
<pre><code class="hljs language-js"><span class="token comment">//...</span>
<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackPrefetch: true */</span> <span class="token string">'LoginModal'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>这会生成 <code>&#x3C;link rel="prefetch" href="login-modal-chunk.js"></code> 并追加到页面头部，指示着浏览器在闲置时间预取 <code>login-modal-chunk.js</code> 文件。</p>
<blockquote class="tip">
<p>只要父 chunk 完成加载，webpack 就会添加 prefetch hint(预取提示)。</p>
</blockquote>
<p>与 prefetch 指令相比，preload 指令有许多不同之处：</p>
<ul>
<li>preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。</li>
<li>preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。</li>
<li>preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。</li>
<li>浏览器支持程度不同。</li>
</ul>
<p>下面这个简单的 preload 示例中，有一个 <code>Component</code>，依赖于一个较大的 library，所以应该将其分离到一个独立的 chunk 中。</p>
<p>我们假想这里的图表组件 <code>ChartComponent</code> 组件需要依赖体积巨大的 <code>ChartingLibrary</code> 库。它会在渲染时显示一个 <code>LoadingIndicator(加载进度条)</code> 组件，然后立即按需导入 <code>ChartingLibrary</code>：</p>
<p><strong>ChartComponent.js</strong></p>
<pre><code class="hljs language-js"><span class="token comment">//...</span>
<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token comment">/* webpackPreload: true */</span> <span class="token string">'ChartingLibrary'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>在页面中使用 <code>ChartComponent</code> 时，在请求 ChartComponent.js 的同时，还会通过 <code>&#x3C;link rel="preload"></code> 请求 charting-library-chunk。假定 page-chunk 体积很小，很快就被加载好，页面此时就会显示 <code>LoadingIndicator(加载进度条)</code> ，等到 <code>charting-library-chunk</code> 请求完成，LoadingIndicator 组件才消失。启动仅需要很少的加载时间，因为只进行单次往返，而不是两次往返。尤其是在高延迟环境下。</p>
<blockquote class="tip">
<p>不正确地使用 webpackPreload 会有损性能，请谨慎使用。</p>
</blockquote>
<h2 id="bundle-analysis">bundle 分析(bundle analysis) <a href="#bundle-analysis" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>一旦开始分离代码，一件很有帮助的事情是，分析输出结果来检查模块在何处结束。 <a href="https://github.com/webpack/analyse">官方分析工具</a> 是一个不错的开始。还有一些其他社区支持的可选项：</p>
<ul>
<li><a href="https://alexkuz.github.io/webpack-chart/">webpack-chart</a>: webpack stats 可交互饼图。</li>
<li><a href="https://chrisbateman.github.io/webpack-visualizer/">webpack-visualizer</a>: 可视化并分析你的 bundle，检查哪些模块占用空间，哪些可能是重复使用的。</li>
<li><a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">webpack-bundle-analyzer</a>：一个 plugin 和 CLI 工具，它将 bundle 内容展示为一个便捷的、交互式、可缩放的树状图形式。</li>
<li><a href="https://webpack.jakoblind.no/optimize">webpack bundle optimize helper</a>：这个工具会分析你的 bundle，并提供可操作的改进措施，以减少 bundle 的大小。</li>
<li><a href="https://github.com/bundle-stats/bundle-stats">bundle-stats</a>：生成一个 bundle 报告（bundle 大小、资源、模块），并比较不同构建之间的结果。</li>
</ul>
<h2 id="next-steps">下一步 <a href="#next-steps" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>接下来，查看 <a href="/guides/lazy-loading/">延迟加载</a> 来学习如何在实际一个真实应用程序中使用 <code>import()</code> 的具体示例，以及查看 <a href="/guides/caching/">缓存</a> 来学习如何有效地分离代码。</p>
<h1 id="缓存">缓存<a href="#%E7%BC%93%E5%AD%98" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<blockquote class="tip">
<p>本指南继续沿用 <a href="/guides/getting-started">起步</a>、<a href="/guides/output-management">管理输出</a> 和 <a href="/guides/code-splitting">代码分离</a> 中的代码示例。</p>
</blockquote>
<p>以上，我们使用 webpack 来打包我们的模块化后的应用程序，webpack 会生成一个可部署的 <code>/dist</code> 目录，然后把打包后的内容放置在此目录中。只要 <code>/dist</code> 目录中的内容部署到 server 上，client（通常是浏览器）就能够访问此 server 的网站及其资源。而最后一步获取资源是比较耗费时间的，这就是为什么浏览器使用一种名为 <a href="https://searchstorage.techtarget.com/definition/cache">缓存</a> 的技术。可以通过命中缓存，以降低网络流量，使网站加载速度更快，然而，如果我们在部署新版本时不更改资源的文件名，浏览器可能会认为它没有被更新，就会使用它的缓存版本。由于缓存的存在，当你需要获取新的代码时，就会显得很棘手。</p>
<p>此指南的重点在于通过必要的配置，以确保 webpack 编译生成的文件能够被客户端缓存，而在文件内容变化后，能够请求到新的文件。</p>
<h2 id="output-filenames">输出文件的文件名(output filename) <a href="#output-filenames" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>我们可以通过替换 <code>output.filename</code> 中的 <a href="/configuration/output/#outputfilename">substitutions</a> 设置，来定义输出文件的名称。webpack 提供了一种使用称为 <strong>substitution(可替换模板字符串)</strong> 的方式，通过带括号字符串来模板化文件名。其中，<code>[contenthash]</code> substitution 将根据资源内容创建出唯一 hash。当资源内容发生变化时，<code>[contenthash]</code> 也会发生变化。</p>
<p>这里使用 <a href="/guides/getting-started">起步</a> 中的示例和 <a href="/guides/output-management">管理输出</a> 中的 <code>plugins</code> 插件来作为项目基础，所以我们依然不必手动地维护 <code>index.html</code> 文件：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">webpack-demo
|- package.json
|- webpack.config.js
|- /dist
|- /src
  |- index.js
|- /node_modules</code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const { CleanWebpackPlugin } = require('clean-webpack-plugin');
  const HtmlWebpackPlugin = require('html-webpack-plugin');

  module.exports = {
    entry: './src/index.js',
    plugins: [
      // 对于 CleanWebpackPlugin 的 v2 versions 以下版本，使用 new CleanWebpackPlugin(['dist/*'])
      new CleanWebpackPlugin(),
      new HtmlWebpackPlugin({
<span class="token deleted">-       title: 'Output Management',</span>
<span class="token inserted">+       title: 'Caching',</span>
      }),
    ],
    output: {
<span class="token deleted">-     filename: 'bundle.js',</span>
<span class="token inserted">+     filename: '[name].[contenthash].js',</span>
      path: path.resolve(__dirname, 'dist'),
    },
  };</code></pre>
<p>使用此配置，然后运行我们的 build script <code>npm run build</code>，产生以下输出：</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
                       Asset       Size  Chunks                    Chunk Names
main.7e2c49a622975ebd9b7e.js     544 kB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  main
                  index.html  197 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.</code></pre>
<p>可以看到，bundle 的名称是它内容（通过 hash）的映射。如果我们不做修改，然后再次运行构建，我们以为文件名会保持不变。然而，如果我们真的运行，可能会发现情况并非如此：</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
                       Asset       Size  Chunks                    Chunk Names
main.205199ab45963f6a62ec.js     544 kB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  main
                  index.html  197 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.</code></pre>
<p>这也是因为 webpack 在入口 chunk 中，包含了某些 boilerplate(引导模板)，特别是 runtime 和 manifest。（译注：boilerplate 指 webpack 运行时的引导代码）</p>
<blockquote class="warning">
<p>输出可能会因当前的 webpack 版本而稍有差异。与旧版本相比，新版本不一定有完全相同的问题，但我们仍然推荐的以下步骤，确保结果可靠。</p>
</blockquote>
<h2 id="extracting-boilerplate">提取引导模板(extracting boilerplate) <a href="#extracting-boilerplate" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>正如我们在 <a href="/guides/code-splitting">代码分离</a> 中所学到的，<a href="/plugins/split-chunks-plugin/"><code>SplitChunksPlugin</code></a> 可以用于将模块分离到单独的 bundle 中。webpack 还提供了一个优化功能，可使用 <a href="/configuration/optimization/#optimizationruntimechunk"><code>optimization.runtimeChunk</code></a> 选项将 runtime 代码拆分为一个单独的 chunk。将其设置为 <code>single</code> 来为所有 chunk 创建一个 runtime bundle：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const { CleanWebpackPlugin } = require('clean-webpack-plugin');
  const HtmlWebpackPlugin = require('html-webpack-plugin');

  module.exports = {
    entry: './src/index.js',
    plugins: [
      // 对于 CleanWebpackPlugin 的 v2 versions 以下版本，使用 new CleanWebpackPlugin(['dist/*'])
      new CleanWebpackPlugin(),
      new HtmlWebpackPlugin({
        title: 'Caching',
      }),
    ],
    output: {
      filename: '[name].[contenthash].js',
      path: path.resolve(__dirname, 'dist'),
    },
<span class="token inserted">+   optimization: {</span>
<span class="token inserted">+     runtimeChunk: 'single',</span>
<span class="token inserted">+   },</span>
  };</code></pre>
<p>再次构建，然后查看提取出来的 <code>runtime</code> bundle：</p>
<pre><code class="hljs language-bash">Hash: 82c9c385607b2150fab2
Version: webpack 4.12.0
Time: 3027ms
                          Asset       Size  Chunks             Chunk Names
runtime.cc17ae2a94ec771e9221.js   1.42 KiB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  runtime
   main.e81de2cf758ada72f306.js   69.5 KiB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  main
                     index.html  275 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
<span class="token punctuation">[</span>1<span class="token punctuation">]</span> <span class="token punctuation">(</span>webpack<span class="token punctuation">)</span>/buildin/module.js 497 bytes <span class="token punctuation">{</span>1<span class="token punctuation">}</span> <span class="token punctuation">[</span>built<span class="token punctuation">]</span>
<span class="token punctuation">[</span>2<span class="token punctuation">]</span> <span class="token punctuation">(</span>webpack<span class="token punctuation">)</span>/buildin/global.js 489 bytes <span class="token punctuation">{</span>1<span class="token punctuation">}</span> <span class="token punctuation">[</span>built<span class="token punctuation">]</span>
<span class="token punctuation">[</span>3<span class="token punctuation">]</span> ./src/index.js 309 bytes <span class="token punctuation">{</span>1<span class="token punctuation">}</span> <span class="token punctuation">[</span>built<span class="token punctuation">]</span>
    + 1 hidden module</code></pre>
<p>将第三方库(library)（例如 <code>lodash</code> 或 <code>react</code>）提取到单独的 <code>vendor</code> chunk 文件中，是比较推荐的做法，这是因为，它们很少像本地的源代码那样频繁修改。因此通过实现以上步骤，利用 client 的长效缓存机制，命中缓存来消除请求，并减少向 server 获取资源，同时还能保证 client 代码和 server 代码版本一致。
这可以通过使用 <a href="/plugins/split-chunks-plugin/#split-chunks-example-2">SplitChunksPlugin 示例 2</a> 中演示的 <a href="/plugins/split-chunks-plugin/"><code>SplitChunksPlugin</code></a> 插件的 <a href="/plugins/split-chunks-plugin/#splitchunkscachegroups"><code>cacheGroups</code></a> 选项来实现。我们在 <code>optimization.splitChunks</code> 添加如下 <code>cacheGroups</code> 参数并构建：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const { CleanWebpackPlugin } = require('clean-webpack-plugin');
  const HtmlWebpackPlugin = require('html-webpack-plugin');

  module.exports = {
    entry: './src/index.js',
    plugins: [
      // 对于 CleanWebpackPlugin 的 v2 versions 以下版本，使用 new CleanWebpackPlugin(['dist/*'])
      new CleanWebpackPlugin(),
      new HtmlWebpackPlugin({
        title: 'Caching',
      }),
    ],
    output: {
      filename: '[name].[contenthash].js',
      path: path.resolve(__dirname, 'dist'),
    },
    optimization: {
      runtimeChunk: 'single',
<span class="token inserted">+     splitChunks: {</span>
<span class="token inserted">+       cacheGroups: {</span>
<span class="token inserted">+         vendor: {</span>
<span class="token inserted">+           test: /[\\/]node_modules[\\/]/,</span>
<span class="token inserted">+           name: 'vendors',</span>
<span class="token inserted">+           chunks: 'all',</span>
<span class="token inserted">+         },</span>
<span class="token inserted">+       },</span>
<span class="token inserted">+     },</span>
    },
  };</code></pre>
<p>再次构建，然后查看新的 <code>vendor</code> bundle：</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
                          Asset       Size  Chunks             Chunk Names
runtime.cc17ae2a94ec771e9221.js   1.42 KiB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  runtime
vendors.a42c3ca0d742766d7a28.js   69.4 KiB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  vendors
   main.abf44fedb7d11d4312d7.js  240 bytes       2  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  main
                     index.html  353 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.</code></pre>
<p>现在，我们可以看到 <code>main</code> 不再含有来自 <code>node_modules</code> 目录的 <code>vendor</code> 代码，并且体积减少到 <code>240 bytes</code>！</p>
<h2 id="module-identifiers">模块标识符(module identifier) <a href="#module-identifiers" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>在项目中再添加一个模块 <code>print.js</code>：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">webpack-demo
|- package.json
|- webpack.config.js
|- /dist
|- /src
  |- index.js
<span class="token inserted">+ |- print.js</span>
|- /node_modules</code></pre>
<p><strong>print.js</strong></p>
<pre><code class="hljs language-diff"><span class="token inserted">+ export default function print(text) {</span>
<span class="token inserted">+   console.log(text);</span>
<span class="token inserted">+ };</span></code></pre>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff">  import _ from 'lodash';
<span class="token inserted">+ import Print from './print';</span>

  function component() {
    const element = document.createElement('div');

    // lodash 是由当前 script 脚本 import 进来的
    element.innerHTML = _.join(['Hello', 'webpack'], ' ');
<span class="token inserted">+   element.onclick = Print.bind(null, 'Hello webpack!');</span>

    return element;
  }

  document.body.appendChild(component());</code></pre>
<p>再次运行构建，然后我们期望的是，只有 <code>main</code> bundle 的 hash 发生变化，然而……</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
                           Asset       Size  Chunks                    Chunk Names
  runtime.1400d5af64fc1b7b3a45.js    5.85 kB      0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         runtime
  vendor.a7561fb0e9a071baadb9.js     541 kB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  vendor
    main.b746e3eb72875af2caa9.js    1.22 kB       2  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         main
                      index.html  352 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.</code></pre>
<p>……我们可以看到这三个文件的 hash 都变化了。这是因为每个 <a href="/api/module-variables/#moduleid-commonjs"><code>module.id</code></a> 会默认地基于解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变。因此，简要概括：</p>
<ul>
<li><code>main</code> bundle 会随着自身的新增内容的修改，而发生变化。</li>
<li><code>vendor</code> bundle 会随着自身的 <code>module.id</code> 的变化，而发生变化。</li>
<li><code>manifest</code> runtime 会因为现在包含一个新模块的引用，而发生变化。</li>
</ul>
<p>第一个和最后一个都是符合预期的行为，<code>vendor</code> hash 发生变化是我们要修复的。我们将 <a href="/configuration/optimization/#optimizationmoduleids"><code>optimization.moduleIds</code></a> 设置为 <code>'hashed'</code>：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const { CleanWebpackPlugin } = require('clean-webpack-plugin');
  const HtmlWebpackPlugin = require('html-webpack-plugin');

  module.exports = {
    entry: './src/index.js',
    plugins: [
      // 对于 CleanWebpackPlugin 的 v2 versions 以下版本，使用 new CleanWebpackPlugin(['dist/*'])
      new CleanWebpackPlugin(),
      new HtmlWebpackPlugin({
        title: 'Caching',
      }),
    ],
    output: {
      filename: '[name].[contenthash].js',
      path: path.resolve(__dirname, 'dist'),
    },
    optimization: {
<span class="token inserted">+     moduleIds: 'hashed',</span>
      runtimeChunk: 'single',
      splitChunks: {
        cacheGroups: {
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
          },
        },
      },
    },
  };</code></pre>
<p>现在，不论是否添加任何新的本地依赖，对于前后两次构建，<code>vendor</code> hash 都应该保持一致：</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
                          Asset       Size  Chunks             Chunk Names
   main.216e852f60c8829c2289.js  340 bytes       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  main
vendors.55e79e5927a639d21a1b.js   69.5 KiB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  vendors
runtime.725a1a51ede5ae0cfde0.js   1.42 KiB       2  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  runtime
                     index.html  353 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
Entrypoint main <span class="token operator">=</span> runtime.725a1a51ede5ae0cfde0.js vendors.55e79e5927a639d21a1b.js main.216e852f60c8829c2289.js
<span class="token punctuation">..</span>.</code></pre>
<p>然后，修改 <code>src/index.js</code>，临时移除额外的依赖：</p>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff">  import _ from 'lodash';
<span class="token deleted">- import Print from './print';</span>
<span class="token inserted">+ // import Print from './print';</span>

  function component() {
    const element = document.createElement('div');

    // lodash 是由当前 script 脚本 import 进来的
    element.innerHTML = _.join(['Hello', 'webpack'], ' ');
<span class="token deleted">-   element.onclick = Print.bind(null, 'Hello webpack!');</span>
<span class="token inserted">+   // element.onclick = Print.bind(null, 'Hello webpack!');</span>

    return element;
  }

  document.body.appendChild(component());</code></pre>
<p>最后，再次运行我们的构建：</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
                          Asset       Size  Chunks             Chunk Names
   main.ad717f2466ce655fff5c.js  274 bytes       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  main
vendors.55e79e5927a639d21a1b.js   69.5 KiB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  vendors
runtime.725a1a51ede5ae0cfde0.js   1.42 KiB       2  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  runtime
                     index.html  353 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
Entrypoint main <span class="token operator">=</span> runtime.725a1a51ede5ae0cfde0.js vendors.55e79e5927a639d21a1b.js main.ad717f2466ce655fff5c.js
<span class="token punctuation">..</span>.</code></pre>
<p>我们可以看到，这两次构建中，<code>vendor</code> bundle 文件名称，都是 <code>55e79e5927a639d21a1b</code>。</p>
<h2 id="conclusion">结论 <a href="#conclusion" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>缓存可能很复杂，但是从应用程序或站点用户可以获得的收益来看，这值得付出努力。想要了解更多信息，请查看下面<em>进一步阅读</em>部分。</p>
<h1 id="创建-library">创建 library<a href="#%E5%88%9B%E5%BB%BA-library" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p>除了打包应用程序，webpack 还可以用于打包 JavaScript library。以下指南适用于希望简化打包策略的 library 作者。</p>
<h2 id="authoring-a-library">创建一个 library <a href="#authoring-a-library" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>假设你正在编写一个名为 <code>webpack-numbers</code> 的小的 library，可以将数字 1 到 5 转换为文本表示，反之亦然，例如将 2 转换为 'two'。</p>
<p>基本的项目结构可能如下所示：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff"><span class="token inserted">+  |- webpack.config.js</span>
<span class="token inserted">+  |- package.json</span>
<span class="token inserted">+  |- /src</span>
<span class="token inserted">+    |- index.js</span>
<span class="token inserted">+    |- ref.json</span></code></pre>
<p>初始化 npm，安装 webpack 和 lodash：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> init -y
<span class="token function">npm</span> <span class="token function">install</span> --save-dev webpack lodash</code></pre>
<p><strong>src/ref.json</strong></p>
<pre><code class="hljs language-json"><span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    <span class="token property">"num"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token property">"word"</span><span class="token operator">:</span> <span class="token string">"One"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token property">"num"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token property">"word"</span><span class="token operator">:</span> <span class="token string">"Two"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token property">"num"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
    <span class="token property">"word"</span><span class="token operator">:</span> <span class="token string">"Three"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token property">"num"</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
    <span class="token property">"word"</span><span class="token operator">:</span> <span class="token string">"Four"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token property">"num"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>
    <span class="token property">"word"</span><span class="token operator">:</span> <span class="token string">"Five"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    <span class="token property">"num"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token property">"word"</span><span class="token operator">:</span> <span class="token string">"Zero"</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span></code></pre>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-js"><span class="token keyword">import</span> _ <span class="token keyword">from</span> <span class="token string">'lodash'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> numRef <span class="token keyword">from</span> <span class="token string">'./ref.json'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">numToWord</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> _<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>numRef<span class="token punctuation">,</span> <span class="token punctuation">(</span>accum<span class="token punctuation">,</span> ref<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> ref<span class="token punctuation">.</span>num <span class="token operator">===</span> num <span class="token operator">?</span> ref<span class="token punctuation">.</span>word <span class="token punctuation">:</span> accum<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">wordToNum</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> _<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>numRef<span class="token punctuation">,</span> <span class="token punctuation">(</span>accum<span class="token punctuation">,</span> ref<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> ref<span class="token punctuation">.</span>word <span class="token operator">===</span> word <span class="token operator">&#x26;&#x26;</span> word<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> ref<span class="token punctuation">.</span>num <span class="token punctuation">:</span> accum<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>这个 library 的调用规范如下：</p>
<ul>
<li><strong>ES2015 module import:</strong></li>
</ul>
<pre><code class="hljs language-js"><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> webpackNumbers <span class="token keyword">from</span> <span class="token string">'webpack-numbers'</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
webpackNumbers<span class="token punctuation">.</span><span class="token function">wordToNum</span><span class="token punctuation">(</span><span class="token string">'Two'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><strong>CommonJS module require:</strong></li>
</ul>
<pre><code class="hljs language-js"><span class="token keyword">const</span> webpackNumbers <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-numbers'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
webpackNumbers<span class="token punctuation">.</span><span class="token function">wordToNum</span><span class="token punctuation">(</span><span class="token string">'Two'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<ul>
<li><strong>AMD module require:</strong></li>
</ul>
<pre><code class="hljs language-js"><span class="token function">require</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'webpackNumbers'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>webpackNumbers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  webpackNumbers<span class="token punctuation">.</span><span class="token function">wordToNum</span><span class="token punctuation">(</span><span class="token string">'Two'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>consumer(使用者) 还可以通过一个 script 标签来加载和使用此 library：</p>
<pre><code class="hljs language-html"><span class="token doctype">&#x3C;!doctype html></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>html</span><span class="token punctuation">></span></span>
  ...
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://unpkg.com/webpack-numbers<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>script</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    <span class="token comment">// ...</span>
    <span class="token comment">// 全局变量</span>
    webpackNumbers<span class="token punctuation">.</span><span class="token function">wordToNum</span><span class="token punctuation">(</span><span class="token string">'Five'</span><span class="token punctuation">)</span>
    <span class="token comment">// window 对象中的属性</span>
    window<span class="token punctuation">.</span>webpackNumbers<span class="token punctuation">.</span><span class="token function">wordToNum</span><span class="token punctuation">(</span><span class="token string">'Five'</span><span class="token punctuation">)</span>
    <span class="token comment">// ...</span>
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<p>注意，我们还可以通过以下配置方式，将 library 暴露为：</p>
<ul>
<li>global 对象中的属性，用于 Node.js。</li>
<li><code>this</code> 对象中的属性。</li>
</ul>
<p>完整的 library 配置和代码，请查看 <a href="https://github.com/kalcifer/webpack-library-example">webpack-library-example</a>。</p>
<h2 id="base-configuration">基本配置 <a href="#base-configuration" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>现在，让我们以某种方式打包这个 library，能够实现以下几个目标：</p>
<ul>
<li>使用 <code>externals</code> 选项，避免将 <code>lodash</code> 打包到应用程序，而使用者会去加载它。</li>
<li>将 library 的名称设置为 <code>webpack-numbers</code>。</li>
<li>将 library 暴露为一个名为 <code>webpackNumbers</code> 的变量。</li>
<li>能够访问其他 Node.js 中的 library。</li>
</ul>
<p>此外，consumer(使用者) 应该能够通过以下方式访问 library：</p>
<ul>
<li>ES2015 模块。例如 <code>import webpackNumbers from 'webpack-numbers'</code>。</li>
<li>CommonJS 模块。例如 <code>require('webpack-numbers')</code>.</li>
<li>全局变量，在通过 <code>script</code> 标签引入时。</li>
</ul>
<p>我们可以从如下 webpack 基本配置开始：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>
  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    filename<span class="token punctuation">:</span> <span class="token string">'webpack-numbers.js'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h2 id="base-configuration-with-source-map">使用 source map 的基本配置 <a href="#base-configuration-with-source-map" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>source map 是有用的调试工具，可以查看压缩代码对应的原始代码。</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'source-map'</span>
<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>devtool <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  mode<span class="token punctuation">:</span> <span class="token string">'development'</span><span class="token punctuation">,</span>
  entry<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>
  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    filename<span class="token punctuation">:</span> <span class="token string">'webpack-numbers.js'</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  devtool<span class="token punctuation">,</span>
  optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    runtimeChunk<span class="token punctuation">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<blockquote>
<p> 关于 source map 配置和可用选项的更多信息，请参考 <a href="https://webpack.js.org/configuration/devtool/">devtool 配置</a></p>
<p>查看代码示例， 请参考 <a href="https://github.com/webpack/webpack/tree/master/examples/source-map">webpack 仓库</a></p>
</blockquote>
<h2 id="externalize-lodash">外部化 lodash <a href="#externalize-lodash" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>现在，如果执行 <code>webpack</code>，你会发现创建了一个体积相当大的文件。如果你查看这个文件，会看到 lodash 也被打包到代码中。在这种场景中，我们更倾向于把 <code>lodash</code> 当作 <code>peerDependency</code>。也就是说，consumer(使用者) 应该已经安装过 <code>lodash</code> 。因此，你就可以放弃控制此外部 library ，而是将控制权让给使用 library 的 consumer。</p>
<p>这可以使用 <code>externals</code> 配置来完成：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');

  module.exports = {
    entry: './src/index.js',
    output: {
      path: path.resolve(__dirname, 'dist'),
      filename: 'webpack-numbers.js',
    },
<span class="token inserted">+   externals: {</span>
<span class="token inserted">+     lodash: {</span>
<span class="token inserted">+       commonjs: 'lodash',</span>
<span class="token inserted">+       commonjs2: 'lodash',</span>
<span class="token inserted">+       amd: 'lodash',</span>
<span class="token inserted">+       root: '_',</span>
<span class="token inserted">+     },</span>
<span class="token inserted">+   },</span>
  };</code></pre>
<p>这意味着你的 library 需要一个名为 <code>lodash</code> 的依赖，这个依赖在 consumer 环境中必须存在且可用。</p>
<blockquote class="tip">
<p>注意，如果你仅计划将 library 用作另一个 webpack bundle 中的依赖模块，则可以直接将 <code>externals</code> 指定为一个数组。</p>
</blockquote>
<h2 id="external-limitations">外部化的限制 <a href="#external-limitations" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>对于想要实现从一个依赖中调用多个文件的那些 library：</p>
<pre><code class="hljs language-js"><span class="token keyword">import</span> <span class="token constant">A</span> <span class="token keyword">from</span> <span class="token string">'library/one'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token constant">B</span> <span class="token keyword">from</span> <span class="token string">'library/two'</span><span class="token punctuation">;</span>

<span class="token comment">// ...</span></code></pre>
<p>无法通过在 externals 中指定整个 <code>library</code> 的方式，将它们从 bundle 中排除。而是需要逐个或者使用一个正则表达式，来排除它们。</p>
<pre><code class="hljs language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  externals<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token string">'library/one'</span><span class="token punctuation">,</span>
    <span class="token string">'library/two'</span><span class="token punctuation">,</span>
    <span class="token comment">// 匹配以 "library/" 开始的所有依赖</span>
    <span class="token operator">/</span><span class="token operator">^</span>library\<span class="token regex">/.+$/</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h2 id="expose-the-library">暴露 library <a href="#expose-the-library" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>对于用法广泛的 library，我们希望它能够兼容不同的环境，例如 CommonJS，AMD，Node.js 或者作为一个全局变量。为了让你的 library 能够在各种使用环境中可用，需要在 <code>output</code> 中添加 <code>library</code> 属性：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');

  module.exports = {
    entry: './src/index.js',
    output: {
      path: path.resolve(__dirname, 'dist'),
      filename: 'webpack-numbers.js',
<span class="token inserted">+     library: 'webpackNumbers',</span>
    },
    externals: {
      lodash: {
        commonjs: 'lodash',
        commonjs2: 'lodash',
        amd: 'lodash',
        root: '_',
      },
    },
  };</code></pre>
<blockquote class="tip">
<p>注意，<code>library</code> 设置绑定到 <code>entry</code> 配置。对于大多数 library，指定一个入口起点就足够了。虽然 <a href="https://github.com/webpack/webpack/tree/master/examples/multi-part-library">一次打包暴露多个库</a> 也是也可以的，然而，通过 <a href="https://stackoverflow.com/questions/34072598/es6-exporting-importing-in-index-file">index script(索引脚本)（仅用于访问一个入口起点）</a> 暴露部分导出则更为简单。我们<strong>不推荐</strong>使用<code>数组</code>作为 library 的 <code>entry</code>。</p>
</blockquote>
<p>这会将你的 library bundle 暴露为名为 <code>webpackNumbers</code> 的全局变量，consumer 通过此名称来 import。为了让 library 和其他环境兼容，则需要在配置中添加 <code>libraryTarget</code> 属性。这个选项可以控制以多种形式暴露 library。</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');

  module.exports = {
    entry: './src/index.js',
    output: {
      path: path.resolve(__dirname, 'dist'),
      filename: 'webpack-numbers.js',
      library: 'webpackNumbers',
<span class="token inserted">+     libraryTarget: 'umd',</span>
    },
    externals: {
      lodash: {
        commonjs: 'lodash',
        commonjs2: 'lodash',
        amd: 'lodash',
        root: '_',
      },
    },
  };</code></pre>
<p>有以下几种方式暴露 library：</p>
<ul>
<li>变量：作为一个全局变量，通过 <code>script</code> 标签来访问（<code>libraryTarget:'var'</code>）。</li>
<li>this：通过 <code>this</code> 对象访问（<code>libraryTarget:'this'</code>）。</li>
<li>window：在浏览器中通过 <code>window</code> 对象访问（<code>libraryTarget:'window'</code>）。</li>
<li>UMD：在 AMD 或 CommonJS <code>require</code> 之后可访问（<code>libraryTarget:'umd'</code>）。</li>
</ul>
<p>如果设置了 <code>library</code> 但没有设置 <code>libraryTarget</code>，则 <code>libraryTarget</code> 默认指定为 <code>var</code>，详细说明请查看 <a href="/configuration/output">output </a> 文档。查看 <a href="/configuration/output#outputlibrarytarget"><code>output.libraryTarget</code></a> 文档，以获取所有可用选项的详细列表。</p>
<blockquote class="warning">
<p>在 webpack v3.5.5 中，使用 <code>libraryTarget: { root:'_' }</code> 将无法正常工作（参考 <a href="https://github.com/webpack/webpack/issues/4824">issue 4824</a>) 所述）。然而，可以设置 <code>libraryTarget: { var: '_' }</code> 来将 library 作为全局变量。</p>
</blockquote>
<h3 id="final-steps">最终步骤 <a href="#final-steps" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>遵循 <a href="/guides/production">生产环境</a> 指南中提到的步骤，来优化生产环境下的输出结果。那么，我们还需要将生成 bundle 的文件路径，添加到 <code>package.json</code> 中的 <code>main</code> 字段中。</p>
<p><strong>package.json</strong></p>
<pre><code class="hljs language-json"><span class="token punctuation">{</span>
  ...
  <span class="token property">"main"</span><span class="token operator">:</span> <span class="token string">"dist/webpack-numbers.js"</span><span class="token punctuation">,</span>
  ...
<span class="token punctuation">}</span></code></pre>
<p>或者，按照这个 <a href="https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md#typical-usage">指南</a>，将其添加为标准模块：</p>
<pre><code class="hljs language-json"><span class="token punctuation">{</span>
  ...
  <span class="token property">"module"</span><span class="token operator">:</span> <span class="token string">"src/index.js"</span><span class="token punctuation">,</span>
  ...
<span class="token punctuation">}</span></code></pre>
<p>这里的 key(键) <code>main</code> 是参照 <a href="https://docs.npmjs.com/files/package.json#main"><code>package.json</code> 标准</a>，而 <code>module</code> 是参照 <a href="https://github.com/dherman/defense-of-dot-js/blob/master/proposal.md">一个</a><a href="https://github.com/rollup/rollup/wiki/pkg.module">提案</a>，此提案允许 JavaScript 生态系统升级使用 ES2015 模块，而不会破坏向后兼容性。</p>
<blockquote class="warning">
<p><code>module</code> 属性应指向一个使用 ES2015 模块语法的脚本，但不包括浏览器或 Node.js 尚不支持的其他语法特性。这使得 webpack 本身就可以解析模块语法，如果用户只用到 library 的某些部分，则允许通过 <a href="https://webpack.docschina.org/guides/tree-shaking/">tree shaking</a> 打包更轻量的包。</p>
</blockquote>
<p>现在，你可以 <a href="https://docs.npmjs.com/getting-started/publishing-npm-packages">将其发布为一个 npm package</a>，并且在 <a href="https://unpkg.com/#/">unpkg.com</a> 找到它，并分发给你的用户。</p>
<blockquote class="tip">
<p>为了暴露和 library 关联着的样式表，你应该使用 <a href="/plugins/mini-css-extract-plugin"><code>MiniCssExtractPlugin</code></a>。然后，用户可以像使用其他样式表一样使用和加载这些样式表。</p>
</blockquote>
<h1 id="环境变量">环境变量<a href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p>想要消除 <code>webpack.config.js</code> 在 <a href="/guides/development">开发环境</a> 和 <a href="/guides/production">生产环境</a> 之间的差异，你可能需要环境变量(environment variable)。</p>
<blockquote class="tip">
<p>webpack 环境变量，与操作系统中的 <code>bash</code> 和 <code>CMD.exe</code> 这些 shell <a href="https://en.wikipedia.org/wiki/Environment_variable">环境变量</a> 不同。</p>
</blockquote>
<p>webpack 命令行 <a href="/api/cli/#environment-options">环境配置</a> 的 <code>--env</code> 参数，可以允许你传入任意数量的环境变量。而在 <code>webpack.config.js</code> 中可以访问到这些环境变量。例如，<code>--env.production</code> 或 <code>--env.NODE_ENV=local</code>（<code>NODE_ENV</code> 通常约定用于定义环境类型，查看 <a href="https://dzone.com/articles/what-you-should-know-about-node-env">这里</a>）。</p>
<pre><code class="hljs language-bash">webpack --env.NODE_ENV<span class="token operator">=</span>local --env.production --progress</code></pre>
<blockquote class="tip">
<p>如果设置 <code>env</code> 变量，却没有赋值，<code>--env.production</code> 默认表示将 <code>--env.production</code> 设置为 <code>true</code>。还有许多其他可以使用的语法。更多详细信息，请查看 <a href="/api/cli/#environment-options">webpack CLI</a> 文档。</p>
</blockquote>
<p>对于我们的 webpack 配置，有一个必须要修改之处。通常，<code>module.exports</code> 指向配置对象。要使用 <code>env</code> 变量，你必须将 <code>module.exports</code> 转换成一个函数：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> env <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// Use env.&#x3C;YOUR VARIABLE> here:</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'NODE_ENV: '</span><span class="token punctuation">,</span> env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'local'</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Production: '</span><span class="token punctuation">,</span> env<span class="token punctuation">.</span>production<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    entry<span class="token punctuation">:</span> <span class="token string">'./src/index.js'</span><span class="token punctuation">,</span>
    output<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>
      path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h1 id="构建性能">构建性能<a href="#%E6%9E%84%E5%BB%BA%E6%80%A7%E8%83%BD" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p>本指南包含一些改进构建/编译性能的实用技巧。</p>
<hr>
<h2 id="general">通用环境 <a href="#general" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>无论你是在 <a href="/guides/development">开发环境</a> 还是在 <a href="/guides/production">生产环境</a> 下运行构建脚本，以下最佳实践都会有所帮助。</p>
<h3 id="stay-up-to-date">更新到最新版本 <a href="#stay-up-to-date" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>使用最新的 webpack 版本。我们会经常进行性能优化。webpack 的最新稳定版本是：</p>
<p><a href="https://github.com/webpack/webpack/releases"><img src="https://img.shields.io/github/package-json/v/webpack/webpack.svg?label=webpack&#x26;style=flat-square&#x26;maxAge=3600" alt="latest webpack version"></a></p>
<p>将 <strong>Node.js</strong> 更新到最新版本，也有助于提高性能。除此之外，将你的 package 管理工具（例如 <code>npm</code> 或者 <code>yarn</code>）更新到最新版本，也有助于提高性能。较新的版本能够建立更高效的模块树以及提高解析速度。</p>
<h3 id="loaders">loader <a href="#loaders" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>将 loader 应用于最少数量的必要模块。而非如下:</p>
<pre><code class="hljs language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>
        loader<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>通过使用 <code>include</code> 字段，仅将 loader 应用在实际需要将其转换的模块：</p>
<pre><code class="hljs language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">//...</span>
  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>
        include<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'src'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        loader<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h3 id="bootstrap">引导(bootstrap) <a href="#bootstrap" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>每个额外的 loader/plugin 都有其启动时间。尽量少地使用工具。</p>
<h3 id="resolving">解析 <a href="#resolving" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>以下步骤可以提高解析速度：</p>
<ul>
<li>减少 <code>resolve.modules</code>, <code>resolve.extensions</code>, <code>resolve.mainFiles</code>, <code>resolve.descriptionFiles</code> 中条目数量，因为他们会增加文件系统调用的次数。</li>
<li>如果你不使用 symlinks（例如 <code>npm link</code> 或者 <code>yarn link</code>），可以设置 <code>resolve.symlinks: false</code>。</li>
<li>如果你使用自定义 resolve plugin 规则，并且没有指定 context 上下文，可以设置 <code>resolve.cacheWithContext: false</code>。</li>
</ul>
<h3 id="dlls">dll <a href="#dlls" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>使用 <code>DllPlugin</code> 为更改不频繁的代码生成单独的编译结果。这可以提高应用程序的编译速度，尽管它增加了构建过程的复杂度。</p>
<h3 id="smaller--faster">小即是快(smaller = faster) <a href="#smaller--faster" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>减少编译结果的整体大小，以提高构建性能。尽量保持 chunk 体积小。</p>
<ul>
<li>使用数量更少/体积更小的 library。</li>
<li>在多页面应用程序中使用 <code>SplitChunksPlugin</code>。</li>
<li>在多页面应用程序中使用 <code>SplitChunksPlugin</code>，并开启 <code>async</code> 模式。</li>
<li>移除未引用代码。</li>
<li>只编译你当前正在开发的那些代码。</li>
</ul>
<h3 id="worker-pool">worker 池(worker pool) <a href="#worker-pool" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p><code>thread-loader</code> 可以将非常消耗资源的 loader 分流给一个 worker pool。</p>
<blockquote class="warning">
<p>不要使用太多的 worker，因为 Node.js 的 runtime 和 loader 都有启动开销。最小化 worker 和 main process(主进程) 之间的模块传输。进程间通讯(IPC, inter process communication)是非常消耗资源的。</p>
</blockquote>
<h3 id="persistent-cache">持久化缓存 <a href="#persistent-cache" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>使用 <code>cache-loader</code> 启用持久化缓存。使用 <code>package.json</code> 中的 <code>"postinstall"</code> 清除缓存目录。</p>
<blockquote class="tip">
<p>我们支持 yarn PnP v3 <a href="https://next.yarnpkg.com/features/pnp"><code>yarn 2 berry</code></a>，来进行持久缓存</p>
</blockquote>
<h3 id="custom-pluginsloaders">自定义 plugin/loader <a href="#custom-pluginsloaders" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>对它们进行概要分析，以免在此处引入性能问题。</p>
<h3 id="progress-plugin">Progress plugin <a href="#progress-plugin" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>将 <code>ProgressPlugin</code> 从 webpack 中删除，可以缩短构建时间。请注意，<code>ProgressPlugin</code> 可能不会为快速构建提供太多价值，因此，请权衡利弊再使用。</p>
<hr>
<h2 id="development">开发环境 <a href="#development" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>以下步骤对于<em>开发环境</em>特别有帮助。</p>
<h3 id="incremental-builds">增量编译 <a href="#incremental-builds" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>使用 webpack 的 watch mode(监听模式)。而不使用其他工具来 watch 文件和调用 webpack 。内置的 watch mode 会记录时间戳并将此信息传递给 compilation 以使缓存失效。</p>
<p>在某些配置环境中，watch mode 会回退到 poll mode(轮询模式)。监听许多文件会导致 CPU 大量负载。在这些情况下，可以使用 <code>watchOptions.poll</code> 来增加轮询的间隔时间。</p>
<h3 id="compile-in-memory">在内存中编译 <a href="#compile-in-memory" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>下面几个工具通过在内存中（而不是写入磁盘）编译和 serve 资源来提高性能：</p>
<ul>
<li><code>webpack-dev-server</code></li>
<li><code>webpack-hot-middleware</code></li>
<li><code>webpack-dev-middleware</code></li>
</ul>
<h3 id="statstojson-speed">stats.toJson 加速 <a href="#statstojson-speed" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>webpack 4 默认使用 <code>stats.toJson()</code> 输出大量数据。除非在增量步骤中做必要的统计，否则请避免获取 <code>stats</code> 对象的部分内容。<code>webpack-dev-server</code> 在 v3.1.3 以后的版本，包含一个重要的性能修复，即最小化每个增量构建步骤中，从 <code>stats</code> 对象获取的数据量。</p>
<h3 id="devtool">Devtool <a href="#devtool" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>需要注意的是不同的 <code>devtool</code> 设置，会导致性能差异。</p>
<ul>
<li><code>"eval"</code> 具有最好的性能，但并不能帮助你转译代码。</li>
<li>如果你能接受稍差一些的 map 质量，可以使用 <code>cheap-source-map</code> 变体配置来提高性能</li>
<li>使用 <code>eval-source-map</code> 变体配置进行增量编译。</li>
</ul>
<p>=> 在大多数情况下，最佳选择是 <code>eval-cheap-module-source-map</code>。</p>
<h3 id="avoid-production-specific-tooling">避免在生产环境下才会用到的工具 <a href="#avoid-production-specific-tooling" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>某些 utility, plugin 和 loader 都只用于生产环境。例如，在开发环境下使用 <code>TerserPlugin</code> 来 minify(压缩) 和 mangle(混淆破坏) 代码是没有意义的。通常在开发环境下，应该排除以下这些工具：</p>
<ul>
<li><code>TerserPlugin</code></li>
<li><code>ExtractTextPlugin</code></li>
<li><code>[hash]</code>/<code>[chunkhash]</code></li>
<li><code>AggressiveSplittingPlugin</code></li>
<li><code>AggressiveMergingPlugin</code></li>
<li><code>ModuleConcatenationPlugin</code></li>
</ul>
<h3 id="minimal-entry-chunk">最小化 entry chunk  <a href="#minimal-entry-chunk" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>webpack 只会在文件系统中输出已经更新的 chunk。某些配置选项（HMR, <code>output.chunkFilename</code> 的 <code>[name]</code>/<code>[chunkhash]</code>, <code>[hash]</code>）来说，除了对已经更新的 chunk 无效之外，对于 entry chunk 也不会生效。</p>
<p>确保在生成 entry chunk 时，尽量减少其体积以提高性能。下面的代码块将只提取包含 runtime 的 chunk，<em>其他 chunk 都作为其子 chunk</em>:</p>
<pre><code class="hljs language-js"><span class="token keyword">new</span> <span class="token class-name">CommonsChunkPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  name<span class="token punctuation">:</span> <span class="token string">'manifest'</span><span class="token punctuation">,</span>
  minChunks<span class="token punctuation">:</span> <span class="token number">Infinity</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h3 id="avoid-extra-optimization-steps">避免额外的优化步骤 <a href="#avoid-extra-optimization-steps" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>webpack 通过执行额外的算法任务，来优化输出结果的体积和加载性能。这些优化适用于小型代码库，但是在大型代码库中却非常耗费性能：</p>
<pre><code class="hljs language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  optimization<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    removeAvailableModules<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    removeEmptyChunks<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    splitChunks<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h3 id="output-without-path-info">输出结果不携带路径信息 <a href="#output-without-path-info" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>webpack 会在输出的 bundle 中生成路径信息。然而，在打包数千个模块的项目中，这会导致造成垃圾回收性能压力。在 <code>options.output.pathinfo</code> 设置中关闭：</p>
<pre><code class="hljs language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    pathinfo<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h3 id="nodejs-versions-8910-9111">Node.js 版本 8.9.10-9.11.1 <a href="#nodejs-versions-8910-9111" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p> Node.js v8.9.10 - v9.11.1 中的 ES2015 <code>Map</code> 和 <code>Set</code> 实现，存在 <a href="https://github.com/nodejs/node/issues/19769">性能回退</a>。webpack 大量地使用这些数据结构，因此这次回退也会影响编译时间。</p>
<p>之前和之后的 Node.js 版本不受影响。</p>
<h3 id="typescript-loader">TypeScript loader <a href="#typescript-loader" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>你可以为 loader 传入 <code>transpileOnly</code> 选项，以缩短使用 <code>ts-loader</code> 时的构建时间。使用此选项，会关闭类型检查。如果要再次开启类型检查，请使用 <a href="https://www.npmjs.com/package/fork-ts-checker-webpack-plugin"><code>ForkTsCheckerWebpackPlugin</code></a>。使用此插件会将检查过程移至单独的进程，可以加快 TypeScript 的类型检查和 ESLint 插入的速度。</p>
<pre><code class="hljs language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  test<span class="token punctuation">:</span> <span class="token regex">/\.tsx?$/</span><span class="token punctuation">,</span>
  use<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      loader<span class="token punctuation">:</span> <span class="token string">'ts-loader'</span><span class="token punctuation">,</span>
      options<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        transpileOnly<span class="token punctuation">:</span> <span class="token boolean">true</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<blockquote class="tip">
<p>这是一个关于 <code>ts-loader</code> <a href="https://github.com/TypeStrong/ts-loader/tree/master/examples/fork-ts-checker-webpack-plugin">完整示例</a>的 Github 仓库。</p>
</blockquote>
<hr>
<h2 id="production">生产环境 <a href="#production" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>以下步骤对于<em>生产环境</em>特别有帮助。</p>
<blockquote class="warning">
<p><strong>不要为了很小的性能收益，牺牲应用程序的质量！</strong>注意，在大多数情况下，优化代码质量比构建性能更重要。</p>
</blockquote>
<h3 id="multiple-compilations">多个 compilation 对象 <a href="#multiple-compilations" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>在创建多个 compilation 时，以下工具可以帮助到你：</p>
<ul>
<li><a href="https://github.com/trivago/parallel-webpack"><code>parallel-webpack</code></a>：它允许在一个 worker 池中运行 compilation。</li>
<li><code>cache-loader</code>：可以在多个 compilation 之间共享缓存。</li>
</ul>
<h3 id="source-maps">Source Maps <a href="#source-maps" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>source map 相当消耗资源。你真的需要它们？</p>
<hr>
<h2 id="specific-tooling-issues">工具相关问题 <a href="#specific-tooling-issues" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>下列工具存在某些可能会降低构建性能的问题：</p>
<h3 id="babel">Babel <a href="#babel" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<ul>
<li>最小化项目中的 preset/plugin 数量。</li>
</ul>
<h3 id="typescript">TypeScript <a href="#typescript" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<ul>
<li>在单独的进程中使用 <code>fork-ts-checker-webpack-plugin</code> 进行类型检查。</li>
<li>配置 loader 跳过类型检查。</li>
<li>使用 <code>ts-loader</code> 时，设置 <code>happyPackMode: true</code> / <code>transpileOnly: true</code>。</li>
</ul>
<h3 id="sass">Sass <a href="#sass" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<ul>
<li><code>node-sass</code> 中有个来自 Node.js 线程池的阻塞线程的 bug。 当使用 <code>thread-loader</code> 时，需要设置 <code>workerParallelJobs: 2</code>。</li>
</ul>
<h1 id="内容安全策略">内容安全策略<a href="#%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p>webpack 能够为其加载的所有脚本添加 <code>nonce</code>。要启用此功能，需要在引入的入口脚本中设置一个 <code>__webpack_nonce__</code> 变量。应该为每个唯一的页面视图生成和提供一个唯一的基于 hash 的 nonce，这就是为什么 <code>__webpack_nonce__</code> 要在入口文件中指定，而不是在配置中指定的原因。注意，<code>nonce</code> 应该是一个 base64 编码的字符串。</p>
<h2 id="examples">示例 <a href="#examples" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>在 entry 文件中：</p>
<pre><code class="hljs language-js"><span class="token comment">// ...</span>
__webpack_nonce__ <span class="token operator">=</span> <span class="token string">'c29tZSBjb29sIHN0cmluZyB3aWxsIHBvcCB1cCAxMjM='</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span></code></pre>
<h2 id="enabling-csp">启用 CSP <a href="#enabling-csp" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>注意，默认情况下不启用 CSP。需要与文档(document)一起发送相应的 <code>CSP</code> header 或 meta 标签 <code>&#x3C;meta http-equiv="Content-Security-Policy" ...></code>，以告知浏览器启用 CSP。以下是一个包含 CDN 白名单 URL 的 CSP header 的示例：</p>
<pre><code class="hljs language-html">Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com;</code></pre>
<p>有关 CSP 和 <code>nonce</code> 属性的更多信息，请查看页面底部的<strong>延伸阅读</strong>部分。</p>
<h1 id="开发---Vagrant">开发 - Vagrant<a href="#%E5%BC%80%E5%8F%91---Vagrant" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p>如果你在开发一个更加高级的项目，并且使用 <a href="https://www.vagrantup.com/">Vagrant</a> 来实现在虚拟机(Virtual Machine)上运行你的开发环境，那你可能会需要在虚拟机中运行 webpack。</p>
<h2 id="configuring-the-project">配置项目 <a href="#configuring-the-project" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>首先，确保 <code>Vagrantfile</code> 拥有一个静态 IP。</p>
<pre><code class="hljs language-ruby"><span class="token constant">Vagrant</span><span class="token punctuation">.</span><span class="token function">configure</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span> <span class="token keyword">do</span> <span class="token operator">|</span>config<span class="token operator">|</span>
  config<span class="token punctuation">.</span>vm<span class="token punctuation">.</span>network <span class="token symbol">:private_network</span><span class="token punctuation">,</span> ip<span class="token punctuation">:</span> <span class="token string">"10.10.10.61"</span>
<span class="token keyword">end</span></code></pre>
<p>然后，在项目中安装 webpack 和 webpack-dev-server。</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev webpack webpack-dev-server</code></pre>
<p>确保提供一个 <code>webpack.config.js</code> 配置文件。如果还没有准备，下面的示例代码可以作为起步的最简配置：</p>
<pre><code class="hljs language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  context<span class="token punctuation">:</span> __dirname<span class="token punctuation">,</span>
  entry<span class="token punctuation">:</span> <span class="token string">'./app.js'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>然后，创建一个 <code>index.html</code> 文件。其中的 <code>script</code> 标签应当指向你的 bundle。如果没有在配置中指定 <code>output.filename</code>，其默认值是 <code>bundle.js</code>。</p>
<pre><code class="hljs language-html"><span class="token doctype">&#x3C;!doctype html></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>html</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/bundle.js<span class="token punctuation">"</span></span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>script</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>head</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>body</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;</span>h2</span><span class="token punctuation">></span></span>Heey!<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>h2</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&#x3C;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<p>注意，你还需要创建一个 <code>app.js</code> 文件。</p>
<h2 id="running-the-server">启动服务器 <a href="#running-the-server" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>现在，我们启动服务器：</p>
<pre><code class="hljs language-bash">webpack-dev-server --host 0.0.0.0 --public 10.10.10.61:8080 --watch-poll</code></pre>
<p>默认只允许从 localhost 访问服务器。所以我们需要修改 <code>--host</code> 参数，
以允许在我们的宿主 PC 上访问。</p>
<p>webpack-dev-server 会在包中引入一个脚本，此脚本连接到 WebSocket，这样可以在任何文件修改时，触发重新加载应用程序。
<code>--public</code> 标记可以确保脚本知道从哪里查找 WebSocket。默认情况下，服务器会使用 <code>8080</code> 端口，
因此也需要在这里指定。</p>
<p><code>--watch-poll</code> 可以确保 webpack 能够检测到文件更改。webpack 默认会监听文件系统触发的相关事件，
但是 VirtualBox 使用默认配置会有许多问题。</p>
<p>现在服务器应该能够通过 <code>http://10.10.10.61:8080</code> 访问了。修改 <code>app.js</code>，应用程序就会实时重新加载。</p>
<h2 id="advanced-usage-with-nginx">配合 nginx 的高级用法 <a href="#advanced-usage-with-nginx" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>为了更好的模拟类生产环境(production-like environment)，还可以用 nginx 来代理 webpack-dev-server。</p>
<p>在你的 nginx 配置文件中，加入下面代码：</p>
<pre><code class="hljs language-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>
  <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>
    <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">8080</span><span class="token punctuation">;</span>
    <span class="token keyword">proxy_http_version</span> <span class="token number">1.1</span><span class="token punctuation">;</span>
    <span class="token keyword">proxy_set_header</span> Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>
    <span class="token keyword">proxy_set_header</span> Connection <span class="token string">"upgrade"</span><span class="token punctuation">;</span>
    <span class="token keyword">error_page</span> <span class="token number">502</span> @start<span class="token operator">-</span>webpack<span class="token operator">-</span>dev<span class="token operator">-</span><span class="token keyword">server</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">location</span> @start<span class="token operator">-</span>webpack<span class="token operator">-</span>dev<span class="token operator">-</span><span class="token keyword">server</span> <span class="token punctuation">{</span>
    <span class="token keyword">default_type</span> text<span class="token operator">/</span>plain<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">502</span> <span class="token string">"Please start the webpack-dev-server first."</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><code>proxy_set_header</code> 这几行配置很重要，因为它们能够使 WebSocket 正常运行。</p>
<p>然后 webpack-dev-server 启动命令可以修改为：</p>
<pre><code class="hljs language-bash">webpack-dev-server --public 10.10.10.61 --watch-poll</code></pre>
<p>现在只能通过 <code>127.0.0.1</code> 访问服务，这点关系不大，因为 ngnix 能够使得你的 PC 电脑能访问到服务器。</p>
<h2 id="conclusion">结论 <a href="#conclusion" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>我们能够从静态 IP 访问 Vagrant box，然后使 webpack-dev-server 可以公开访问，以便浏览器可以访问到它。然后，我们解决了 VirtualBox 不发送到文件系统事件的常见问题，此问题会导致服务器无法重新加载文件更改。</p>
<h1 id="依赖管理">依赖管理<a href="#%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<blockquote>
<p>es6 modules</p>
<p>commonjs</p>
<p>amd</p>
</blockquote>
<h2 id="require-with-expression">带表达式的 require 语句 <a href="#require-with-expression" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>如果你的 request 含有表达式(expressions)，就会创建一个上下文(context)，因为在编译时(compile time)并不清楚 <strong>具体</strong> 导入哪个模块。</p>
<p>示例，考虑到我们有包含 <code>.esj</code> 文件的如下目录结构：</p>
<pre><code class="hljs language-bash">example_directory
│
└───template
│   │   table.ejs
│   │   table-row.ejs
│   │
│   └───directory
│       │   another.ejs</code></pre>
<p>当台下的 <code>require()</code> 调用被评估解析：</p>
<pre><code class="hljs language-javascript"><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./template/'</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'.ejs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>webpack 解析 <code>require()</code> 调用，然后提取出如下一些信息：</p>
<pre><code class="hljs language-code">Directory: ./template
Regular expression: /^.*\.ejs$/
</code></pre>
<p><strong>context module</strong></p>
<p>会生成一个 context module(上下文模块)。会生成一个 context module(上下文模块)。它包含 <strong>目录下的所有模块</strong> 的引用，如果一个 request 符合正则表达式，就能 require 进来。该context module包含一个map（映射）对象，会把requests翻译成对应的模块id。（译者注：request参考<a href="https://webpack.docschina.org/glossary/">概念术语</a> ）</p>
<p>示例map（映射）:</p>
<pre><code class="hljs language-json"><span class="token punctuation">{</span>
  <span class="token property">"./table.ejs"</span><span class="token operator">:</span> <span class="token number">42</span><span class="token punctuation">,</span>
  <span class="token property">"./table-row.ejs"</span><span class="token operator">:</span> <span class="token number">43</span><span class="token punctuation">,</span>
  <span class="token property">"./directory/another.ejs"</span><span class="token operator">:</span> <span class="token number">44</span>
<span class="token punctuation">}</span></code></pre>
<p>此 context module 还包含一些访问这个 map 对象的 runtime 逻辑。</p>
<p>这意味着 webpack 能够支持动态地 require，但会导致所有可能用到的模块都包含在 bundle 中。</p>
<h2 id="requirecontext"><code>require.context</code> <a href="#requirecontext" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>你还可以通过 <code>require.context()</code> 函数来创建自己的 context。</p>
<p>可以给这个函数传入三个参数：一个要搜索的目录，一个标记表示是否还搜索其子目录，
以及一个匹配文件的正则表达式。</p>
<p>webpack 会在构建中解析代码中的 <code>require.context()</code> 。</p>
<p>语法如下：</p>
<pre><code class="hljs language-javascript">require<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span>directory<span class="token punctuation">,</span> useSubdirectories <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> regExp <span class="token operator">=</span> <span class="token regex">/^\.\/.*$/</span><span class="token punctuation">,</span> mode <span class="token operator">=</span> <span class="token string">'sync'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>示例：</p>
<pre><code class="hljs language-javascript">require<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span><span class="token string">'./test'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token regex">/\.test\.js$/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//（创建出）一个 context，其中文件来自 test 目录，request 以 `.test.js` 结尾。</span></code></pre>
<pre><code class="hljs language-javascript">require<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span><span class="token string">'../'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token regex">/\.stories\.js$/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// （创建出）一个 context，其中所有文件都来自父文件夹及其所有子级文件夹，request 以 `.stories.js` 结尾。</span></code></pre>
<blockquote class="warning">
<p>传递给 <code>require.context</code> 的参数必须是字面量(literal)！</p>
</blockquote>
<h3 id="context-module-api">context module API <a href="#context-module-api" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>一个 context module 会导出一个（require）函数，此函数可以接收一个参数：request。</p>
<p>此导出函数有三个属性：<code>resolve</code>, <code>keys</code>, <code>id</code>。</p>
<ul>
<li><code>resolve</code> 是一个函数，它返回 request 被解析后得到的模块 id。</li>
<li><code>keys</code> 也是一个函数，它返回一个数组，由所有可能被此 context module 处理的请求（译者注：参考下面第二段代码中的 key）组成。</li>
</ul>
<p>如果想引入一个文件夹下面的所有文件，或者引入能匹配一个正则表达式的所有文件，这个功能就会很有帮助，例如：</p>
<pre><code class="hljs language-javascript"><span class="token keyword">function</span> <span class="token function">importAll</span> <span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  r<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">importAll</span><span class="token punctuation">(</span>require<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span><span class="token string">'../components/'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token regex">/\.js$/</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<pre><code class="hljs language-javascript"><span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">importAll</span> <span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  r<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">=></span> cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">r</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">importAll</span><span class="token punctuation">(</span>require<span class="token punctuation">.</span><span class="token function">context</span><span class="token punctuation">(</span><span class="token string">'../components/'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token regex">/\.js$/</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 在构建时(build-time)，所有被 require 的模块都会被填充到 cache 对象中。</span></code></pre>
<ul>
<li><code>id</code> 是 context module 的模块 id. 它可能在你使用 <code>module.hot.accept</code> 时会用到。</li>
</ul>
<h1 id="安装">安装<a href="#%E5%AE%89%E8%A3%85" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p>本指南介绍了安装 webpack 的各种方法。</p>
<h2 id="prerequisites">前提条件 <a href="#prerequisites" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>在开始之前，请确保安装了 <a href="https://nodejs.org/en/">Node.js</a> 的最新版本。使用 Node.js 最新的长期支持版本(LTS - Long Term Support)，是理想的起步。
使用旧版本，你可能遇到各种问题，因为它们可能缺少 webpack 功能，
或者缺少相关 package。</p>
<h2 id="local-installation">本地安装 <a href="#local-installation" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>最新的 webpack 正式版本是：</p>
<p><a href="https://github.com/webpack/webpack/releases"><img src="https://img.shields.io/npm/v/webpack.svg?label=webpack&#x26;style=flat-square&#x26;maxAge=3600" alt="GitHub release"></a></p>
<p>要安装最新版本或特定版本，请运行以下命令之一：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev webpack
<span class="token comment"># 或指定版本</span>
<span class="token function">npm</span> <span class="token function">install</span> --save-dev webpack@<span class="token operator">&#x3C;</span>version<span class="token operator">></span></code></pre>
<blockquote class="tip">
<p>是否使用 <code>--save-dev</code> 取决于你的应用场景。假设你仅使用 webpack 进行构建操作，那么建议你在安装时使用 <code>--save-dev</code> 选项，因为可能你不需要在生产环境上使用 webpack。如果需要应用于生产环境，请忽略 <code>--save-dev</code> 选项。</p>
</blockquote>
<p>如果你使用 webpack v4+ 版本，你还需要安装 <a href="/api/cli/">CLI</a>。</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev webpack-cli</code></pre>
<p>对于大多数项目，我们建议本地安装。这可以在引入重大更新(breaking change)版本时，更容易分别升级项目。
通常会通过运行一个或多个 <a href="https://docs.npmjs.com/misc/scripts">npm scripts</a> 以在本地 <code>node_modules</code> 目录中查找安装的 webpack，
来运行 webpack：</p>
<pre><code class="hljs language-json"><span class="token property">"scripts"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
	<span class="token property">"build"</span><span class="token operator">:</span> <span class="token string">"webpack --config webpack.config.js"</span>
<span class="token punctuation">}</span></code></pre>
<blockquote class="tip">
<p>想要运行本地安装的 webpack，你可以通过 <code>node_modules/.bin/webpack</code> 来访问它的二进制版本。另外，如果你使用的是 npm v5.2.0 或更高版本，则可以运行 'npx webpack' 来执行。</p>
</blockquote>
<h2 id="global-installation">全局安装 <a href="#global-installation" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>通过以下 NPM 安装方式，可以使 <code>webpack</code> 在全局环境下可用：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --global webpack</code></pre>
<blockquote class="warning">
<p><strong>不推荐</strong> 全局安装 webpack。这会将你项目中的 webpack 锁定到指定版本，并且在使用不同的 webpack 版本的项目中，
可能会导致构建失败。</p>
</blockquote>
<h2 id="bleeding-edge">最新体验版本 <a href="#bleeding-edge" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>如果你热衷于使用最新版本的 webpack，你可以使用以下命令安装 beta 版本，
或者直接从 webpack 的仓库中安装：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev webpack@next
<span class="token comment"># 或指定的 tag/分支</span>
<span class="token function">npm</span> <span class="token function">install</span> --save-dev webpack/webpack<span class="token comment">#&#x3C;tagname/branchname></span></code></pre>
<blockquote class="warning">
<p>安装这些最新体验版本时要小心！它们可能仍然包含 bug，因此不应该用于生产环境。</p>
</blockquote>
<h1 id="脚手架">脚手架<a href="#%E8%84%9A%E6%89%8B%E6%9E%B6" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p>首次设置复杂的 webpack 配置可能会很困难。并且编写高级配置来优化性能会更加困难。下面提供的 <code>init</code> 能力，可以让我们使用可自定义的第三方初始化包，来创建 webpack 配置。</p>
<h2 id="creating-a-scaffold">创建脚手架 <a href="#creating-a-scaffold" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>在编写 <code>webpack-cli</code> 脚手架之前，请先考虑下要实现的目标和要使用的群体：</p>
<ul>
<li>是否需要实现一个可被多种应用程序和项目使用的通用脚手架？</li>
<li>是否需要脚手架支持特定内容，例如同时编写 webpack.config.js 和框架代码的脚手架？</li>
<li>谁是潜在的用户，脚手架用户将会有什么样的用户体验？</li>
</ul>
<p><code>webpack-cli</code> 提供了一种交互式体验，可以对应地自定义输出。例如，询问类似 "你的入口起点是什么？" 这样的问题。</p>
<h3 id="writing-a-scaffold">编写脚手架 <a href="#writing-a-scaffold" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>如果你想要学习如何编写脚手架，这里有许多资源可以参考，可以阅读 <a href="/contribute/writing-a-scaffold/">编写脚手架</a> 教程作为开始。</p>
<p><code>webpack-scaffold</code> 是用于创建脚手架的工具套件。它包含一些可用于创建脚手架的功能。</p>
<h3 id="running-a-scaffold">执行脚手架 <a href="#running-a-scaffold" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>可以使用 <code>webpack-cli init</code> 执行脚手架：</p>
<pre><code class="hljs language-bash">webpack-cli init <span class="token operator">&#x3C;</span>your-scaffold<span class="token operator">></span></code></pre>
<h4 id="running-a-scaffold-locally">在本地运行脚手架 <a href="#running-a-scaffold-locally" aria-hidden="true"><span class="icon icon-link"></span></a></h4>
<p>当脚手架 package 位于本地文件系统中时，应将 <code>init</code> 指向其路径：</p>
<pre><code class="hljs language-bash">webpack-cli init path/to/your/scaffold</code></pre>
<p>或者，还可以创建一个全局模块并符号链接(symlink)到本地​​模块：</p>
<ul>
<li>使用 npm</li>
</ul>
<pre><code class="hljs language-bash"><span class="token function">cd</span> path/to/my-scaffold
<span class="token function">npm</span> <span class="token function">link</span>
webpack-cli init my-scaffold</code></pre>
<ul>
<li>使用 yarn</li>
</ul>
<pre><code class="hljs language-bash"><span class="token function">cd</span> path/to/my-scaffold
yarn <span class="token function">link</span>
webpack-cli init my-scaffold</code></pre>
<h4 id="running-a-scaffold-from-npm">从 npm 运行脚手架 <a href="#running-a-scaffold-from-npm" aria-hidden="true"><span class="icon icon-link"></span></a></h4>
<p>如果可以从 npm 获得此 package，则其名称必须以 <code>webpack-scaffold</code> 开头，并且可以通过运行以下命令来使用：</p>
<pre><code class="hljs language-bash">webpack-cli init webpack-scaffold-yourpackage</code></pre>
<h2 id="api">API <a href="#api" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>要创建一个<code>脚手架</code>，必须创建一个 <a href="http://yeoman.io/authoring/"><code>yeoman-generator</code></a>。感谢它的存在，现在可以选择在它的基础上扩展出你自己的 generator，其中同样包括 Yeoman API 中提供的方法。值得注意的是，我们支持常规 webpack 配置的所有属性。为了实现这一点，需要记住一件事：</p>
<blockquote class="warning">
<p>使用字符串创建对象，而使用双字符串(double string)创建字符串。这意味着，为了创建一个字符串，你必须将其包装在另一个字符串中，以便我们正确验证它。</p>
</blockquote>
<h3 id="required">必选项 <a href="#required" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<ul>
<li><a href="#optsenvconfigurationrequired"><code>opts.env.configuration</code>(required)</a></li>
<li><a href="#optsenvconfigurationmyobj-required"><code>opts.env.configuration.myObj</code> (required)</a></li>
<li><a href="#myobjwebpackoptions-required"><code>myObj.webpackOptions</code> (required)</a></li>
<li><a href="#writing-required"><code>writing</code> (required)</a></li>
</ul>
<h3 id="optional">可选项 <a href="#optional" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<ul>
<li><a href="#myobjmerge-optional">myObj.merge</a></li>
<li><a href="#myobjtopscopeoptional">myObj.topScope</a></li>
<li><a href="#myobjconfignameoptional">myObj.configName</a></li>
</ul>
<h3 id="optsenvconfigurationrequired"><code>opts.env.configuration</code>（必选项） <a href="#optsenvconfigurationrequired" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p><code>object</code></p>
<p>这里是你配置的入口起点，请在 generator 的构造函数中对其进行初始化，以使 CLI 能够正常运行：</p>
<pre><code class="hljs language-js"><span class="token keyword">class</span> <span class="token class-name">MyScaffold</span> <span class="token keyword">extends</span> <span class="token class-name">Generator</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> opts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
    opts<span class="token punctuation">.</span>env<span class="token punctuation">.</span>configuration <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="optsenvconfigurationmyobj-required"><code>opts.env.configuration.myObj</code>（必选项） <a href="#optsenvconfigurationmyobj-required" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p><code>object</code></p>
<p>这里是你的脚手架，此处添加一些选项，CLI 会将其转换为 webpack 配置。你可以根据自己的喜好命名多种不同的脚手架，它们代表不同的配置，例如 <code>dev.config</code> 或 <code>prod.config</code>：</p>
<pre><code class="hljs language-js"><span class="token keyword">class</span> <span class="token class-name">MyScaffold</span> <span class="token keyword">extends</span> <span class="token class-name">Generator</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> opts<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>args<span class="token punctuation">,</span> opts<span class="token punctuation">)</span><span class="token punctuation">;</span>
    opts<span class="token punctuation">.</span>env<span class="token punctuation">.</span>configuration <span class="token operator">=</span> <span class="token punctuation">{</span>
      dev<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
      prod<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="myobjwebpackoptions-required"><code>myObj.webpackOptions</code>（必选项） <a href="#myobjwebpackoptions-required" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p><code>object</code></p>
<p>该对象具有与常规 webpack <a href="/configuration/">配置</a> 相同的格式。在此处声明想要预置的属性，例如 <code>entry</code>, <code>output</code> 和 <code>context</code>。可以在 yeoman 方法中对此进行初始化：</p>
<pre><code class="hljs language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>env<span class="token punctuation">.</span>configuration<span class="token punctuation">.</span>dev<span class="token punctuation">.</span>webpackOptions <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token punctuation">:</span> <span class="token string">'\'app.js\''</span><span class="token punctuation">,</span>
  output<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h3 id="writing-required"><code>writing</code>（必选项） <a href="#writing-required" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p><code>function</code></p>
<p>为了运行脚手架实例，需要将配置写入一个 <code>.yo-rc.json</code> 文件。可以使用 yeoman generator 中提供的某个生命周期来完成，例如 <code>writing</code> 方法：</p>
<pre><code class="hljs language-js"><span class="token keyword">class</span> <span class="token class-name">MyScaffold</span> <span class="token keyword">extends</span> <span class="token class-name">Generator</span> <span class="token punctuation">{</span>
  <span class="token function">writing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>config<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token string">'configuration'</span><span class="token punctuation">,</span> myObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="myobjmerge-optional"><code>myObj.merge</code>（可选项） <a href="#myobjmerge-optional" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p><code>string</code></p>
<p>如果要使用 <a href="https://github.com/survivejs/webpack-merge"><code>webpack-merge</code></a>，可以将 <code>myObj</code> 的 <code>merge</code> 属性，设置为需要合并的配置的名称：</p>
<pre><code class="hljs language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>env<span class="token punctuation">.</span>configuration<span class="token punctuation">.</span>dev<span class="token punctuation">.</span>merge <span class="token operator">=</span> <span class="token string">'myConfig'</span><span class="token punctuation">;</span></code></pre>
<h3 id="myobjtopscopeoptional"><code>myObj.topScope</code>（可选项）<a href="#myobjtopscopeoptional" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p><code>[string]</code></p>
<p>在 <code>topScope</code> 属性中，可以编写配置所需的所有代码，例如模块导入和函数/变量声明：</p>
<pre><code class="hljs language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>env<span class="token punctuation">.</span>configuration<span class="token punctuation">.</span>dev<span class="token punctuation">.</span>topScope <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'const webpack = require("webpack");'</span><span class="token punctuation">,</span>
  <span class="token string">'const path = require("path");'</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<h3 id="myobjconfignameoptional"><code>myObj.configName</code>（可选项） <a href="#myobjconfignameoptional" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p><code>string</code></p>
<p><code>configName</code> 允许自定义配置文件的名称。例如，可以将其命名为 <code>webpack.base.js</code>  而不是默认的 <code>webpack.config.js</code>：</p>
<pre><code class="hljs language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>options<span class="token punctuation">.</span>env<span class="token punctuation">.</span>configuration<span class="token punctuation">.</span>dev<span class="token punctuation">.</span>configName <span class="token operator">=</span> <span class="token string">'base'</span><span class="token punctuation">;</span></code></pre>
<h1 id="模块热替换">模块热替换<a href="#%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%BF%E6%8D%A2" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<blockquote class="tip">
<p>本指南继续沿用 <a href="/guides/development">开发环境</a> 指南中的代码示例。</p>
</blockquote>
<p>模块热替换(hot module replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新所有类型的模块，
而无需完全刷新。本页面重点介绍其 <strong>实现</strong>，而 <a href="/concepts/hot-module-replacement">概念</a> 页面提供了更多关于
它的工作原理以及为什么它有用的细节。</p>
<blockquote class="warning">
<p><strong>HMR</strong> 不适用于生产环境，这意味着它应当用于开发环境。更多详细信息，
请查看 <a href="/guides/production">生产环境</a> 指南。</p>
</blockquote>
<h2 id="enabling-hmr">启用 HMR <a href="#enabling-hmr" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>此功能可以很大程度提高生产效率。我们要做的就是更新 <a href="https://github.com/webpack/webpack-dev-server">webpack-dev-server</a> 配置，
然后使用 webpack 内置的 HMR 插件。我们还要删除掉 <code>print.js</code> 的入口起点，
因为现在已经在 <code>index.js</code> 模块中引用了它。</p>
<blockquote class="tip">
<p>如果你在技术选型中使用了 <code>webpack-dev-middleware</code> 而没有使用 <code>webpack-dev-server</code>，请使用 <a href="https://github.com/webpack-contrib/webpack-hot-middleware"><code>webpack-hot-middleware</code></a> 依赖包，以在你的自定义服务器或应用程序上启用 HMR。</p>
</blockquote>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const HtmlWebpackPlugin = require('html-webpack-plugin');
  const { CleanWebpackPlugin } = require('clean-webpack-plugin');

  module.exports = {
    entry: {
       app: './src/index.js',
<span class="token deleted">-      print: './src/print.js',</span>
    },
    devtool: 'inline-source-map',
    devServer: {
      contentBase: './dist',
<span class="token inserted">+     hot: true,</span>
    },
    plugins: [
      // new CleanWebpackPlugin(['dist/*']) for &#x3C; v2 versions of CleanWebpackPlugin
      new CleanWebpackPlugin(),
      new HtmlWebpackPlugin({
        title: 'Hot Module Replacement',
      }),
    ],
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
  };</code></pre>
<blockquote class="tip">
<p>你可以通过以下命令来修改 <a href="https://github.com/webpack/webpack-dev-server">webpack-dev-server</a>
的配置：<code>webpack-dev-server --hotOnly</code>。</p>
</blockquote>
<p>现在，我们来修改 <code>index.js</code> 文件，以便当 <code>print.js</code> 内部发生变更时可以告诉 webpack 接受更新的模块。</p>
<p><strong>index.js</strong></p>
<pre><code class="hljs language-diff">  import _ from 'lodash';
  import printMe from './print.js';

  function component() {
    const element = document.createElement('div');
    const btn = document.createElement('button');

    element.innerHTML = _.join(['Hello', 'webpack'], ' ');

    btn.innerHTML = 'Click me and check the console!';
    btn.onclick = printMe;

    element.appendChild(btn);

    return element;
  }

  document.body.appendChild(component());
<span class="token inserted">+</span>
<span class="token inserted">+ if (module.hot) {</span>
<span class="token inserted">+   module.hot.accept('./print.js', function() {</span>
<span class="token inserted">+     console.log('Accepting the updated printMe module!');</span>
<span class="token inserted">+     printMe();</span>
<span class="token inserted">+   })</span>
<span class="token inserted">+ }</span></code></pre>
<p>更改 <code>print.js</code> 中 <code>console.log</code> 的输出内容，你将会在浏览器中看到如下的输出
（不要担心现在 <code>button.onclick = printMe()</code> 的输出，我们稍后也会更新该部分）。</p>
<p><strong>print.js</strong></p>
<pre><code class="hljs language-diff">  export default function printMe() {
<span class="token deleted">-   console.log('I get called from print.js!');</span>
<span class="token inserted">+   console.log('Updating print.js...');</span>
  }</code></pre>
<p><strong>console</strong></p>
<pre><code class="hljs language-diff">[HMR] Waiting for update signal from WDS...
main.js:4395 [WDS] Hot Module Replacement enabled.
<span class="token inserted">+ 2main.js:4395 [WDS] App updated. Recompiling...</span>
<span class="token inserted">+ main.js:4395 [WDS] App hot update...</span>
<span class="token inserted">+ main.js:4330 [HMR] Checking for updates on the server...</span>
<span class="token inserted">+ main.js:10024 Accepting the updated printMe module!</span>
<span class="token inserted">+ 0.4b8ee77….hot-update.js:10 Updating print.js...</span>
<span class="token inserted">+ main.js:4330 [HMR] Updated modules:</span>
<span class="token inserted">+ main.js:4330 [HMR]  - 20</span></code></pre>
<h2 id="via-the-nodejs-api">通过 Node.js API <a href="#via-the-nodejs-api" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>在 Node.js API 中使用 webpack dev server 时，不要将 dev server 选项放在 webpack 配置对象中。而是在创建时，
将其作为第二个参数传递。例如：</p>
<p><code>new WebpackDevServer(compiler, options)</code></p>
<p>想要启用 HMR，还需要修改 webpack 配置对象，使其包含 HMR 入口起点。<code>webpack-dev-server</code> 依赖包中具有一个叫做 <code>addDevServerEntrypoints</code> 的方法，你可以通过使用这个方法来实现。这是关于如何使用的一个基本示例：</p>
<p><strong>dev-server.js</strong></p>
<pre><code class="hljs language-javascript"><span class="token keyword">const</span> webpackDevServer <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-dev-server'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./webpack.config.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span>
  contentBase<span class="token punctuation">:</span> <span class="token string">'./dist'</span><span class="token punctuation">,</span>
  hot<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  host<span class="token punctuation">:</span> <span class="token string">'localhost'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

webpackDevServer<span class="token punctuation">.</span><span class="token function">addDevServerEntrypoints</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> compiler <span class="token operator">=</span> <span class="token function">webpack</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">webpackDevServer</span><span class="token punctuation">(</span>compiler<span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">,</span> <span class="token string">'localhost'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'dev server listening on port 5000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<blockquote class="tip">
<p>如果你正在使用 <a href="/guides/development#using-webpack-dev-middleware"><code>webpack-dev-middleware</code></a>，可以通过 <a href="https://github.com/webpack-contrib/webpack-hot-middleware"><code>webpack-hot-middleware</code></a> 依赖包，在自定义 dev server 中启用 HMR。</p>
</blockquote>
<h2 id="gotchas">问题 <a href="#gotchas" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>模块热替换可能比较难以掌握。为了说明这一点，我们回到刚才的示例中。如果你继续点击示例页面上的按钮，
你会发现控制台仍在打印旧的 <code>printMe</code> 函数。</p>
<p>这是因为按钮的 <code>onclick</code> 事件处理函数仍然绑定在旧的 <code>printMe</code> 函数上。</p>
<p>为了让 HMR 正常工作，我们需要更新代码，使用 <code>module.hot.accept</code> 将其绑定到新的 <code>printMe</code> 函数上：</p>
<p><strong>index.js</strong></p>
<pre><code class="hljs language-diff">  import _ from 'lodash';
  import printMe from './print.js';

  function component() {
    const element = document.createElement('div');
    const btn = document.createElement('button');

    element.innerHTML = _.join(['Hello', 'webpack'], ' ');

    btn.innerHTML = 'Click me and check the console!';
    btn.onclick = printMe;  // onclick event is bind to the original printMe function

    element.appendChild(btn);

    return element;
  }

<span class="token deleted">- document.body.appendChild(component());</span>
<span class="token inserted">+ let element = component(); // 存储 element，以在 print.js 修改时重新渲染</span>
<span class="token inserted">+ document.body.appendChild(element);</span>

  if (module.hot) {
    module.hot.accept('./print.js', function() {
      console.log('Accepting the updated printMe module!');
<span class="token deleted">-     printMe();</span>
<span class="token inserted">+     document.body.removeChild(element);</span>
<span class="token inserted">+     element = component(); // 重新渲染 "component"，以便更新 click 事件处理函数</span>
<span class="token inserted">+     document.body.appendChild(element);</span>
    })
  }</code></pre>
<p>这仅仅是一个示例，还有很多让人易于犯错的情况。
幸运的是，有很多 loader（下面会提到一些）可以使得模块热替换变得更加容易。</p>
<h2 id="hmr-with-stylesheets">HMR 加载样式 <a href="#hmr-with-stylesheets" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>借助于 <code>style-loader</code>，使用模块热替换来加载 CSS 实际上极其简单。此 loader 在幕后使用了 <code>module.hot.accept</code>，在 CSS 依赖模块更新之后，会将其 patch(修补) 到 <code>&#x3C;style></code> 标签中。</p>
<p>首先使用以下命令安装两个 loader ：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev style-loader css-loader</code></pre>
<p>然后更新配置文件，使用这两个 loader。</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const HtmlWebpackPlugin = require('html-webpack-plugin');
  const { CleanWebpackPlugin } = require('clean-webpack-plugin');

  module.exports = {
    entry: {
      app: './src/index.js',
    },
    devtool: 'inline-source-map',
    devServer: {
      contentBase: './dist',
      hot: true,
    },
<span class="token inserted">+   module: {</span>
<span class="token inserted">+     rules: [</span>
<span class="token inserted">+       {</span>
<span class="token inserted">+         test: /\.css$/,</span>
<span class="token inserted">+         use: ['style-loader', 'css-loader'],</span>
<span class="token inserted">+       },</span>
<span class="token inserted">+     ],</span>
<span class="token inserted">+   },</span>
    plugins: [
       // 对于 CleanWebpackPlugin 的 v2 versions 以下版本，使用 new CleanWebpackPlugin(['dist/*'])
      new CleanWebpackPlugin(),
      new HtmlWebpackPlugin({
        title: 'Hot Module Replacement',
      }),
    ],
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
  };</code></pre>
<p>如同 import 模块，热加载样式表同样很简单：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  | - package.json
  | - webpack.config.js
  | - /dist
    | - bundle.js
  | - /src
    | - index.js
    | - print.js
<span class="token inserted">+   | - styles.css</span></code></pre>
<p><strong>styles.css</strong></p>
<pre><code class="hljs language-css"><span class="token selector">body</span> <span class="token punctuation">{</span>
  <span class="token property">background</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>index.js</strong></p>
<pre><code class="hljs language-diff">  import _ from 'lodash';
  import printMe from './print.js';
<span class="token inserted">+ import './styles.css';</span>

  function component() {
    const element = document.createElement('div');
    const btn = document.createElement('button');

    element.innerHTML = _.join(['Hello', 'webpack'], ' ');

    btn.innerHTML = 'Click me and check the console!';
    btn.onclick = printMe;  // onclick event is bind to the original printMe function

    element.appendChild(btn);

    return element;
  }

  let element = component();
  document.body.appendChild(element);

  if (module.hot) {
    module.hot.accept('./print.js', function() {
      console.log('Accepting the updated printMe module!');
      document.body.removeChild(element);
      element = component(); // Re-render the "component" to update the click handler
      document.body.appendChild(element);
    })
  }</code></pre>
<p>将 <code>body</code> 的 style 改为 <code>background: red;</code>，你应该可以立即看到页面的背景颜色随之更改，而无需完全刷新。</p>
<p><strong>styles.css</strong></p>
<pre><code class="hljs language-diff">  body {
<span class="token deleted">-   background: blue;</span>
<span class="token inserted">+   background: red;</span>
  }</code></pre>
<h2 id="other-code-and-frameworks">其他代码和框架 <a href="#other-code-and-frameworks" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>社区还提供许多其他 loader 和示例，可以使 HMR 与各种框架和库平滑地进行交互……</p>
<ul>
<li><a href="https://github.com/gaearon/react-hot-loader">React Hot Loader</a>: 实时调整 react 组件。</li>
<li><a href="https://github.com/vuejs/vue-loader">Vue Loader</a>: 此 loader 支持 vue 组件的 HMR，提供开箱即用体验。</li>
<li><a href="https://github.com/klazuka/elm-hot-webpack-loader">Elm Hot webpack Loader</a>: 支持 Elm 编程语言的 HMR。</li>
<li><a href="https://github.com/gdi2290/angular-hmr">Angular HMR</a>: 没有必要使用 loader！直接修改 NgModule 主文件就够了，
它可以完全控制 HMR API。</li>
<li><a href="https://github.com/sveltejs/svelte-loader">Svelte Loader</a>: 此 loader 开箱即用地支持 Svelte 组件的热更新。</li>
</ul>
<blockquote class="tip">
<p>如果你知道任何其他 loader 或 plugin，能够有助于或增强模块热替换(hot module replacement)，请提交一个 pull request 以添加到此列表中！</p>
</blockquote>
<h1 id="Tree-Shaking">Tree Shaking<a href="#Tree-Shaking" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p><em>tree shaking</em> 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块语法的 <a href="http://exploringjs.com/es6/ch_modules.html#static-module-structure">静态结构</a> 特性，例如 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import"><code>import</code></a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export"><code>export</code></a>。这个术语和概念实际上是由 ES2015 模块打包工具 <a href="https://github.com/rollup/rollup">rollup</a> 普及起来的。</p>
<p>webpack 2 正式版本内置支持 ES2015 模块（也叫做 <em>harmony modules</em>）和未使用模块检测能力。新的 webpack 4 正式版本扩展了此检测能力，通过 <code>package.json</code> 的 <code>"sideEffects"</code> 属性作为标记，向 compiler 提供提示，表明项目中的哪些文件是 "pure(纯正 ES2015 模块)"，由此可以安全地删除文件中未使用的部分。</p>
<blockquote class="tip">
<p>本指南的继承自 <a href="/guides/getting-started">起步</a> 指南。如果你尚未阅读该指南，请先行阅读。</p>
</blockquote>
<h2 id="add-a-utility">添加一个通用模块 <a href="#add-a-utility" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>在我们的项目中添加一个新的通用模块文件 <code>src/math.js</code>，并导出两个函数：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">webpack-demo
|- package.json
|- webpack.config.js
|- /dist
  |- bundle.js
  |- index.html
|- /src
  |- index.js
<span class="token inserted">+ |- math.js</span>
|- /node_modules</code></pre>
<p><strong>src/math.js</strong></p>
<pre><code class="hljs language-javascript"><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">square</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">cube</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">*</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>需要将 <code>mode</code> 配置设置成<a href="/configuration/mode/#mode-development">development</a>，以确定 bundle 不会被压缩：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
<span class="token inserted">+ mode: 'development',</span>
<span class="token inserted">+ optimization: {</span>
<span class="token inserted">+   usedExports: true,</span>
<span class="token inserted">+ },</span>
};</code></pre>
<p>配置完这些后，更新入口脚本，使用其中一个新方法，并且为了简化示例，我们先将 <code>lodash</code> 删除：</p>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff"><span class="token deleted">- import _ from 'lodash';</span>
<span class="token inserted">+ import { cube } from './math.js';</span>

  function component() {
<span class="token deleted">-   const element = document.createElement('div');</span>
<span class="token inserted">+   const element = document.createElement('pre');</span>

<span class="token deleted">-   // Lodash, now imported by this script</span>
<span class="token deleted">-   element.innerHTML = _.join(['Hello', 'webpack'], ' ');</span>
<span class="token inserted">+   element.innerHTML = [</span>
<span class="token inserted">+     'Hello webpack!',</span>
<span class="token inserted">+     '5 cubed is equal to ' + cube(5)</span>
<span class="token inserted">+   ].join('\n\n');</span>

    return element;
  }

  document.body.appendChild(component());</code></pre>
<p>注意，我们<strong>没有从 <code>src/math.js</code> 模块中 <code>import</code> 另外一个 <code>square</code> 方法</strong>。这个函数就是所谓的“未引用代码(dead code)”，也就是说，应该删除掉未被引用的 <code>export</code>。现在运行 npm script <code>npm run build</code>，并查看输出的 bundle：</p>
<p><strong>dist/bundle.js (around lines 90 - 100)</strong></p>
<pre><code class="hljs language-js"><span class="token comment">/* 1 */</span>
<span class="token comment">/***/</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> __webpack_exports__<span class="token punctuation">,</span> __webpack_require__<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">'use strict'</span><span class="token punctuation">;</span>
  <span class="token comment">/* unused harmony export square */</span>
  <span class="token comment">/* harmony export (immutable) */</span> __webpack_exports__<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> cube<span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">square</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">cube</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">*</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>注意，上面的 <code>unused harmony export square</code> 注释。如果你观察它下面的代码，你会注意到虽然我们没有引用 <code>square</code>，但它仍然被包含在 bundle 中。我们将在下一节解决这个问题。</p>
<h2 id="mark-the-file-as-side-effect-free">将文件标记为 side-effect-free(无副作用) <a href="#mark-the-file-as-side-effect-free" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>在一个纯粹的 ESM 模块世界中，很容易识别出哪些文件有 side effect。然而，我们的项目无法达到这种纯度，所以，此时有必要提示 webpack compiler 哪些代码是“纯粹部分”。</p>
<p>通过 package.json 的 <code>"sideEffects"</code> 属性，来实现这种方式。</p>
<pre><code class="hljs language-json"><span class="token punctuation">{</span>
  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"your-project"</span><span class="token punctuation">,</span>
  <span class="token property">"sideEffects"</span><span class="token operator">:</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span></code></pre>
<p>如果所有代码都不包含 side effect，我们就可以简单地将该属性标记为 <code>false</code>，来告知 webpack，它可以安全地删除未用到的 export。</p>
<blockquote class="tip">
<p>"side effect(副作用)" 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。举例说明，例如 polyfill，它影响全局作用域，并且通常不提供 export。</p>
</blockquote>
<p>如果你的代码确实有一些副作用，可以改为提供一个数组：</p>
<pre><code class="hljs language-json"><span class="token punctuation">{</span>
  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"your-project"</span><span class="token punctuation">,</span>
  <span class="token property">"sideEffects"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">"./src/some-side-effectful-file.js"</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre>
<p>数组方式支持相对路径、绝对路径和 glob 模式匹配相关文件。它在内部使用 <a href="https://github.com/micromatch/micromatch#matching-features">micromatch</a>。</p>
<blockquote class="tip">
<p>注意，所有导入文件都会受到 tree shaking 的影响。这意味着，如果在项目中使用类似 <code>css-loader</code> 并 import 一个 CSS 文件，则需要将其添加到 side effect 列表中，以免在生产模式中无意中将它删除：</p>
</blockquote>
<pre><code class="hljs language-json"><span class="token punctuation">{</span>
  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"your-project"</span><span class="token punctuation">,</span>
  <span class="token property">"sideEffects"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">"./src/some-side-effectful-file.js"</span><span class="token punctuation">,</span>
    <span class="token string">"*.css"</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre>
<p>最后，还可以在 <a href="/configuration/module/#module-rules"><code>module.rules</code> 配置选项</a> 中设置 <code>"sideEffects"</code>。</p>
<h2 id="clarifying-tree-shaking-and-sideeffects">解释 tree shaking 和 <code>sideEffects</code> <a href="#clarifying-tree-shaking-and-sideeffects" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p><a href="/configuration/optimization/#optimizationsideeffects"><code>sideEffects</code></a> 和 <a href="/configuration/optimization/#optimizationusedexports"><code>usedExports</code></a>（更多被认为是 tree shaking）是两种不同的优化方式。</p>
<p><strong><code>sideEffects</code> 更为有效</strong> 是因为它允许跳过整个模块/文件和整个文件子树。</p>
<p><code>usedExports</code> 依赖于 <a href="https://github.com/terser-js/terser">terser</a> 去检测语句中的副作用。它是一个 JavaScript 任务而且没有像 <code>sideEffects</code> 一样简单直接。而且它不能跳转子树/依赖由于细则中说副作用需要被评估。尽管导出函数能运作如常，但 React 框架的高阶函数（HOC）在这种情况下是会出问题的。</p>
<p>让我们来看一个例子：</p>
<pre><code class="hljs language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> Button <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@shopify/polaris'</span><span class="token punctuation">;</span></code></pre>
<p>打包前的文件版本看起来是这样的：</p>
<pre><code class="hljs language-javascript"><span class="token keyword">import</span> hoistStatics <span class="token keyword">from</span> <span class="token string">'hoist-non-react-statics'</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Button</span><span class="token punctuation">(</span>_ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> _final <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> _len <span class="token operator">=</span> arguments<span class="token punctuation">.</span>length<span class="token punctuation">,</span> objs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>_len<span class="token punctuation">)</span><span class="token punctuation">,</span> _key <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> _key <span class="token operator">&#x3C;</span> _len<span class="token punctuation">;</span> _key<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    objs<span class="token punctuation">[</span>_key<span class="token punctuation">]</span> <span class="token operator">=</span> arguments<span class="token punctuation">[</span>_key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> _i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> _objs <span class="token operator">=</span> objs<span class="token punctuation">;</span> _i <span class="token operator">&#x3C;</span> _objs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> _i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> obj <span class="token operator">=</span> _objs<span class="token punctuation">[</span>_i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">mergeRecursively</span><span class="token punctuation">(</span>_final<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> _final<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">withAppProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">addProvider</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> WithProvider <span class="token operator">=</span>
    <span class="token comment">/*#__PURE__*/</span>
    <span class="token keyword">function</span> <span class="token punctuation">(</span>_React$Component<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ...</span>
      <span class="token keyword">return</span> WithProvider<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">(</span>Component<span class="token punctuation">)</span><span class="token punctuation">;</span>

    WithProvider<span class="token punctuation">.</span>contextTypes <span class="token operator">=</span> WrappedComponent<span class="token punctuation">.</span>contextTypes <span class="token operator">?</span> <span class="token function">merge</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">.</span>contextTypes<span class="token punctuation">,</span> polarisAppProviderContextTypes<span class="token punctuation">)</span> <span class="token punctuation">:</span> polarisAppProviderContextTypes<span class="token punctuation">;</span>
    <span class="token keyword">var</span> FinalComponent <span class="token operator">=</span> <span class="token function">hoistStatics</span><span class="token punctuation">(</span>WithProvider<span class="token punctuation">,</span> WrappedComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> FinalComponent<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> Button$<span class="token number">1</span> <span class="token operator">=</span> <span class="token function">withAppProvider</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Button<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...,</span>
  Button$<span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>当 <code>Button</code> 没有被使用，你可以有效地清除掉 <code>export { Button$1 };</code> 且保留所有剩下的代码。那问题来了，“这段代码会有任何副作用或它能被安全都清理掉吗？”。很难说，尤其是这 <code>withAppProvider()(Button)</code> 这段代码。<code>withAppProvider</code> 被调用，而且返回的值也被调用。当调用 <code>merge</code> 或 <code>hoistStatics</code> 会有任何副作用吗？当给 <code>WithProvider.contextTypes</code> (Setter?) 赋值或当读取 <code>WrappedComponent.contextTypes</code> (Getter) 的时候，会有任何副作用吗？</p>
<p>实际上，Terser 尝试去解决以上的问题，但在很多情况下，它不太确定。但这不会意味着 terser 由于无法解决这些问题而运作得不好，而是由于在 JavaScript 这种动态语言中实在太难去确定。</p>
<p>但我们可以通过 <code>/*#__PURE__*/</code> 注释来帮忙 terser。它给一个语句标记为没有副作用。就这样一个简单的改变就能够使下面的代码被 tree-shake:</p>
<p><code>var Button$1 = /*#__PURE__*/ withAppProvider()(Button);</code></p>
<p>这样会允许去掉这代码代码，但仍然会有一些导入的问题需要被包括/评估，因为它们包含了副作用。</p>
<p>为了解决这个问题，我们使用在 <code>package.json</code> 中<a href="/guides/tree-shaking/#mark-the-file-as-side-effect-free"><code>"sideEffects"</code></a> 属性。</p>
<p>它类似于 <code>/*#__PURE__*/</code> 但是作用于模块的层面，而不是代码语句的层面。它表示的意思是(指<code>"sideEffects"</code> 属性)：“如果被标记为无副作用的模块没有被直接导出使用，打包工具会跳过进行模块的副作用分析评估。”。</p>
<p>在一个 <code>Shopify Polaris</code> 的例子，原有的模块如下：</p>
<p><strong>index.js</strong></p>
<pre><code class="hljs language-javascript"><span class="token keyword">import</span> <span class="token string">'./configure'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">'./types'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">'./components'</span><span class="token punctuation">;</span></code></pre>
<p><strong>components/index.js</strong></p>
<pre><code class="hljs language-javascript"><span class="token comment">// ...</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> Breadcrumbs <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./Breadcrumbs'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> Button<span class="token punctuation">,</span> buttonFrom<span class="token punctuation">,</span> buttonsFrom<span class="token punctuation">,</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./Button'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> ButtonGroup <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./ButtonGroup'</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span></code></pre>
<p><strong>package.json</strong></p>
<pre><code class="hljs language-json">// ...
<span class="token property">"sideEffects"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token string">"**/*.css"</span><span class="token punctuation">,</span>
  <span class="token string">"**/*.scss"</span><span class="token punctuation">,</span>
  <span class="token string">"./esnext/index.js"</span><span class="token punctuation">,</span>
  <span class="token string">"./esnext/configure.js"</span>
<span class="token punctuation">]</span><span class="token punctuation">,</span>
// ...</code></pre>
<p>对于代码 <code>import { Button } from "@shopify/polaris";</code> 它有以下的暗示：</p>
<ul>
<li>导入它：导入并包含该模块，分析评估它并继续进行依赖分析</li>
<li>跳过它：不导入它，不分析评估它但会继续进行依赖分析</li>
<li>排除它：不导入它，不评估且不做依赖分析</li>
</ul>
<p>以下是每个匹配到的资源的情况：</p>
<ul>
<li><code>index.js</code>: 没有直接的导出被使用，但被标记为有副作用 -> 导入它</li>
<li><code>configure.js</code>: 没有导出被使用，但被标记为有副作用 -> 导入它</li>
<li><code>types/index.js</code>: 没有导出被使用，没有被标记为有副作用 -> 排除它</li>
<li><code>components/index.js</code>: 没有导出被使用，没有被标记为有副作用，但重新导出的导出内容被使用了 -> 跳过它</li>
<li><code>components/Breadcrumbs.js</code>: 没有导出被使用，没有被标记为有副作用 -> 排除它。这也会排除所有如同 <code>components/Breadcrumbs.css</code> 的依赖，尽管它们都被标记为有副作用。</li>
<li><code>components/Button.js</code>: 直接的导出被使用，没有被标记为有副作用 -> 导入它</li>
<li><code>components/Button.css</code>: 没有导出被使用，但被标记为有副作用 -> 导入它</li>
</ul>
<p>在这种情况下，只有4个模块被导入到 bundle 中：</p>
<ul>
<li><code>index.js</code>: 基本为空的</li>
<li><code>configure.js</code></li>
<li><code>components/Button.js</code></li>
<li><code>components/Button.css</code></li>
</ul>
<p>在这次的优化后，其它的优化项目都可以应用。例如：从 <code>Button.js</code> 导出 的<code>buttonFrom</code> 和 <code>buttonsFrom</code> 也没有被使用。<code>usedExports</code> 优化会捡起这些代码而且 terser 会能够从 bundle 中把这些语句摘除出来。</p>
<p>模块合并也会应用。所以这4个模块，加上入口的模块（也可能有更多的依赖）会被合并。 <strong><code>index.js</code> 最终没有生成代码</strong>.</p>
<h2 id="mark-a-function-call-as-side-effect-free">将函数调用标记为无副作用 <a href="#mark-a-function-call-as-side-effect-free" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>是可以告诉 webpack 一个函数调用是无副作用的，只要通过 <code>/*#__PURE__*/</code> 注释。它可以被放到函数调用之前，用来标记它们是无副作用的(pure)。传到函数中的入参是无法被刚才的注释所标记，需要单独每一个标记才可以。如果一个没被使用的变量定义的初始值被认为是无副作用的（pure），它会被标记为死代码，不会被执行且会被压缩工具清除掉。这个行为被会开启当 <a href="/configuration/optimization/#optimizationinnergraph"><code>optimization.innerGraph</code></a> 被设置成 <code>true</code>。</p>
<p><strong>file.js</strong></p>
<pre><code class="hljs language-javascript"><span class="token comment">/*#__PURE__*/</span> <span class="token function">double</span><span class="token punctuation">(</span><span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<h2 id="minify-the-output">压缩输出结果 <a href="#minify-the-output" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>通过 <code>import</code> 和 <code>export</code>  语法，我们已经找出需要删除的“未引用代码(dead code)”，然而，不仅仅是要找出，还要在 bundle 中删除它们。为此，我们需要将 <code>mode</code> 配置选项设置为 <a href="/configuration/mode/#mode-production"><code>production</code></a>。</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
<span class="token deleted">- mode: 'development',</span>
<span class="token deleted">- optimization: {</span>
<span class="token deleted">-   usedExports: true,</span>
<span class="token deleted">- }</span>
<span class="token inserted">+ mode: 'production',</span>
};</code></pre>
<blockquote class="tip">
<p>注意，也可以在命令行接口中使用 <code>--optimize-minimize</code> 标记，来启用 <code>TerserPlugin</code>。</p>
</blockquote>
<p>准备就绪后，然后运行另一个命令 <code>npm run build</code>，看看输出结果有没有发生改变。</p>
<p>你发现 <code>dist/bundle.js</code> 中的差异了吗？显然，现在整个 bundle 都已经被 minify(压缩) 和 mangle(混淆破坏)，但是如果仔细观察，则不会看到引入 <code>square</code> 函数，但能看到 <code>cube</code> 函数的混淆破坏版本（<code>function r(e){return e*e*e}n.a=r</code>）。现在，随着 minification(代码压缩) 和 tree shaking，我们的 bundle 减小几个字节！虽然，在这个特定示例中，可能看起来没有减少很多，但是，在有着复杂依赖树的大型应用程序上运行 tree shaking 时，会对 bundle 产生显著的体积优化。</p>
<blockquote class="tip">
<p>在使用 tree shaking 时必须有 <a href="/plugins/module-concatenation-plugin">ModuleConcatenationPlugin</a> 的支持，您可以通过设置配置项 <code>mode: "production"</code> 以启用它。如果您没有如此做，请记得手动引入 <a href="/plugins/module-concatenation-plugin">ModuleConcatenationPlugin</a>。</p>
</blockquote>
<h2 id="conclusion">结论 <a href="#conclusion" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>因此，我们学到为了利用 <em>tree shaking</em> 的优势， 你必须...</p>
<ul>
<li>使用 ES2015 模块语法（即 <code>import</code> 和 <code>export</code>）。</li>
<li>确保没有编译器将您的 ES2015 模块语法转换为 CommonJS 的（顺带一提，这是现在常用的 @babel/preset-env 的默认行为，详细信息请参阅<a href="https://babeljs.io/docs/en/babel-preset-env#modules">文档</a>）。</li>
<li>在项目的 <code>package.json</code> 文件中，添加 <code>"sideEffects"</code> 属性。</li>
<li>使用 <code>mode</code> 为 <code>"production"</code> 的配置项以启用<a href="/concepts/mode/#usage">更多优化项</a>，包括压缩代码与 tree shaking。</li>
</ul>
<p>你可以将应用程序想象成一棵树。绿色表示实际用到的 source code(源码) 和 library(库)，是树上活的树叶。灰色表示未引用代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。</p>
<p>如果你对优化输出很感兴趣，请进入到下个指南，来了解 <a href="/guides/production">生产环境</a> 构建的详细细节。</p>
<h1 id="生产环境">生产环境<a href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p>在本指南中，我们将深入一些最佳实践和工具，将站点或应用程序构建到生产环境中。</p>
<blockquote class="tip">
<p>以下示例来源于 <a href="/guides/tree-shaking">tree shaking</a> 和 <a href="/guides/development">开发环境</a>。在继续之前，请确保你已经熟悉这些指南中所介绍的概念/配置。</p>
</blockquote>
<h2 id="setup">配置 <a href="#setup" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p><em>development(开发环境)</em> 和 <em>production(生产环境)</em> 这两个环境下的构建目标存在着巨大差异。在<em>开发环境</em>中，我们需要：强大的 source map 和一个有着 live reloading(实时重新加载) 或 hot module replacement(热模块替换) 能力的 localhost server。而<em>生产环境</em>目标则转移至其他方面，关注点在于压缩 bundle、更轻量的 source map、资源优化等，通过这些优化方式改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写<strong>彼此独立的 webpack 配置</strong>。</p>
<p>虽然，以上我们将<em>生产环境</em>和<em>开发环境</em>做了略微区分，但是，请注意，我们还是会遵循不重复原则(Don't repeat yourself - DRY)，保留一个 "common(通用)" 配置。为了将这些配置合并在一起，我们将使用一个名为 <a href="https://github.com/survivejs/webpack-merge"><code>webpack-merge</code></a> 的工具。此工具会引用 "common" 配置，因此我们不必再在环境特定(environment-specific)的配置中编写重复代码。</p>
<p>我们先从安装 <code>webpack-merge</code> 开始，并将之前指南中已经成型的那些代码进行分离：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev webpack-merge</code></pre>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  |- package.json
<span class="token deleted">- |- webpack.config.js</span>
<span class="token inserted">+ |- webpack.common.js</span>
<span class="token inserted">+ |- webpack.dev.js</span>
<span class="token inserted">+ |- webpack.prod.js</span>
  |- /dist
  |- /src
    |- index.js
    |- math.js
  |- /node_modules</code></pre>
<p><strong>webpack.common.js</strong></p>
<pre><code class="hljs language-diff"><span class="token inserted">+ const path = require('path');</span>
<span class="token inserted">+ const { CleanWebpackPlugin } = require('clean-webpack-plugin');</span>
<span class="token inserted">+ const HtmlWebpackPlugin = require('html-webpack-plugin');</span>
<span class="token inserted">+</span>
<span class="token inserted">+ module.exports = {</span>
<span class="token inserted">+   entry: {</span>
<span class="token inserted">+     app: './src/index.js',</span>
<span class="token inserted">+   },</span>
<span class="token inserted">+   plugins: [</span>
<span class="token inserted">+     // 对于 CleanWebpackPlugin 的 v2 versions 以下版本，使用 new CleanWebpackPlugin(['dist/*'])</span>
<span class="token inserted">+     new CleanWebpackPlugin(),</span>
<span class="token inserted">+     new HtmlWebpackPlugin({</span>
<span class="token inserted">+       title: 'Production',</span>
<span class="token inserted">+     }),</span>
<span class="token inserted">+   ],</span>
<span class="token inserted">+   output: {</span>
<span class="token inserted">+     filename: '[name].bundle.js',</span>
<span class="token inserted">+     path: path.resolve(__dirname, 'dist'),</span>
<span class="token inserted">+   },</span>
<span class="token inserted">+ };</span></code></pre>
<p><strong>webpack.dev.js</strong></p>
<pre><code class="hljs language-diff"><span class="token inserted">+ const merge = require('webpack-merge');</span>
<span class="token inserted">+ const common = require('./webpack.common.js');</span>
<span class="token inserted">+</span>
<span class="token inserted">+ module.exports = merge(common, {</span>
<span class="token inserted">+   mode: 'development',</span>
<span class="token inserted">+   devtool: 'inline-source-map',</span>
<span class="token inserted">+   devServer: {</span>
<span class="token inserted">+     contentBase: './dist',</span>
<span class="token inserted">+   },</span>
<span class="token inserted">+ });</span></code></pre>
<p><strong>webpack.prod.js</strong></p>
<pre><code class="hljs language-diff"><span class="token inserted">+ const merge = require('webpack-merge');</span>
<span class="token inserted">+ const common = require('./webpack.common.js');</span>
<span class="token inserted">+</span>
<span class="token inserted">+ module.exports = merge(common, {</span>
<span class="token inserted">+   mode: 'production',</span>
<span class="token inserted">+ });</span></code></pre>
<p>现在，在 <code>webpack.common.js</code> 中，我们设置了 <code>entry</code> 和 <code>output</code> 配置，并且在其中引入这两个环境公用的全部插件。在 <code>webpack.dev.js</code> 中，我们将 <code>mode</code> 设置为 <code>development</code>，并且为此环境添加了推荐的 <code>devtool</code>（强大的 source map）和简单的 <code>devServer</code> 配置。最后，在 <code>webpack.prod.js</code> 中，我们将 <code>mode</code> 设置为 <code>production</code>，其中会引入之前在 <a href="/guides/tree-shaking">tree shaking</a> 指南中介绍过的 <code>TerserPlugin</code>。</p>
<p>注意，在环境特定的配置中使用 <code>merge()</code> 功能，可以很方便地引用 <code>webpack.dev.js</code> 和 <code>webpack.prod.js</code> 中公用的 common 配置。<code>webpack-merge</code> 工具提供了各种 merge(合并) 高级功能，但是在我们的用例中，无需用到这些功能。</p>
<h2 id="npm-scripts">NPM Scripts <a href="#npm-scripts" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>现在，我们把 <code>scripts</code> 重新指向到新配置。让 <code>npm start</code> script 中 <code>webpack-dev-server</code>, 使用 <code>webpack.dev.js</code>, 而让 <code>npm run build</code> script 使用 <code>webpack.prod.js</code>:</p>
<p><strong>package.json</strong></p>
<pre><code class="hljs language-diff">  {
    "name": "development",
    "version": "1.0.0",
    "description": "",
    "main": "src/index.js",
    "scripts": {
<span class="token deleted">-     "start": "webpack-dev-server --open",</span>
<span class="token inserted">+     "start": "webpack-dev-server --open --config webpack.dev.js",</span>
<span class="token deleted">-     "build": "webpack"</span>
<span class="token inserted">+     "build": "webpack --config webpack.prod.js"</span>
    },
    "keywords": [],
    "author": "",
    "license": "ISC",
    "devDependencies": {
      "clean-webpack-plugin": "^0.1.17",
      "css-loader": "^0.28.4",
      "csv-loader": "^2.1.1",
      "express": "^4.15.3",
      "file-loader": "^0.11.2",
      "html-webpack-plugin": "^2.29.0",
      "style-loader": "^0.18.2",
      "webpack": "^4.30.0",
      "webpack-dev-middleware": "^1.12.0",
      "webpack-dev-server": "^2.9.1",
      "webpack-merge": "^4.1.0",
      "xml-loader": "^1.2.1"
    }
  }</code></pre>
<p>随便运行下这些脚本，然后查看输出结果的变化，然后我们会继续添加一些<em>生产环境</em>配置。</p>
<h2 id="specify-the-mode">指定 mode <a href="#specify-the-mode" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>许多 library 通过与 <code>process.env.NODE_ENV</code> 环境变量关联，以决定 library 中应该引用哪些内容。例如，当<code>process.env.NODE_ENV</code> 没有被设置为 <code>'production'</code> 时，某些 library 为了使调试变得容易，可能会添加额外的 log(日志记录) 和 test(测试) 功能。并且，在使用 <code>process.env.NODE_ENV === 'production'</code> 时，一些 library 可能针对具体用户的环境，删除或添加一些重要代码，以进行代码执行方面的优化。从 webpack v4 开始, 指定 <a href="/configuration/mode/"><code>mode</code></a> 会自动地配置 <a href="/plugins/define-plugin"><code>DefinePlugin</code></a>：</p>
<p><strong>webpack.prod.js</strong></p>
<pre><code class="hljs language-diff">  const merge = require('webpack-merge');
  const common = require('./webpack.common.js');

  module.exports = merge(common, {
    mode: 'production',
  });</code></pre>
<blockquote class="tip">
<p>技术上讲，<code>NODE_ENV</code> 是一个由 Node.js 暴露给执行脚本的系统环境变量。通常用于决定在开发环境与生产环境(dev-vs-prod)下，server tools(服务期工具)、build scripts(构建脚本) 和 client-side libraries(客户端库) 的行为。然而，与预期相反，在构建脚本 <code>webpack.config.js</code> 中<code>process.env.NODE_ENV</code> 并没有被设置为 <code>"production"</code>，请查看 <a href="https://github.com/webpack/webpack/issues/2537">#2537</a>。因此，在 webpack 配置文件中，<code>process.env.NODE_ENV === 'production' ? '[name].[hash].bundle.js' : '[name].bundle.js'</code> 这样的条件语句，无法按照预期运行。</p>
</blockquote>
<p>如果你正在使用像 <a href="https://react.docchina.org/"><code>react</code></a> 这样的 library，那么在添加此 DefinePlugin 插件后，你应该看到 bundle 大小显著下降。还要注意，任何位于 <code>/src</code> 的本地代码都可以关联到 process.env.NODE_ENV 环境变量，所以以下检查也是有效的：</p>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff">  import { cube } from './math.js';
<span class="token inserted">+</span>
<span class="token inserted">+ if (process.env.NODE_ENV !== 'production') {</span>
<span class="token inserted">+   console.log('Looks like we are in development mode!');</span>
<span class="token inserted">+ }</span>

  function component() {
    const element = document.createElement('pre');

    element.innerHTML = [
      'Hello webpack!',
      '5 cubed is equal to ' + cube(5)
    ].join('\n\n');

    return element;
  }

  document.body.appendChild(component());</code></pre>
<h2 id="minification">压缩(Minification) <a href="#minification" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>webpack v4+ will minify your code by default in <a href="/configuration/mode/#mode-production"><code>production mode</code></a>.</p>
<p>注意，虽然生产环境下默认使用 <a href="/plugins/terser-webpack-plugin"><code>TerserPlugin</code></a> ，并且也是代码压缩方面比较好的选择，但是还有一些其他可选择项。以下有几个同样很受欢迎的插件：</p>
<ul>
<li><a href="https://github.com/webpack-contrib/babel-minify-webpack-plugin"><code>BabelMinifyWebpackPlugin</code></a></li>
<li><a href="https://github.com/webpack-contrib/closure-webpack-plugin"><code>ClosureWebpackPlugin</code></a></li>
</ul>
<p>如果决定尝试一些其他压缩插件，只要确保新插件也会按照 <a href="/guides/tree-shaking">tree shake</a> 指南中所陈述的具有删除未引用代码(dead code)的能力，并将它作为 <a href="/configuration/optimization/#optimization-minimizer"><code>optimization.minimizer</code></a>。</p>
<h2 id="source-mapping">源码映射(Source Mapping) <a href="#source-mapping" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>我们鼓励你在生产环境中启用 source map，因为它们对 debug(调试源码) 和运行 benchmark tests(基准测试) 很有帮助。虽然有着如此强大的功能，然而还是应该针对生产环境用途，选择一个可以快速构建的推荐配置（更多选项请查看 <a href="/configuration/devtool"><code>devtool</code></a>）。对于本指南，我们将在<em>生产环境</em>中使用 <code>source-map</code> 选项，而不是我们在<em>开发环境</em>中用到的 <code>inline-source-map</code>：</p>
<p><strong>webpack.prod.js</strong></p>
<pre><code class="hljs language-diff">  const merge = require('webpack-merge');
  const common = require('./webpack.common.js');

  module.exports = merge(common, {
    mode: 'production',
<span class="token inserted">+   devtool: 'source-map',</span>
  });</code></pre>
<blockquote class="tip">
<p>避免在生产中使用 <code>inline-***</code> 和 <code>eval-***</code>，因为它们会增加 bundle 体积大小，并降低整体性能。</p>
</blockquote>
<h2 id="minimize-css">压缩 CSS <a href="#minimize-css" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>将生产环境下的 CSS 进行压缩会非常重要，请查看 <a href="/plugins/mini-css-extract-plugin/#minimizing-for-production">在生产环境下压缩</a> 章节。</p>
<h2 id="cli-alternatives">CLI 替代选项 <a href="#cli-alternatives" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>以上所述也可以通过命令行实现。例如，<code>--optimize-minimize</code> 标记将在幕后引用 <code>TerserPlugin</code>。和以上描述的 <code>DefinePlugin</code> 实例相同，<code>--define process.env.NODE_ENV="'production'"</code> 也会做同样的事情。而且，<code>webpack -p</code> 将自动地配置上述这两个标记，从而调用需要引入的插件。</p>
<p>虽然这种简写方式很好，但通常我们建议只使用配置方式，因为在这两种方式中，配置方式能够更准确地理解现在正在做的事情。配置方式还为可以让你更加细微地控制这两个插件中的其他选项。</p>
<h1 id="懒加载">懒加载<a href="#%E6%87%92%E5%8A%A0%E8%BD%BD" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<blockquote class="tip">
<p>本指南继承自<a href="/guides/code-splitting">代码分离</a>。如果你尚未阅读该指南，请先行阅读。</p>
</blockquote>
<p>懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。</p>
<h2 id="example">示例 <a href="#example" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>我们在<a href="/guides/code-splitting#dynamic-imports">代码分离</a>中的例子基础上，进一步做些调整来说明这个概念。那里的代码确实会在脚本运行的时候产生一个分离的代码块 <code>lodash.bundle.js</code> ，在技术概念上“懒加载”它。问题是加载这个包并不需要用户的交互 -- 意思是每次加载页面的时候都会请求它。这样做并没有对我们有很多帮助，还会对性能产生负面影响。</p>
<p>我们试试不同的做法。我们增加一个交互，当用户点击按钮的时候用 console 打印一些文字。但是会等到第一次交互的时候再加载那个代码块（<code>print.js</code>）。为此，我们返回到代码分离的例子中，把 <code>lodash</code> 放到主代码块中，重新运行<em>代码分离</em>中的代码 <a href="/guides/code-splitting#dynamic-imports">final <em>Dynamic Imports</em> example</a>。</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">webpack-demo
|- package.json
|- webpack.config.js
|- /dist
|- /src
  |- index.js
<span class="token inserted">+ |- print.js</span>
|- /node_modules</code></pre>
<p><strong>src/print.js</strong></p>
<pre><code class="hljs language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'The print.js module has loaded! See the network tab in dev tools...'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Button Clicked: Here\'s "some text"!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff"><span class="token inserted">+ import _ from 'lodash';</span>
<span class="token inserted">+</span>
<span class="token deleted">- async function getComponent() {</span>
<span class="token inserted">+ function component() {</span>
    const element = document.createElement('div');
<span class="token deleted">-   const _ = await import(/* webpackChunkName: "lodash" */ 'lodash');</span>
<span class="token inserted">+   const button = document.createElement('button');</span>
<span class="token inserted">+   const br = document.createElement('br');</span>

<span class="token inserted">+   button.innerHTML = 'Click me and look at the console!';</span>
    element.innerHTML = _.join(['Hello', 'webpack'], ' ');
<span class="token inserted">+   element.appendChild(br);</span>
<span class="token inserted">+   element.appendChild(button);</span>
<span class="token inserted">+</span>
<span class="token inserted">+   // Note that because a network request is involved, some indication</span>
<span class="token inserted">+   // of loading would need to be shown in a production-level site/app.</span>
<span class="token inserted">+   button.onclick = e => import(/* webpackChunkName: "print" */ './print').then(module => {</span>
<span class="token inserted">+     const print = module.default;</span>
<span class="token inserted">+</span>
<span class="token inserted">+     print();</span>
<span class="token inserted">+   });</span>

    return element;
  }

<span class="token deleted">- getComponent().then(component => {</span>
<span class="token deleted">-   document.body.appendChild(component);</span>
<span class="token deleted">- });</span>
<span class="token inserted">+ document.body.appendChild(component());</span></code></pre>
<blockquote class="warning">
<p>注意当调用 ES6 模块的 <code>import()</code> 方法（引入模块）时，必须指向模块的 <code>.default</code> 值，因为它才是 promise 被处理后返回的实际的 <code>module</code> 对象。</p>
</blockquote>
<p>现在运行 webpack 来验证一下我们的懒加载功能：</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
          Asset       Size  Chunks                    Chunk Names
print.bundle.js  417 bytes       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         print
index.bundle.js     548 kB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  index
     index.html  189 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.</code></pre>
<h2 id="frameworks">框架 <a href="#frameworks" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>许多框架和类库对于如何用它们自己的方式来实现（懒加载）都有自己的建议。这里有一些例子：</p>
<ul>
<li>React: <a href="https://reacttraining.com/react-router/web/guides/code-splitting">Code Splitting and Lazy Loading</a></li>
<li>Vue: <a href="https://vuedose.tips/tips/dynamic-imports-in-vue-js-for-better-performance/">Dynamic Imports in Vue.js for better performance</a></li>
<li>Angular: <a href="https://angular.io/guide/router#milestone-6-asynchronous-routing">Lazy Loading route configuration</a> and <a href="https://medium.com/@var_bin/angularjs-webpack-lazyload-bb7977f390dd">AngularJS + webpack = lazyLoad</a></li>
</ul>
<h1 id="Shimming-预置依赖">Shimming 预置依赖<a href="#Shimming-%E9%A2%84%E7%BD%AE%E4%BE%9D%E8%B5%96" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p><code>webpack</code> compiler 能够识别遵循 ES2015 模块语法、CommonJS 或 AMD 规范编写的模块。然而，一些 third party(第三方库) 可能会引用一些全局依赖（例如 <code>jQuery</code> 中的 <code>$</code>）。因此这些 library 也可能会创建一些需要导出的全局变量。这些 "broken modules(不符合规范的模块)" 就是 <em>shimming(预置依赖)</em> 发挥作用的地方。</p>
<blockquote class="warning">
<p><strong>我们不推荐使用全局依赖！</strong>webpack 背后的整个理念是使前端开发更加模块化。也就是说，需要编写具有良好的封闭性(well contained)、不依赖于隐含依赖（例如，全局变量）的彼此隔离的模块。请只在必要的时候才使用这些特性。</p>
</blockquote>
<p><em>shim</em> 另外一个极其有用的使用场景就是：当你希望 <a href="https://en.wikipedia.org/wiki/Polyfill_(programming)">polyfill</a> 扩展浏览器能力，来支持到更多用户时。在这种情况下，你可能只是想要将这些 polyfills 提供给需要修补(patch)的浏览器（也就是实现按需加载）。</p>
<p>下面的文章将向我们展示这两种用例。</p>
<blockquote class="tip">
<p>为了方便，本指南继续沿用 <a href="/guides/getting-started">起步</a> 中的代码示例。在继续之前，请确保你已经熟悉这些配置。</p>
</blockquote>
<h2 id="shimming-globals">Shimming 预置全局变量 <a href="#shimming-globals" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>让我们开始第一个 shimming 全局变量的用例。在此之前，先看下我们的项目：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">webpack-demo
|- package.json
|- webpack.config.js
|- /dist
|- /src
  |- index.js
|- /node_modules</code></pre>
<p>还记得我们之前用过的 <code>lodash</code> 吗？出于演示目的，例如把这个应用程序中的模块依赖，改为一个全局变量依赖。要实现这些，我们需要使用 <code>ProvidePlugin</code> 插件。</p>
<p>使用 <a href="/plugins/provide-plugin"><code>ProvidePlugin</code></a> 后，能够在 webpack 编译的每个模块中，通过访问一个变量来获取一个 package。如果 webpack 看到模块中用到这个变量，它将在最终 bundle 中引入给定的 package。让我们先移除 <code>lodash</code> 的 <code>import</code> 语句，改为通过插件提供它：</p>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff"><span class="token deleted">- import _ from 'lodash';</span>
<span class="token deleted">-</span>
  function component() {
    const element = document.createElement('div');

<span class="token deleted">-   // Lodash, now imported by this script</span>
    element.innerHTML = _.join(['Hello', 'webpack'], ' ');

    return element;
  }

  document.body.appendChild(component());</code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
<span class="token inserted">+ const webpack = require('webpack');</span>

  module.exports = {
    entry: './src/index.js',
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
<span class="token inserted">+   plugins: [</span>
<span class="token inserted">+     new webpack.ProvidePlugin({</span>
<span class="token inserted">+       _: 'lodash',</span>
<span class="token inserted">+     }),</span>
<span class="token inserted">+   ],</span>
  };</code></pre>
<p>我们本质上所做的，就是告诉 webpack……</p>
<blockquote>
<p>如果你遇到了至少一处用到 <code>_</code> 变量的模块实例，那请你将 <code>lodash</code> package 引入进来，并将其提供给需要用到它的模块。</p>
</blockquote>
<p>运行我们的构建脚本，将会看到同样的输出：</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
    Asset    Size  Chunks                    Chunk Names
bundle.js  544 kB       0  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  main
<span class="token punctuation">..</span>.</code></pre>
<p>还可以使用 <code>ProvidePlugin</code> 暴露出某个模块中单个导出，通过配置一个“数组路径”（例如 <code>[module, child, ...children?]</code>）实现此功能。所以，我们假想如下，无论 <code>join</code> 方法在何处调用，我们都只会获取到 <code>lodash</code> 中提供的 <code>join</code> 方法。</p>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff">  function component() {
    const element = document.createElement('div');

<span class="token deleted">-   element.innerHTML = _.join(['Hello', 'webpack'], ' ');</span>
<span class="token inserted">+   element.innerHTML = join(['Hello', 'webpack'], ' ');</span>

    return element;
  }

  document.body.appendChild(component());</code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const webpack = require('webpack');

  module.exports = {
    entry: './src/index.js',
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
    plugins: [
      new webpack.ProvidePlugin({
<span class="token deleted">-       _: 'lodash',</span>
<span class="token inserted">+       join: ['lodash', 'join'],</span>
      }),
    ],
  };</code></pre>
<p>这样就能很好的与 <a href="/guides/tree-shaking">tree shaking</a> 配合，将 <code>lodash</code> library 中的其余没有用到的导出去除。</p>
<h2 id="granular-shimming">细粒度 Shimming <a href="#granular-shimming" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>一些遗留模块依赖的 <code>this</code> 指向的是 <code>window</code> 对象。在接下来的用例中，调整我们的 <code>index.js</code>：</p>
<pre><code class="hljs language-diff">  function component() {
    const element = document.createElement('div');

    element.innerHTML = join(['Hello', 'webpack'], ' ');
<span class="token inserted">+</span>
<span class="token inserted">+   // 假设我们处于 `window` 上下文</span>
<span class="token inserted">+   this.alert('Hmmm, this probably isn\'t a great idea...')</span>

    return element;
  }

  document.body.appendChild(component());</code></pre>
<p>当模块运行在 CommonJS 上下文中，这将会变成一个问题，也就是说此时的 <code>this</code> 指向的是 <code>module.exports</code>。在这种情况下，你可以通过使用 <a href="/loaders/imports-loader/"><code>imports-loader</code></a> 覆盖 <code>this</code> 指向：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const webpack = require('webpack');

  module.exports = {
    entry: './src/index.js',
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
<span class="token inserted">+   module: {</span>
<span class="token inserted">+     rules: [</span>
<span class="token inserted">+       {</span>
<span class="token inserted">+         test: require.resolve('./src/index.js'),</span>
<span class="token inserted">+         use: 'imports-loader?this=>window',</span>
<span class="token inserted">+       },</span>
<span class="token inserted">+     ],</span>
<span class="token inserted">+   },</span>
    plugins: [
      new webpack.ProvidePlugin({
        join: ['lodash', 'join'],
      }),
    ],
  };</code></pre>
<h2 id="global-exports">全局 Exports <a href="#global-exports" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>让我们假设，某个 library 创建出一个全局变量，它期望 consumer(使用者) 使用这个变量。为此，我们可以在项目配置中，添加一个小模块来演示说明：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  |- package.json
  |- webpack.config.js
  |- /dist
  |- /src
    |- index.js
<span class="token inserted">+   |- globals.js</span>
  |- /node_modules</code></pre>
<p><strong>src/globals.js</strong></p>
<pre><code class="hljs language-js"><span class="token keyword">const</span> file <span class="token operator">=</span> <span class="token string">'blah.txt'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> helpers <span class="token operator">=</span> <span class="token punctuation">{</span>
  test<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'test something'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  parse<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'parse something'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>你可能从来没有在自己的源码中做过这些事情，但是你也许遇到过一个老旧的 library，和上面所展示的代码类似。在这种情况下，我们可以使用 <a href="/loaders/exports-loader/"><code>exports-loader</code></a>，将一个全局变量作为一个普通的模块来导出。例如，为了将 <code>file</code> 导出为 <code>file</code> 以及将 <code>helpers.parse</code> 导出为 <code>parse</code>，做如下调整：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const webpack = require('webpack');

  module.exports = {
    entry: './src/index.js',
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
    module: {
      rules: [
        {
          test: require.resolve('./src/index.js'),
          use: 'imports-loader?this=>window',
        },
<span class="token inserted">+       {</span>
<span class="token inserted">+         test: require.resolve('./src/globals.js'),</span>
<span class="token inserted">+         use: 'exports-loader?file,parse=helpers.parse',</span>
<span class="token inserted">+       },</span>
      ],
    },
    plugins: [
      new webpack.ProvidePlugin({
        join: ['lodash', 'join'],
      }),
    ],
  };</code></pre>
<p>现在，在我们的 entry 入口文件中（即 <code>src/index.js</code>），我们能 <code>import { file, parse } from './globals.js';</code> ，然后一切将顺利运行。</p>
<h2 id="loading-polyfills">加载 Polyfills <a href="#loading-polyfills" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>目前为止我们所讨论的所有内容都是处理那些遗留的 package，让我们进入到第二个话题：<strong>polyfill</strong>。</p>
<p>有很多方法来加载 polyfill。例如，想要引入 <a href="https://babel.docschina.org/docs/en/babel-polyfill/"><code>babel-polyfill</code></a> 我们只需如下操作：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save babel-polyfill</code></pre>
<p>然后，使用 <code>import</code> 将其引入到我们的主 bundle 文件：</p>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff"><span class="token inserted">+ import 'babel-polyfill';</span>
<span class="token inserted">+</span>
  function component() {
    const element = document.createElement('div');

    element.innerHTML = join(['Hello', 'webpack'], ' ');

    return element;
  }

  document.body.appendChild(component());</code></pre>
<blockquote class="tip">
<p>注意，我们没有将 <code>import</code> 绑定到某个变量。这是因为 polyfill 直接基于自身执行，并且是在基础代码执行之前，这样通过这些预置，我们就可以假定已经具有某些原生功能。</p>
</blockquote>
<p>注意，这种方式优先考虑正确性，而不考虑 bundle 体积大小。为了安全和可靠，polyfill/shim 必须<strong>运行于所有其他代码之前</strong>，而且需要同步加载，或者说，需要在所有 polyfill/shim 加载之后，再去加载所有应用程序代码。
社区中存在许多误解，即现代浏览器“不需要”polyfill，或者 polyfill/shim 仅用于添加缺失功能 - 实际上，它们通常用于<em>修复损坏实现(repair broken implementation)</em>，即使是在最现代的浏览器中，也会出现这种情况。
因此，最佳实践仍然是，不加选择地和同步地加载所有 polyfill/shim，尽管这会导致额外的 bundle 体积成本。</p>
<p>如果你认为自己已经打消这些顾虑，并且希望承受损坏的风险。那么接下来的这件事情，可能是你应该要做的：
我们将会把 <code>import</code> 放入一个新文件，并加入 <a href="https://github.com/github/fetch"><code>whatwg-fetch</code></a> polyfill：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save whatwg-fetch</code></pre>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff"><span class="token deleted">- import 'babel-polyfill';</span>
<span class="token deleted">-</span>
  function component() {
    const element = document.createElement('div');

    element.innerHTML = join(['Hello', 'webpack'], ' ');

    return element;
  }

  document.body.appendChild(component());</code></pre>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  |- package.json
  |- webpack.config.js
  |- /dist
  |- /src
    |- index.js
    |- globals.js
<span class="token inserted">+   |- polyfills.js</span>
  |- /node_modules</code></pre>
<p><strong>src/polyfills.js</strong></p>
<pre><code class="hljs language-javascript"><span class="token keyword">import</span> <span class="token string">'babel-polyfill'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'whatwg-fetch'</span><span class="token punctuation">;</span></code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const webpack = require('webpack');

  module.exports = {
<span class="token deleted">-   entry: './src/index.js',</span>
<span class="token inserted">+   entry: {</span>
<span class="token inserted">+     polyfills: './src/polyfills.js',</span>
<span class="token inserted">+     index: './src/index.js',</span>
<span class="token inserted">+   },</span>
    output: {
<span class="token deleted">-     filename: 'bundle.js',</span>
<span class="token inserted">+     filename: '[name].bundle.js',</span>
      path: path.resolve(__dirname, 'dist'),
    },
    module: {
      rules: [
        {
          test: require.resolve('./src/index.js'),
          use: 'imports-loader?this=>window',
        },
        {
          test: require.resolve('./src/globals.js'),
          use: 'exports-loader?file,parse=helpers.parse',
        },
      ],
    },
    plugins: [
      new webpack.ProvidePlugin({
        join: ['lodash', 'join'],
      }),
    ],
  };</code></pre>
<p>如上配置之后，我们可以在代码中添加一些逻辑，有条件地加载新的 <code>polyfills.bundle.js</code> 文件。根据需要支持的技术和浏览器来决定是否加载。我们将做一些简单的试验，来确定是否需要引入这些 polyfill：</p>
<p><strong>dist/index.html</strong></p>
<pre><code class="hljs language-diff">  &#x3C;!doctype html>
  &#x3C;html>
    &#x3C;head>
      &#x3C;title>Getting Started&#x3C;/title>
<span class="token inserted">+     &#x3C;script></span>
<span class="token inserted">+       const modernBrowser = (</span>
<span class="token inserted">+         'fetch' in window &#x26;&#x26;</span>
<span class="token inserted">+         'assign' in Object</span>
<span class="token inserted">+       );</span>
<span class="token inserted">+</span>
<span class="token inserted">+       if ( !modernBrowser ) {</span>
<span class="token inserted">+         const scriptElement = document.createElement('script');</span>
<span class="token inserted">+</span>
<span class="token inserted">+         scriptElement.async = false;</span>
<span class="token inserted">+         scriptElement.src = '/polyfills.bundle.js';</span>
<span class="token inserted">+         document.head.appendChild(scriptElement);</span>
<span class="token inserted">+       }</span>
<span class="token inserted">+     &#x3C;/script></span>
    &#x3C;/head>
    &#x3C;body>
      &#x3C;script src="index.bundle.js">&#x3C;/script>
    &#x3C;/body>
  &#x3C;/html></code></pre>
<p>现在，在 entry 入口文件中，可以通过 <code>fetch</code> 获取一些数据：</p>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff">  function component() {
    const element = document.createElement('div');

    element.innerHTML = join(['Hello', 'webpack'], ' ');

    return element;
  }

  document.body.appendChild(component());
<span class="token inserted">+</span>
<span class="token inserted">+ fetch('https://jsonplaceholder.typicode.com/users')</span>
<span class="token inserted">+   .then(response => response.json())</span>
<span class="token inserted">+   .then(json => {</span>
<span class="token inserted">+     console.log('We retrieved some data! AND we\'re confident it will work on a variety of browser distributions.')</span>
<span class="token inserted">+     console.log(json)</span>
<span class="token inserted">+   })</span>
<span class="token inserted">+   .catch(error => console.error('Something went wrong when fetching this data: ', error))</span></code></pre>
<p>执行构建脚本，可以看到，浏览器发送了额外的 <code>polyfills.bundle.js</code> 文件请求，然后所有代码顺利执行。注意，以上的这些设定可能还会有所改进，这里我们向你提供一个很棒的想法：将 polyfill 提供给需要引入它的用户。</p>
<h2 id="further-optimizations">进一步优化 <a href="#further-optimizations" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p><code>babel-preset-env</code> package 通过 <a href="https://github.com/browserslist/browserslist">browserslist</a> 来转译那些你浏览器中不支持的特性。这个 preset 使用 <a href="https://babel.docschina.org/docs/en/babel-preset-env#usebuiltins"><code>useBuiltIns</code></a> 选项，默认值是 <code>false</code>，这种方式可以将全局 <code>babel-polyfill</code> 导入，改进为更细粒度的 <code>import</code> 格式：</p>
<pre><code class="hljs language-js"><span class="token keyword">import</span> <span class="token string">'core-js/modules/es7.string.pad-start'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'core-js/modules/es7.string.pad-end'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'core-js/modules/web.timers'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'core-js/modules/web.immediate'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'core-js/modules/web.dom.iterable'</span><span class="token punctuation">;</span></code></pre>
<p>See <a href="https://babeljs.io/docs/en/babel-preset-env">the babel-preset-env documentation</a> for more information.</p>
<h2 id="node-built-ins">Node 内置 <a href="#node-built-ins" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>像 <code>process</code> 这种 Node 内置模块，能直接根据配置文件进行正确的 polyfill，而不需要任何特定的 loader 或者 plugin。查看 <a href="/configuration/node">node</a> 配置页面获取更多信息。</p>
<h2 id="other-utilities">其他工具 <a href="#other-utilities" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>还有一些其他的工具，也能够帮助我们处理这些遗留模块。</p>
<p>如果这些遗留模块没有 AMD/CommonJS 版本，但你也想将他们加入 <code>dist</code> 文件，则可以使用 <a href="/configuration/module/#modulenoparse"><code>noParse</code></a> 来标识出这个模块。这样就能使 webpack 将引入这些模块，但是不进行转化(parse)，以及不解析(resolve) <code>require()</code> 和 <code>import</code> 语句。这种用法还会提高构建性能。</p>
<blockquote class="warning">
<p>任何需要 AST 的功能（例如 <code>ProvidePlugin</code>）都不起作用。</p>
</blockquote>
<p>最后，一些模块支持多种 <a href="/concepts/modules">模块格式</a>，例如一个混合有 AMD、CommonJS 和 legacy(遗留) 的模块。在大多数这样的模块中，会首先检查 <code>define</code>，然后使用一些怪异代码导出一些属性。在这些情况下，可以通过 <a href="/loaders/imports-loader/"><code>imports-loader</code></a> 设置 <code>define=>false</code> 来强制 CommonJS 路径。</p>
<hr>
<blockquote class="tip">
<p>译者注：shimming 是一个库(library)，它将一个新的 API 引入到一个旧的环境中，而且仅靠旧的环境中已有的手段实现。polyfill 就是一个用在浏览器 API 上的 shimming。我们通常的做法是先检查当前浏览器是否支持某个 API，如果不支持的话就按需加载对应的 polyfill。然后新旧浏览器就都可以使用这个 API 了。</p>
</blockquote>
<h1 id="TypeScript">TypeScript<a href="#TypeScript" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<blockquote class="tip">
<p>本指南继续沿用 <a href="/guides/getting-started/"><em>起步</em></a> 中的代码示例。</p>
</blockquote>
<p><a href="https://www.typescriptlang.org">TypeScript</a> 是 JavaScript 的超集，为其增加了类型系统，可以编译为普通 JavaScript 代码。这篇指南里我们将会学习是如何将 webpack 和 TypeScript 进行集成。</p>
<h2 id="basic-setup">基础配置 <a href="#basic-setup" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>首先，执行以下命令安装 TypeScript compiler 和 loader：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev typescript ts-loader</code></pre>
<p>现在，我们将修改目录结构和配置文件：</p>
<p><strong>project</strong></p>
<pre><code class="hljs language-diff">  webpack-demo
  |- package.json
<span class="token inserted">+ |- tsconfig.json</span>
  |- webpack.config.js
  |- /dist
    |- bundle.js
    |- index.html
  |- /src
    |- index.js
<span class="token inserted">+   |- index.ts</span>
  |- /node_modules</code></pre>
<p><strong>tsconfig.json</strong></p>
<p>这里我们设置一个基本的配置，来支持 JSX，并将 TypeScript 编译到 ES5……</p>
<pre><code class="hljs language-json"><span class="token punctuation">{</span>
  <span class="token property">"compilerOptions"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"outDir"</span><span class="token operator">:</span> <span class="token string">"./dist/"</span><span class="token punctuation">,</span>
    <span class="token property">"noImplicitAny"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    <span class="token property">"module"</span><span class="token operator">:</span> <span class="token string">"es6"</span><span class="token punctuation">,</span>
    <span class="token property">"target"</span><span class="token operator">:</span> <span class="token string">"es5"</span><span class="token punctuation">,</span>
    <span class="token property">"jsx"</span><span class="token operator">:</span> <span class="token string">"react"</span><span class="token punctuation">,</span>
    <span class="token property">"allowJs"</span><span class="token operator">:</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>查看 <a href="https://www.typescriptlang.org/docs/handbook/tsconfig-json.html">TypeScript 官方文档</a> 了解更多关于 <code>tsconfig.json</code> 的配置选项。</p>
<p>想要了解 webpack 配置的更多信息，请查看 <a href="/concepts/configuration/">配置</a> 概念。</p>
<p>现在，配置 webpack 处理 TypeScript：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-js"><span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  entry<span class="token punctuation">:</span> <span class="token string">'./src/index.ts'</span><span class="token punctuation">,</span>
  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token punctuation">:</span> <span class="token regex">/\.tsx?$/</span><span class="token punctuation">,</span>
        use<span class="token punctuation">:</span> <span class="token string">'ts-loader'</span><span class="token punctuation">,</span>
        exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  resolve<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    extensions<span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">'.tsx'</span><span class="token punctuation">,</span> <span class="token string">'.ts'</span><span class="token punctuation">,</span> <span class="token string">'.js'</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    filename<span class="token punctuation">:</span> <span class="token string">'bundle.js'</span><span class="token punctuation">,</span>
    path<span class="token punctuation">:</span> path<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>__dirname<span class="token punctuation">,</span> <span class="token string">'dist'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>这会让 webpack 直接从 <code>./index.ts</code> <em>进入</em>，然后通过 <code>ts-loader</code> <em>加载</em>所有的 <code>.ts</code> 和 <code>.tsx</code> 文件，并且在当前目录<em>输出</em>一个 <code>bundle.js</code> 文件。</p>
<p>现在让我们改变 <code>lodash</code> 在 <code>./index.ts</code> 文件中的引入，
因为在 <code>lodash</code> 的定义中没有默认(default)的导出。</p>
<p><strong>./index.ts</strong></p>
<pre><code class="hljs language-diff"><span class="token deleted">- import _ from 'lodash';</span>
<span class="token inserted">+ import * as _ from 'lodash';</span>

  function component() {
    const element = document.createElement('div');

    element.innerHTML = _.join(['Hello', 'webpack'], ' ');

    return element;
  }

  document.body.appendChild(component());</code></pre>
<blockquote class="tip">
<p>如果想在 TypeScript 中保留如<code>import _ from 'lodash';</code>的语法被让它作为一种默认的导入方式，需要在文件 <strong>tsconfig.json</strong> 中设置<code>"allowSyntheticDefaultImports" : true</code> 和 <code>"esModuleInterop" : true</code> 。这个是与 TypeScript 相关的配置，在本文档中提及仅供参考。</p>
</blockquote>
<h2 id="loader">Loader <a href="#loader" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p><a href="https://github.com/TypeStrong/ts-loader"><code>ts-loader</code></a></p>
<p>在本指南中，我们使用 <code>ts-loader</code>，因为它能够很方便地启用额外的 webpack 功能，例如将其他 web 资源导入到项目中。</p>
<h2 id="source-maps">Source Maps <a href="#source-maps" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>想要了解 source map 的更多信息，请查看 <a href="/guides/development">开发</a> 指南。</p>
<p>想要启用 source map，我们必须配置 TypeScript，以将内联的 source map 输出到编译后的 JavaScript 文件中。必须在 TypeScript 配置中添加下面这行：</p>
<p><strong>tsconfig.json</strong></p>
<pre><code class="hljs language-diff">  {
    "compilerOptions": {
      "outDir": "./dist/",
<span class="token inserted">+     "sourceMap": true,</span>
      "noImplicitAny": true,
      "module": "commonjs",
      "target": "es5",
      "jsx": "react",
      "allowJs": true
    }
  }</code></pre>
<p>现在，我们需要告诉 webpack 提取这些 source map，并内联到最终的 bundle 中。</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');

  module.exports = {
    entry: './src/index.ts',
<span class="token inserted">+   devtool: 'inline-source-map',</span>
    module: {
      rules: [
        {
          test: /\.tsx?$/,
          use: 'ts-loader',
          exclude: /node_modules/,
        },
      ],
    },
    resolve: {
      extensions: [ '.tsx', '.ts', '.js' ],
    },
    output: {
      filename: 'bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
  };</code></pre>
<p>查看 <a href="/configuration/devtool/">devtool</a> 文档以了解更多信息。</p>
<h2 id="using-third-party-libraries">使用第三方类库 <a href="#using-third-party-libraries" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>在从 npm 安装 third party library(第三方库) 时，一定要记得同时安装此 library 的类型声明文件(typing definition)。你可以从 <a href="https://microsoft.github.io/TypeSearch/">TypeSearch</a> 中找到并安装这些第三方库的类型声明文件。</p>
<p>举个例子，如果想安装 lodash 类型声明文件，我们可以运行下面的命令：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev @types/lodash</code></pre>
<p>想了解更多，可以查看 <a href="https://blogs.msdn.microsoft.com/typescript/2016/06/15/the-future-of-declaration-files/">这篇文章</a>。</p>
<h2 id="importing-other-assets">导入其他资源 <a href="#importing-other-assets" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>想要在 TypeScript 中使用非代码资源(non-code asset)，我们需要告诉 TypeScript 推断导入资源的类型。在项目里创建一个 <code>custom.d.ts</code> 文件，这个文件用来表示项目中 TypeScript 的自定义类型声明。我们为 <code>.svg</code> 文件设置一个声明：</p>
<p><strong>custom.d.ts</strong></p>
<pre><code class="hljs language-typescript"><span class="token keyword">declare</span> <span class="token keyword">module</span> <span class="token string">"*.svg"</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> content<span class="token punctuation">:</span> <span class="token builtin">any</span><span class="token punctuation">;</span>
  <span class="token keyword">export</span> <span class="token keyword">default</span> content<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>H这里，我们通过指定任何以 <code>.svg</code> 结尾的导入(import)，将 SVG 声明(declare) 为一个新的模块(module)，并将模块的 <code>content</code> 定义为 <code>any</code>。我们可以通过将类型定义为字符串，来更加显式地将它声明为一个 url。同样的概念适用于其他资源，包括 CSS, SCSS, JSON 等。</p>
<h2 id="build-performance">构建性能 <a href="#build-performance" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<blockquote class="warning">
<p>这可能会降低构建性能。</p>
</blockquote>
<p>关于构建工具，请查看<a href="/guides/build-performance/">构建性能</a>指南。</p>
<h1 id="渐进式网络应用程序">渐进式网络应用程序<a href="#%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<blockquote class="tip">
<p>本指南继续沿用 <a href="/guides/output-management">管理输出</a> 中的代码示例。</p>
</blockquote>
<p>渐进式网络应用程序(progressive web application - PWA)，是一种可以提供类似于native app(原生应用程序) 体验的 web app(网络应用程序)。PWA 可以用来做很多事。其中最重要的是，在<strong>离线(offline)</strong>时应用程序能够继续运行功能。这是通过使用名为 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">Service Workers</a> 的 web 技术来实现的。</p>
<p>本章将重点介绍，如何为我们的应用程序添加离线体验。我们将使用名为 <a href="https://github.com/GoogleChrome/workbox">Workbox</a> 的 Google 项目来实现此目的，该项目提供的工具可帮助我们更简单地为 web app 提供离线支持。</p>
<h2 id="we-dont-work-offline-now">现在，我们并没有运行在离线环境下 <a href="#we-dont-work-offline-now" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>到目前为止，我们一直是直接查看本地文件系统的输出结果。通常情况下，真正的用户是通过网络访问 web app；用户的浏览器会与一个提供所需资源（例如，<code>.html</code>, <code>.js</code> 和 <code>.css</code> 文件）的 <strong>server</strong> 通讯。</p>
<p>我们通过搭建一个简易 server 下，测试下这种离线体验。这里使用 <a href="https://www.npmjs.com/package/http-server">http-server</a> package：<code>npm install http-server --save-dev</code>。还要修改 <code>package.json</code> 的 <code>scripts</code> 部分，来添加一个 <code>start</code> script：</p>
<p><strong>package.json</strong></p>
<pre><code class="hljs language-diff">{
  ...
  "scripts": {
<span class="token deleted">-    "build": "webpack"</span>
<span class="token inserted">+    "build": "webpack",</span>
<span class="token inserted">+    "start": "http-server dist"</span>
  },
  ...
}</code></pre>
<p>注意：默认情况下，<a href="/configuration/dev-server/">webpack DevServer</a> 会写入到内存。我们需要启用 <a href="/configuration/dev-server#devserverwritetodisk-">writeToDisk</a> 选项，来让 http-server 处理 <code>./dist</code> 目录中的文件。</p>
<p>如果你之前没有操作过，先得运行命令 <code>npm run build</code> 来构建你的项目。然后运行命令 <code>npm start</code>。应该产生以下输出：</p>
<pre><code class="hljs language-bash"><span class="token operator">></span> http-server dist

Starting up http-server, serving dist
Available on:
  http://xx.x.x.x:8080
  http://127.0.0.1:8080
  http://xxx.xxx.x.x:8080
Hit CTRL-C to stop the server</code></pre>
<p>如果你打开浏览器访问 <code>http://localhost:8080</code> (即 <code>http://127.0.0.1</code>)，你应该会看到 webpack 应用程序被 serve 到 <code>dist</code> 目录。如果停止 server 然后刷新，则 webpack 应用程序不再可访问。</p>
<p>这就是我们为实现离线体验所需要的改变。在本章结束时，我们应该要实现的是，停止 server 然后刷新，仍然可以看到应用程序正常运行。</p>
<h2 id="adding-workbox">添加 Workbox <a href="#adding-workbox" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>添加 workbox-webpack-plugin 插件，然后调整 <code>webpack.config.js</code> 文件：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> workbox-webpack-plugin --save-dev</code></pre>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">  const path = require('path');
  const HtmlWebpackPlugin = require('html-webpack-plugin');
  const { CleanWebpackPlugin } = require('clean-webpack-plugin');
<span class="token inserted">+ const WorkboxPlugin = require('workbox-webpack-plugin');</span>

  module.exports = {
    entry: {
      app: './src/index.js',
      print: './src/print.js',
    },
    plugins: [
      // 对于 CleanWebpackPlugin 的 v2 versions 以下版本，使用 new CleanWebpackPlugin(['dist/*'])
      new CleanWebpackPlugin(),
      new HtmlWebpackPlugin({
<span class="token deleted">-       title: 'Output Management',</span>
<span class="token inserted">+       title: 'Progressive Web Application',</span>
      }),
<span class="token inserted">+     new WorkboxPlugin.GenerateSW({</span>
<span class="token inserted">+       // 这些选项帮助快速启用 ServiceWorkers</span>
<span class="token inserted">+       // 不允许遗留任何“旧的” ServiceWorkers</span>
<span class="token inserted">+       clientsClaim: true,</span>
<span class="token inserted">+       skipWaiting: true,</span>
<span class="token inserted">+     }),</span>
    ],
    output: {
      filename: '[name].bundle.js',
      path: path.resolve(__dirname, 'dist'),
    },
  };</code></pre>
<p>完成这些设置，再次执行 <code>npm run build</code>，看下会发生什么：</p>
<pre><code class="hljs language-bash"><span class="token punctuation">..</span>.
                  Asset       Size  Chunks                    Chunk Names
          app.bundle.js     545 kB    0, 1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>  <span class="token punctuation">[</span>big<span class="token punctuation">]</span>  app
        print.bundle.js    2.74 kB       1  <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>         print
             index.html  254 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
precache-manifest.b5ca1c555e832d6fbf9462efd29d27eb.js  268 bytes          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
      service-worker.js       1 kB          <span class="token punctuation">[</span>emitted<span class="token punctuation">]</span>
<span class="token punctuation">..</span>.</code></pre>
<p>现在你可以看到，生成了两个额外的文件：<code>service-worker.js</code> 和名称冗长的 <code>precache-manifest.b5ca1c555e832d6fbf9462efd29d27eb.js</code>。<code>service-worker.js</code> 是 Service Worker 文件，<code>precache-manifest.b5ca1c555e832d6fbf9462efd29d27eb.js</code> 是 <code>service-worker.js</code> 引用的文件，所以它也可以运行。你本地生成的文件可能会有所不同；但是应该会有一个 <code>service-worker.js</code> 文件。</p>
<p>所以，值得高兴的是，我们现在已经创建出一个 Service Worker。接下来该做什么？</p>
<h2 id="registering-our-service-worker">注册 Service Worker <a href="#registering-our-service-worker" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>接下来我们注册 Service Worker，使其出场并开始表演。通过添加以下注册代码来完成此操作：</p>
<p><strong>index.js</strong></p>
<pre><code class="hljs language-diff">  import _ from 'lodash';
  import printMe from './print.js';

<span class="token inserted">+ if ('serviceWorker' in navigator) {</span>
<span class="token inserted">+   window.addEventListener('load', () => {</span>
<span class="token inserted">+     navigator.serviceWorker.register('/service-worker.js').then(registration => {</span>
<span class="token inserted">+       console.log('SW registered: ', registration);</span>
<span class="token inserted">+     }).catch(registrationError => {</span>
<span class="token inserted">+       console.log('SW registration failed: ', registrationError);</span>
<span class="token inserted">+     });</span>
<span class="token inserted">+   });</span>
<span class="token inserted">+ }</span></code></pre>
<p>再次运行 <code>npm run build</code> 来构建包含注册代码版本的应用程序。然后用 <code>npm start</code> 启动服务。访问 <code>http://localhost:8080</code> 并查看 console 控制台。在那里你应该看到：</p>
<pre><code class="hljs language-bash">SW registered</code></pre>
<p>现在来进行测试。停止 server 并刷新页面。如果浏览器能够支持 Service Worker，应该可以看到你的应用程序还在正常运行。然而，server 已经<strong>停止</strong> serve 整个 dist 文件夹，此刻是 Service Worker 在进行 serve。</p>
<h2 id="conclusion">结论 <a href="#conclusion" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>你已经使用 Workbox 项目构建了一个离线应用程序。开始进入将 web app 改造为 PWA 的旅程。你现在可能想要考虑下一步做什么。<a href="https://developers.google.com/web/progressive-web-apps/">这里</a>是可以帮助到你解决下一步问题的比较不错的资源。</p>
<h1 id="公共路径">公共路径<a href="#%E5%85%AC%E5%85%B1%E8%B7%AF%E5%BE%84" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p><code>publicPath</code> 配置选项在各种场景中都非常有用。你可以通过它来指定应用程序中所有资源的基础路径。</p>
<h2 id="use-cases">示例 <a href="#use-cases" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>下面提供一些用于实际应用程序的示例，通过这些示例，此功能显得极其简单。实质上，发送到 <code>output.path</code> 目录的每个文件，都将从 <code>output.publicPath</code> 位置引用。这也包括（通过 <a href="/guides/code-splitting/">代码分离</a> 创建的）子 chunk 和作为依赖图一部分的所有其他资源（例如 image, font 等）。</p>
<h3 id="environment-based">基于环境设置 <a href="#environment-based" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>在开发环境中，我们通常有一个 <code>assets/</code> 文件夹，它与索引页面位于同一级别。这没太大问题，但是，如果我们将所有静态资源托管至 CDN，然后想在生产环境中使用呢？</p>
<p>想要解决这个问题，可以直接使用一个有着悠久历史的 environment variable(环境变量)。假设我们有一个变量 <code>ASSET_PATH</code>：</p>
<pre><code class="hljs language-js"><span class="token keyword">import</span> webpack <span class="token keyword">from</span> <span class="token string">'webpack'</span><span class="token punctuation">;</span>

<span class="token comment">// 尝试使用环境变量，否则使用根路径</span>
<span class="token keyword">const</span> <span class="token constant">ASSET_PATH</span> <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">ASSET_PATH</span> <span class="token operator">||</span> <span class="token string">'/'</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    publicPath<span class="token punctuation">:</span> <span class="token constant">ASSET_PATH</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token comment">// 这可以帮助我们在代码中安全地使用环境变量</span>
    <span class="token keyword">new</span> <span class="token class-name">webpack<span class="token punctuation">.</span>DefinePlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token string">'process.env.ASSET_PATH'</span><span class="token punctuation">:</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token constant">ASSET_PATH</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<h3 id="on-the-fly">在运行时设置 <a href="#on-the-fly" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>另一个可能出现的情况是，需要在运行时设置 <code>publicPath</code>。webpack 暴露了一个名为 <code>__webpack_public_path__</code> 的全局变量。所以在应用程序的 entry point 中，可以直接如下设置：</p>
<pre><code class="hljs language-js">__webpack_public_path__ <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">ASSET_PATH</span><span class="token punctuation">;</span></code></pre>
<p>这些内容就是你所需要的。由于我们已经在配置中使用了 <code>DefinePlugin</code>，
<code>process.env.ASSET_PATH</code> 将始终都被定义，
因此我们可以安全地使用。</p>
<blockquote class="warning">
<p>注意，如果在 entry 文件中使用 ES2015 module import，则会在 import 之后进行 <code>__webpack_public_path__</code> 赋值。在这种情况下，你必须将 public path 赋值移至一个专用模块中，然后将它的 import 语句放置到 entry.js 最上面：</p>
</blockquote>
<pre><code class="hljs language-js"><span class="token comment">// entry.js</span>
<span class="token keyword">import</span> <span class="token string">'./public-path'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token string">'./app'</span><span class="token punctuation">;</span></code></pre>
<h1 id="集成">集成<a href="#%E9%9B%86%E6%88%90" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p>首先，我们要消除一个常见的误解。webpack 是一个模块打包工具(module bundler)（例如，<a href="http://browserify.org/">Browserify</a> 或 <a href="https://brunch.io/">Brunch</a>）。而<em>不是一个任务执行工具(task runner)</em>（例如，<a href="https://www.gnu.org/software/make/">Make</a>, <a href="https://gruntjs.com/">Grunt</a> 或者 <a href="https://gulpjs.com/">Gulp</a> ）。任务执行工具用来自动化处理常见的开发任务，例如，lint(代码检测)、build(构建)、test(测试)。相比模块打包工具，任务执行工具则聚焦在偏重上层的问题上面。你仍然可以得益于这种用法：使用上层的工具，而将打包部分的问题留给 webpack。</p>
<p>打包工具帮助你取得准备用于部署的 JavaScript 和 stylesheet，将它们转换为适合浏览器的可用格式。例如，可以通过 <a href="/plugins/terser-webpack-plugin">压缩</a>、<a href="/guides/code-splitting">分离 chunk</a> 和 <a href="/guides/lazy-loading">惰性加载</a> 我们的 JavaScript 来提高性能。打包是 web 开发中最重要的挑战之一，解决此问题可以消除开发过程中的大部分痛点。</p>
<p>好的消息是，虽然有一些功能重叠，但是如果使用方式正确，任务运行工具和模块打包工具还是能够一起协同工作。本指南提供了关于如何将 webpack 与一些流行的任务运行工具集成在一起的高度概述。</p>
<h2 id="npm-scripts">NPM Scripts <a href="#npm-scripts" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>通常 webpack 用户使用 npm <a href="https://docs.npmjs.com/misc/scripts"><code>scripts</code></a> 来作为任务执行工具。这是比较好的开始。然而跨平台支持可能是个问题，但是有几种解决方案。许多用户（但不是大多数用户）直接使用 npm <code>scripts</code> 和各种级别的 webpack 配置和工具。</p>
<p>因此，虽然 webpack 核心重点是打包，但是可以通过各种扩展，将它用于任务运行工具的常见工作。集成一个单独的工具会增加复杂度，因此在开始前一定要权衡利弊。</p>
<h2 id="grunt">Grunt <a href="#grunt" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>对于那些使用 Grunt 的人，我们推荐使用 <a href="https://www.npmjs.com/package/grunt-webpack"><code>grunt-webpack</code></a> package。使用 <code>grunt-webpack</code> 你可以将 webpack 或 <a href="https://github.com/webpack/webpack-dev-server">webpack-dev-server</a> 作为一项任务(task)执行，访问 <a href="https://gruntjs.com/api/grunt.template">grunt template tags</a> 中的统计信息，拆分开发和生产配置等等。如果还没有安装 <code>grunt-webpack</code> 和 <code>webpack</code>，请先安装它们：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev grunt-webpack webpack</code></pre>
<p>然后，注册一个配置并加载任务：</p>
<p><strong>Gruntfile.js</strong></p>
<pre><code class="hljs language-js"><span class="token keyword">const</span> webpackConfig <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./webpack.config.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>grunt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  grunt<span class="token punctuation">.</span><span class="token function">initConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    webpack<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      options<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        stats<span class="token punctuation">:</span> <span class="token operator">!</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">||</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">===</span> <span class="token string">'development'</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      prod<span class="token punctuation">:</span> webpackConfig<span class="token punctuation">,</span>
      dev<span class="token punctuation">:</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span> watch<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> webpackConfig<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  grunt<span class="token punctuation">.</span><span class="token function">loadNpmTasks</span><span class="token punctuation">(</span><span class="token string">'grunt-webpack'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>获取更多信息，请查看 <a href="https://github.com/webpack-contrib/grunt-webpack">仓库</a>。</p>
<h2 id="gulp">Gulp <a href="#gulp" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>在 <a href="https://github.com/shama/webpack-stream"><code>webpack-stream</code></a> package（也称作 <code>gulp-webpack</code>） 的帮助下，可以相当直接地将 Gulp 与 webpack 集成。在这种情况下，不需要单独安装 <code>webpack</code>，因为它是 <code>webpack-stream</code> 直接依赖：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev webpack-stream</code></pre>
<p>只要将 <code>webpack</code> 替换为 <code>require('webpack-stream')</code>，并传递一个配置：</p>
<p><strong>gulpfile.js</strong></p>
<pre><code class="hljs language-js"><span class="token keyword">const</span> gulp <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'gulp'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> webpack <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-stream'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
gulp<span class="token punctuation">.</span><span class="token function">task</span><span class="token punctuation">(</span><span class="token string">'default'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> gulp<span class="token punctuation">.</span><span class="token function">src</span><span class="token punctuation">(</span><span class="token string">'src/entry.js'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">webpack</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// Any configuration options...</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>gulp<span class="token punctuation">.</span><span class="token function">dest</span><span class="token punctuation">(</span><span class="token string">'dist/'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>获取更多信息，请查看 <a href="https://github.com/shama/webpack-stream">仓库</a>。</p>
<h2 id="mocha">Mocha <a href="#mocha" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p><a href="https://github.com/zinserjan/mocha-webpack"><code>mocha-webpack</code></a> 可以将 Mocha 与 webpack 完全集成。这个仓库提供了很多关于其优势和劣势的细节，基本上 <code>mocha-webpack</code> 只是一个简单封装，提供与 Mocha 几乎相同的 CLI，并提供各种 webpack 功能，例如改进了 watch mode 和改进了路径分析。这里是一个如何安装并使用它来运行测试套件的示例（在 <code>./test</code> 中找到）：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev webpack mocha mocha-webpack
mocha-webpack <span class="token string">'test/**/*.js'</span></code></pre>
<p>获取更多信息，请查看 <a href="https://github.com/zinserjan/mocha-webpack">仓库</a>。</p>
<h2 id="karma">Karma <a href="#karma" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p><a href="https://github.com/webpack-contrib/karma-webpack"><code>karma-webpack</code></a> package 允许你使用 webpack 预处理 <a href="https://karma-runner.github.io/1.0/index.html">Karma</a> 中的文件。它也可以使用 <a href="https://github.com/webpack/webpack-dev-middleware"><code>webpack-dev-middleware</code></a>，并允许传递两者的配置。下面是一个简单的示例：</p>
<pre><code class="hljs language-bash"><span class="token function">npm</span> <span class="token function">install</span> --save-dev webpack karma karma-webpack</code></pre>
<p><strong>karma.conf.js</strong></p>
<pre><code class="hljs language-js">module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  config<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    files<span class="token punctuation">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span> pattern<span class="token punctuation">:</span> <span class="token string">'test/*_test.js'</span><span class="token punctuation">,</span> watched<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span> pattern<span class="token punctuation">:</span> <span class="token string">'test/**/*_test.js'</span><span class="token punctuation">,</span> watched<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
    preprocessors<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token string">'test/*_test.js'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">'webpack'</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token string">'test/**/*_test.js'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span> <span class="token string">'webpack'</span> <span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    webpack<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// Any custom webpack configuration...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    webpackMiddleware<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// Any custom webpack-dev-middleware configuration...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>获取更多信息，请查看 <a href="https://github.com/webpack-contrib/karma-webpack">仓库</a>。</p>
<h1 id="entry-高级用法">entry 高级用法<a href="#entry-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<h2 id="multiple-file-types-per-entry">每个入口使用多种文件类型 <a href="#multiple-file-types-per-entry" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p>在不使用 <code>import</code> 样式文件的应用程序中（预单页应用程序或其他原因），使用一个值数组结构的 <a href="/configuration/entry-context/#entry">entry</a>，并且在其中传入不同类型的文件，可以实现将 CSS 和 JavaScript（和其他）文件分离在不同的 bundle。</p>
<p>举个例子。我们有一个具有两种页面类型的 PHP 应用程序：home(首页) 和 account(帐户)。home 与应用程序其余部分（account 页面）具有不同的布局和不可共享的 JavaScript。我们想要从应用程序文件中输出 home 页面的 <code>home.js</code> 和 <code>home.css</code>，为 account 页面输出 <code>account.js</code> 和 <code>account.css</code>。</p>
<p><strong>home.js</strong></p>
<pre><code class="hljs language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'home page type'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>home.scss</strong></p>
<pre><code class="hljs language-scss">// home page individual styles
</code></pre>
<p><strong>account.js</strong></p>
<pre><code class="hljs language-javascript">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'account page type'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p><strong>account.scss</strong></p>
<pre><code class="hljs language-scss">// account page individual styles
</code></pre>
<p>我们将在 <code>production(生产)</code> 模式中使用 <a href="/plugins/mini-css-extract-plugin/"><code>MiniCssExtractPlugin</code></a> 作为 CSS 的一个最佳实践。</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-js"><span class="token keyword">const</span> MiniCssExtractPlugin <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'mini-css-extract-plugin'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
  mode<span class="token punctuation">:</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span><span class="token punctuation">,</span>
  entry<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    home<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'./home.js'</span><span class="token punctuation">,</span> <span class="token string">'./home.scss'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    account<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'./account.js'</span><span class="token punctuation">,</span> <span class="token string">'./account.scss'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  output<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    filename<span class="token punctuation">:</span> <span class="token string">'[name].js'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  module<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span>
        test<span class="token punctuation">:</span> <span class="token regex">/\.scss$/</span><span class="token punctuation">,</span>
        use<span class="token punctuation">:</span> <span class="token punctuation">[</span>
          <span class="token comment">// fallback to style-loader in development</span>
          process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">?</span> <span class="token string">'style-loader'</span> <span class="token punctuation">:</span> MiniCssExtractPlugin<span class="token punctuation">.</span>loader<span class="token punctuation">,</span>
          <span class="token string">'css-loader'</span><span class="token punctuation">,</span>
          <span class="token string">'sass-loader'</span><span class="token punctuation">,</span>
        <span class="token punctuation">]</span><span class="token punctuation">,</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  plugins<span class="token punctuation">:</span> <span class="token punctuation">[</span>
    <span class="token keyword">new</span> <span class="token class-name">MiniCssExtractPlugin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      filename<span class="token punctuation">:</span> <span class="token string">'[name].css'</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>由于我们未指定其他输出路径，因此使用以上配置运行 webpack 将输出到 <code>./dist</code>。<code>./dist</code> 目录下现在包含四个文件：</p>
<ul>
<li>home.js</li>
<li>home.css</li>
<li>account.js</li>
<li>account.css</li>
</ul>
<h1 id="资源模块">资源模块<a href="#%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9D%97" aria-hidden="true"><span class="icon icon-link"></span></a></h1>
<p>资源模块(asset module)是一种模块类型，它允许使用资源文件（字体，图标等）而无需配置额外 loader。</p>
<p>在 webpack 5 之前，通常使用：</p>
<ul>
<li><a href="/loaders/raw-loader/"><code>raw-loader</code></a> 将文件导入为字符串</li>
<li><a href="/loaders/url-loader/"><code>url-loader</code></a> 将文件作为 data URI 内联到 bundle 中</li>
<li><a href="/loaders/file-loader/"><code>file-loader</code></a> 将文件发送到输出目录</li>
</ul>
<p>资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader：</p>
<ul>
<li><code>asset/resource</code> 发送一个单独的文件并导出 URL。之前通过使用 <code>file-loader</code> 实现。</li>
<li><code>asset/inline</code> 导出一个资源的 data URI。之前通过使用 <code>url-loader</code> 实现。</li>
<li><code>asset/source</code> 导出资源的源代码。之前通过使用 <code>raw-loader</code> 实现。</li>
<li><code>asset</code> 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 <code>url-loader</code>，并且配置资源体积限制实现。</li>
</ul>
<blockquote class="warning">
<p>这是一项实验功能。通过在 webpack 配置的 <a href="/configuration/experiments/">experiments</a> 选项中设置 <code>experiments.asset: true</code> 来开启资源模块。</p>
</blockquote>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, 'dist')
  },
<span class="token inserted">+ experiments: {</span>
<span class="token inserted">+   asset: true</span>
<span class="token inserted">+ },</span>
};</code></pre>
<h2 id="resource-assets">resource 资源(resource asset) <a href="#resource-assets" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, 'dist')
  },
  experiments: {
    asset: true
  },
<span class="token inserted">+ module: {</span>
<span class="token inserted">+   rules: [</span>
<span class="token inserted">+     {</span>
<span class="token inserted">+       test: /\.png/,</span>
<span class="token inserted">+       type: 'asset/resource'</span>
<span class="token inserted">+     }</span>
<span class="token inserted">+   ]</span>
<span class="token inserted">+ },</span>
};</code></pre>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-js"><span class="token keyword">import</span> mainImage <span class="token keyword">from</span> <span class="token string">'./images/main.png'</span><span class="token punctuation">;</span>

img<span class="token punctuation">.</span>src <span class="token operator">=</span> mainImage<span class="token punctuation">;</span> <span class="token comment">// '/dist/151cfcfa1bd74779aadb.png'</span></code></pre>
<p>所有 <code>.png</code> 文件都将被发送到输出目录，并且其路径将被注入到 bundle 中。</p>
<h3 id="custom-output-filename">自定义输出文件名 <a href="#custom-output-filename" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>默认情况下，<code>asset/resource</code> 模块以 <code>[hash][ext]</code> 文件名发送到输出目录。</p>
<p>可以通过在 webpack 配置中设置 <a href="/configuration/output/#outputassetmodulefilename"><code>output.assetModuleFilename</code></a> 来修改此模板字符串：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, 'dist'),
<span class="token inserted">+   assetModuleFilename: 'images/[hash][ext]'</span>
  },
  experiments: {
    asset: true
  },
  module: {
    rules: [
      {
        test: /\.png/,
        type: 'asset/resource'
      }
    ]
  },
};</code></pre>
<p>另一种自定义输出文件名的方式是，将某些资源发送到指定目录：</p>
<pre><code class="hljs language-diff">const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, 'dist'),
<span class="token inserted">+   assetModuleFilename: 'images/[hash][ext]'</span>
  },
  experiments: {
    asset: true
  },
  module: {
    rules: [
      {
        test: /\.png/,
        type: 'asset/resource'
<span class="token deleted">-     }</span>
<span class="token inserted">+     },</span>
<span class="token inserted">+     {</span>
<span class="token inserted">+       test: /\.html/,</span>
<span class="token inserted">+       type: 'asset/resource',</span>
<span class="token inserted">+       generator: {</span>
<span class="token inserted">+         filename: 'static/[hash][ext]'</span>
<span class="token inserted">+       }</span>
<span class="token inserted">+     }</span>
    ]
  },
};</code></pre>
<p>使用此配置，所有 <code>html</code> 文件都将被发送到输出目录中的 <code>static</code> 目录中。</p>
<p><code>Rule.generator.filename</code> 与 <a href="/configuration/output/#outputassetmodulefilename"><code>output.assetModuleFilename</code></a> 相同，并且仅适用于 <code>asset</code> 和 <code>asset/resource</code> 模块类型。</p>
<h2 id="inlining-assets">inline 资源(inlining asset) <a href="#inlining-assets" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, 'dist'),
<span class="token deleted">-   assetModuleFilename: 'images/[hash][ext]'</span>
  },
  experiments: {
    asset: true
  },
  module: {
    rules: [
      {
<span class="token deleted">-       test: /\.png/,</span>
<span class="token deleted">-       type: 'asset/resource'</span>
<span class="token inserted">+       test: /\.svg/,</span>
<span class="token inserted">+       type: 'asset/inline'</span>
<span class="token deleted">-     },</span>
<span class="token inserted">+     }</span>
<span class="token deleted">-     {</span>
<span class="token deleted">-       test: /\.html/,</span>
<span class="token deleted">-       type: 'asset/resource',</span>
<span class="token deleted">-       generator: {</span>
<span class="token deleted">-         filename: 'static/[hash][ext]'</span>
<span class="token deleted">-       }</span>
<span class="token deleted">-     }</span>
    ]
  }
};</code></pre>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff"><span class="token deleted">- import mainImage from './images/main.png';</span>
<span class="token inserted">+ import metroMap from './images/matro.svg';</span>

<span class="token deleted">- img.src = mainImage; // '/dist/151cfcfa1bd74779aadb.png'</span>
<span class="token inserted">+ block.style.background = `url(${metroMap})`; // url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDo...vc3ZnPgo=)</span></code></pre>
<p>所有 <code>.svg</code> 文件都将作为 data URI 注入到 bundle 中。</p>
<h3 id="custom-data-uri-generator">自定义 data URI 生成器 <a href="#custom-data-uri-generator" aria-hidden="true"><span class="icon icon-link"></span></a></h3>
<p>webpack 输出的 data URI，默认是呈现为使用 Base64 算法编码的文件内容。</p>
<p>如果要使用自定义编码算法，则可以指定一个自定义函数来编码文件内容：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">const path = require('path');
<span class="token inserted">+ const svgToMiniDataURI = require('mini-svg-data-uri');</span>

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, 'dist')
  },
  experiments: {
    asset: true
  },
  module: {
    rules: [
      {
        test: /\.svg/,
        type: 'asset/inline',
<span class="token inserted">+       generator: {</span>
<span class="token inserted">+         dataUrl: content => {</span>
<span class="token inserted">+           content = content.toString();</span>
<span class="token inserted">+           return svgToMiniDataURI(content);</span>
<span class="token inserted">+         }</span>
<span class="token inserted">+       }</span>
      }
    ]
  },
};</code></pre>
<p>现在，所有 <code>.svg</code> 文件都将通过 <code>mini-svg-data-uri</code> 包进行编码。</p>
<h2 id="source-assets">source 资源(source asset) <a href="#source-assets" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">const path = require('path');
<span class="token deleted">- const svgToMiniDataURI = require('mini-svg-data-uri');</span>

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, 'dist')
  },
  experiments: {
    asset: true
  },
  module: {
    rules: [
      {
<span class="token deleted">-       test: /\.svg/,</span>
<span class="token deleted">-       type: 'asset/inline',</span>
<span class="token deleted">-       generator: {</span>
<span class="token deleted">-         dataUrl: content => {</span>
<span class="token deleted">-           content = content.toString();</span>
<span class="token deleted">-           return svgToMiniDataURI(content);</span>
<span class="token deleted">-         }</span>
<span class="token deleted">-       }</span>
<span class="token inserted">+       test: /\.txt/,</span>
<span class="token inserted">+       type: 'asset/source',</span>
      }
    ]
  },
};</code></pre>
<p><strong>src/example.txt</strong></p>
<pre><code class="hljs language-text">Hello world
</code></pre>
<p><strong>src/index.js</strong></p>
<pre><code class="hljs language-diff"><span class="token deleted">- import metroMap from './images/matro.svg';</span>
<span class="token inserted">+ import exampleText from './example.txt';</span>

<span class="token deleted">- block.style.background = `url(${metroMap}); // url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDo...vc3ZnPgo=)</span>
<span class="token inserted">+ block.textContent = exampleText; // 'Hello world'</span></code></pre>
<p>所有 <code>.txt</code> 文件将原样注入到 bundle 中。</p>
<h2 id="general-asset-type">通用资源类型(general asset type) <a href="#general-asset-type" aria-hidden="true"><span class="icon icon-link"></span></a></h2>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, 'dist')
  },
  experiments: {
    asset: true
  },
  module: {
    rules: [
      {
<span class="token inserted">+       test: /\.txt/,</span>
<span class="token inserted">+       type: 'asset',</span>
      }
    ]
  },
};</code></pre>
<p>现在，webpack 将按照默认条件，自动地在 <code>resource</code> 和 <code>inline</code> 之间进行选择：小于 8kb 的文件，将会视为 <code>inline</code> 模块类型，否则会被视为 <code>resource</code> 模块类型。</p>
<p>可以通过在 webpack 配置的 module rule 层级中，设置 <a href="/configuration/module/#ruleparserdataurlcondition"><code>Rule.parser.dataUrlCondition.maxSize</code></a> 选项来修改此条件：</p>
<p><strong>webpack.config.js</strong></p>
<pre><code class="hljs language-diff">const path = require('path');

module.exports = {
  entry: './src/index.js',
  output: {
    filename: 'main.js',
    path: path.resolve(__dirname, 'dist')
  },
  experiments: {
    asset: true
  },
  module: {
    rules: [
      {
        test: /\.txt/,
        type: 'asset',
<span class="token inserted">+       parser: {</span>
<span class="token inserted">+         dataUrlCondition: {</span>
<span class="token inserted">+           maxSize: 4 * 1024 // 4kb</span>
<span class="token inserted">+         }</span>
<span class="token inserted">+       }</span>
      }
    ]
  },
};</code></pre>
<p>还可以 <a href="/configuration/module/#ruleparserdataurlcondition">指定一个函数</a> 来决定是否 inline 模块。</p>
</div><div class="contributors__section"><hr/><h3>Contributors</h3><div class="contributors"><div class="contributors__list"><a class="contributor" href="https://github.com/webpack"><img alt="webpack" src="/cb0093496837d3dc43dfae5a9104d663.png"/><span class="contributor__name"> <!-- -->webpack</span></a></div></div></div></div></section><div class="gitter"><div class="gitter__button"><i class="gitter__icon icon-gitter"></i></div></div></div><footer class="footer"><div class="container footer__inner"><section class="footer__left"><a class="footer__link" href="/guides/getting-started/">起步</a><a class="footer__link" href="/organization/">组织</a><a class="footer__link" href="/starter-kits/">配套工具</a><a class="footer__link" href="/comparison/">比较</a></section><section class="footer__middle"><a class="footer__icon" href="/"><img src="/d19378a95ebe6b15d5ddea281138dcf4.svg" alt="webpack icon"/></a></section><section class="footer__right"><a href="https://webpack.threadless.com/" target="_blank" rel="noopener" class="footer__link">商店</a><a class="footer__link" href="/glossary/">概念术语</a><a class="footer__link" href="/branding/">品牌</a><a href="https://gitter.im/webpack/webpack" target="_blank" rel="noopener" class="footer__link">Gitter</a><a href="https://github.com/webpack/webpack/releases" target="_blank" rel="noopener" class="footer__link">更新日志</a><a class="footer__link footer__license" href="/license"><img alt="Creative Commons License" src="/7052446b5e67df4434f4031afd2f1497.svg"/><img alt="Creative Commons License" src="/7ebb1b3901ce119694f65e04f6347ef5.svg"/></a></section></div></footer></div></div><script>
window.matchMedia('print').addListener(function(mql) {
  if (!mql.matches) {
      window.close();
  }
});
window.print();
</script></body></html>