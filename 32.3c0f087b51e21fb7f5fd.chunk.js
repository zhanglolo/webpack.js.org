(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{326:function(e,n,s){"use strict";s.r(n),n.default='<p>resolver 是一个帮助寻找模块绝对路径的库。\n一个模块可以作为另一个模块的依赖模块，然后被后者引用，如下：</p>\n<pre><code class="hljs language-js"><span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">\'path/to/module\'</span><span class="token punctuation">;</span>\n<span class="token comment">// 或者</span>\n<span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'path/to/module\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n<p>所依赖的模块可以是来自应用程序的代码或第三方库。\nresolver 帮助 webpack 从每个 <code>require</code>/<code>import</code> 语句中，找到需要引入到 bundle 中的模块代码。\n当打包模块时，webpack 使用 <a href="https://github.com/webpack/enhanced-resolve">enhanced-resolve</a> 来解析文件路径。</p>\n<h2 id="resolving-rules-in-webpack">webpack 中的解析规则 <a href="#resolving-rules-in-webpack" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>使用 <code>enhanced-resolve</code>，webpack 能解析三种文件路径：</p>\n<h3 id="absolute-paths">绝对路径 <a href="#absolute-paths" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<pre><code class="hljs language-js"><span class="token keyword">import</span> <span class="token string">\'/home/me/file\'</span><span class="token punctuation">;</span>\n\n<span class="token keyword">import</span> <span class="token string">\'C:\\\\Users\\\\me\\\\file\'</span><span class="token punctuation">;</span></code></pre>\n<p>由于已经获得文件的绝对路径，因此不需要再做进一步解析。</p>\n<h3 id="relative-paths">相对路径 <a href="#relative-paths" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<pre><code class="hljs language-js"><span class="token keyword">import</span> <span class="token string">\'../src/file1\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'./file2\'</span><span class="token punctuation">;</span></code></pre>\n<p>在这种情况下，使用 <code>import</code> 或 <code>require</code> 的资源文件所处的目录，被认为是上下文目录。在 <code>import/require</code> 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径。</p>\n<h3 id="module-paths">模块路径 <a href="#module-paths" aria-hidden="true"><span class="icon icon-link"></span></a></h3>\n<pre><code class="hljs language-js"><span class="token keyword">import</span> <span class="token string">\'module\'</span><span class="token punctuation">;</span>\n<span class="token keyword">import</span> <span class="token string">\'module/lib/file\'</span><span class="token punctuation">;</span></code></pre>\n<p>在 <a href="/configuration/resolve/#resolvemodules"><code>resolve.modules</code></a> 中指定的所有目录检索模块。\n你可以通过配置别名的方式来替换初始模块路径，具体请参照 <a href="/configuration/resolve/#resolvealias"><code>resolve.alias</code></a> 配置选项。</p>\n<p>一旦根据上述规则解析路径后，resolver 将会检查路径是指向文件还是文件夹。如果路径指向文件：</p>\n<ul>\n<li>如果文件具有扩展名，则直接将文件打包。</li>\n<li>否则，将使用 <a href="/configuration/resolve/#resolveextensions"><code>resolve.extensions</code></a> 选项作为文件扩展名来解析，此选项会告诉解析器在解析中能够接受那些扩展名（例如 <code>.js</code>，<code>.jsx</code>）。</li>\n</ul>\n<p>如果路径指向一个文件夹，则进行如下步骤寻找具有正确扩展名的文件：</p>\n<ul>\n<li>如果文件夹中包含 <code>package.json</code> 文件，则会根据 <a href="/configuration/resolve/#resolve-mainfields"><code>resolve.mainFields</code></a> 配置中的字段顺序查找，并根据 <code>package.json</code> 中的符合配置要求的第一个字段来确定文件路径。</li>\n<li>如果不存在 <code>package.json</code> 文件或 <a href="/configuration/resolve/#resolvemainfields"><code>resolve.mainFields</code></a> 没有返回有效路径，则会根据 <a href="/configuration/resolve/#resolvemainfiles"><code>resolve.mainFiles</code></a> 配置选项中指定的文件名顺序查找，看是否能在 import/require 的目录下匹配到一个存在的文件名。</li>\n<li>然后使用 <a href="/configuration/resolve/#resolveextensions"><code>resolve.extensions</code></a> 选项，以类似的方式解析文件扩展名。</li>\n</ul>\n<p>webpack 会根据构建目标，为这些选项提供合理的<a href="/configuration/resolve">默认</a>配置。</p>\n<h2 id="resolving-loaders">解析 loader <a href="#resolving-loaders" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>loader 的解析规则也遵循特定的规范。但是 <a href="/configuration/resolve/#resolveloader"><code>resolveLoader</code></a> 配置项可以为 loader 设置独立的解析规则。</p>\n<h2 id="caching">缓存 <a href="#caching" aria-hidden="true"><span class="icon icon-link"></span></a></h2>\n<p>每次文件系统访问文件都会被缓存，以便于更快触发对同一文件的多个并行或串行请求。在 <a href="/configuration/watch/#watch">watch 模式</a> 下，只有修改过的文件会被从缓存中移出。如果关闭 watch 模式，则会在每次编译前清理缓存。</p>\n<p>欲了解更多上述配置信息，请查阅 <a href="/configuration/resolve">Resolve API</a>。</p>\n'}}]);